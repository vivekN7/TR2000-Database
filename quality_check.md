# TR2000 Deployability & Quality Review

This document summarizes a comprehensive code review of the deploy scripts and PL/SQL packages, with focused sections on deployment readiness, validation practices, and error logging/failure modes. It concludes with concrete fixes and a safe test plan.

## Executive Summary

- The repository is well structured and close to deployable, but several critical blockers will prevent a reliable “drop and redeploy” followed by a successful ETL run.
- Most urgent fixes: identity-vs-sequence mismatches, missing prerequisites for the API proxy, incomplete control-data seeding, duplicated package bodies, and a few risky STG→core loading behaviors when upstream API/JSON are empty.
- Validation utilities exist and are solid in principle, but they are not consistently used during STG→core loads. JSON validation is defined but not enforced before parsing.
- Error logging is comprehensive, but key gaps remain (sequence use; error context fields; fail-fast gating to avoid clearing core on bad/empty JSON).

---

## Deployment Readiness Review

### Structure & Orchestration
- Master deploy is orderly and robust: `deploy/DEPLOY_ALL.sql` creates tables, sequences, indexes, views, packages, procedures, and loads control data, then compiles invalid objects and reports a summary.
- Clear separation of concerns: DDL under `01_tables`, packages under `04_packages`, control-data seed in `07_control_data`.

### Critical Blockers
- Identity vs. Sequence mismatch:
  - Code inserts use sequences (`RAW_JSON_SEQ.NEXTVAL`, `ETL_ERROR_SEQ.NEXTVAL`, `ETL_RUN_SEQ.NEXTVAL`), while tables are defined with identity columns.
  - Affected code: `PKG_API_CLIENT`, `PKG_ETL_LOGGING`, `PKG_ETL_VALIDATION` (and potentially others calling `ETL_ERROR_LOG`, `RAW_JSON`, `ETL_RUN_LOG`).
  - Affected DDL: `ETL_ERROR_LOG`, `RAW_JSON`, `ETL_RUN_LOG` are created as `GENERATED BY DEFAULT AS IDENTITY`.
  - `deploy/02_sequences/all_sequences.sql` contains an export error and likely does not define the missing sequences.

- Missing prerequisites (empty folder `deploy/00_prerequisites/`):
  - Provisioning and configuration of `API_SERVICE` schema (proxy user), including:
    - `GRANT CONNECT THROUGH API_SERVICE` to `TR2000_STAGING`.
    - Execute on `API_SERVICE.API_GATEWAY` (or creation of that package if it is your wrapper).
    - Network ACLs for outbound HTTPS (APEX_WEB_SERVICE/UTL_HTTP access).

- Incomplete control-data seeding:
  - `deploy/07_control_data/load_control_data.sql` clears `ETL_FILTER`, `CONTROL_SETTINGS`, `CONTROL_ENDPOINTS`, but seeds only `ETL_FILTER`.
  - Missing required settings:
    - `CONTROL_SETTINGS`: `API_BASE_URL`, `MAX_PCS_DETAILS_PER_RUN` (and other knobs you rely on).
    - `CONTROL_ENDPOINTS`: templates for all reference endpoints and, optionally, PCS detail endpoints.

- Duplicate package bodies in single files:
  - `deploy/04_packages/PKG_MAIN_ETL_CONTROL.sql`, `deploy/04_packages/PKG_ETL_PROCESSOR.sql`, and `deploy/04_packages/PKG_ETL_LOGGING.sql` include two `CREATE OR REPLACE ... PACKAGE BODY` blocks. This compiles but is brittle and confusing.

- DDL duplication/misplacement:
  - `deploy/01_tables/04_reference_tables.sql` erroneously includes STG table DDL that already exists in `03_staging_tables.sql`. Keep STG DDL in one file only.

### High-Impact Improvements
- Prefer identity columns and remove sequence usage in code:
  - For identity-backed tables, omit the ID column from insert lists; keep `RETURNING id INTO ...` if needed.
  - Remove `RAW_JSON_SEQ.NEXTVAL`, `ETL_ERROR_SEQ.NEXTVAL`, `ETL_RUN_SEQ.NEXTVAL` in package inserts.
  - Alternatively, if you prefer sequences, change table DDL to use explicit sequences and triggers or default `sequence.NEXTVAL` — but be consistent across DDL and code.

- Complete `00_prerequisites/`:
  - Add a script to create/verify `API_SERVICE`, grant proxy connect-through, grant required execution privileges, and set network ACLs for your API base host.

- Complete `07_control_data/load_control_data.sql` with minimal required data:
  - `CONTROL_SETTINGS`:
    - `API_BASE_URL = https://equinor.pipespec-api.presight.com`
    - `MAX_PCS_DETAILS_PER_RUN = 10` (or `0` for unlimited)
  - `CONTROL_ENDPOINTS` (keys used in code):
    - `PCS_REFERENCES` → `/plants/{plant_id}/issues/rev/{issue_revision}/pcs`
    - `VDS_REFERENCES` → `/plants/{plant_id}/issues/rev/{issue_revision}/vds`
    - `MDS_REFERENCES` → `/plants/{plant_id}/issues/rev/{issue_revision}/mds`
    - `EDS_REFERENCES` → `/plants/{plant_id}/issues/rev/{issue_revision}/eds`
    - `VSK_REFERENCES` → `/plants/{plant_id}/issues/rev/{issue_revision}/vsk`
    - `ESK_REFERENCES` → `/plants/{plant_id}/issues/rev/{issue_revision}/esk`
    - `PIPE_ELEMENT_REFERENCES` → `/plants/{plant_id}/issues/rev/{issue_revision}/pipe-elements`
    - `SC_REFERENCES` → `/plants/{plant_id}/issues/rev/{issue_revision}/sc`
    - `VSM_REFERENCES` → `/plants/{plant_id}/issues/rev/{issue_revision}/vsm`
    - `PCS_LIST` → `/plants/{plant_id}/pcs`
    - Optional PCS detail keys for consistency:
      - `PCS_HEADER_PROPERTIES` → `/plants/{plant_id}/pcs/{pcs_name}/rev/{pcs_revision}`
      - `PCS_TEMP_PRESSURES` → `.../temp-pressures`
      - `PCS_PIPE_SIZES` → `.../pipe-sizes`
      - `PCS_PIPE_ELEMENTS` → `.../pipe-elements`
      - `PCS_VALVE_ELEMENTS` → `.../valve-elements`
      - `PCS_EMBEDDED_NOTES` → `.../embedded-notes`
  - Ensure placeholders match `build_endpoint_url`: `{plant_id}`, `{issue_revision}`, `{pcs_name}`, `{pcs_revision}`.

- Remove duplicate package bodies and keep a single canonical body per file.

- Fix `04_reference_tables.sql` by removing any STG DDL; keep STG DDL only in `03_staging_tables.sql`.

- Add URL-encoding for path segments in `PKG_API_CLIENT.build_endpoint_url` or immediately before calling `API_GATEWAY.get_clob()` (e.g., wrap values using `UTL_URL.ESCAPE`), especially for `PCS_NAME`.

- SQL*Plus and DDL hygiene:
  - Add `SET DEFINE OFF` in scripts that include JSON or brace-heavy content to avoid accidental substitution.
  - Ensure consistent use of `CREATE OR REPLACE EDITIONABLE PACKAGE "TR2000_STAGING"...` across all packages (some files lack the schema qualifier and EDITIONABLE keyword). Standardize for clarity.

---

## Validation Review

### What Exists Today
- `PKG_ETL_VALIDATION` provides:
  - `safe_to_number(...)`: trims, regex-validates, logs to `ETL_ERROR_LOG` on invalid format, returns default (often NULL) rather than raising.
  - `safe_to_date(...)`: converts with flexible parsing (see package body), logs failures, returns default.
  - `validate_json(...)`: boolean check intended to validate JSON before parse.
  - `validate_required_field(...)`: records missing-field issues.
  - `validate_row_counts(...)`: logs STG vs core mismatches.
  - `check_duplicate_key(...)`: placeholder; currently returns FALSE and does not enforce/validate duplicates.

### Gaps and Risks
- Inconsistent use of safe conversions during STG→core loads:
  - Several `INSERT ... SELECT` statements in `PKG_ETL_PROCESSOR` still use `TO_NUMBER(...)` instead of `safe_to_number(...)` (e.g., PCS list `TestPressure`, PCS pipe sizes metrics, pipe element `ElementID`, etc.).
  - numeric/date conversions should consistently use safe conversion functions with `p_source_table/field/record_id` populated for traceability.

- JSON validation is not enforced:
  - Parsers (`PKG_ETL_PROCESSOR`) do not call `validate_json(...)` before `JSON_TABLE(...)`.
  - The API client logs non-2xx calls but downstream parsers still run, potentially “clearing and reloading” to empty when JSON is empty/shape-changed.

- Duplicate-key validation is not implemented:
  - `check_duplicate_key(...)` returns FALSE without checking.
  - While core tables are PK/UK constrained, explicit pre-insert checks can improve diagnostics.

### Recommendations (Validation)
- Replace all `TO_NUMBER(...)` and any raw `TO_DATE(...)` in STG→core inserts with safe functions:
  - Use `PKG_ETL_VALIDATION.safe_to_number(p_value, p_default, p_source_table, p_source_field, p_record_id)`.
  - Confirm `safe_to_date(...)` is used everywhere dates are parsed (many already call `PKG_DATE_UTILS.safe_parse_date(...)`; standardize on one safe entry-point and ensure it logs on failures).

- Enforce JSON validation before parsing:
  - In each `parse_and_load_*` procedure, call `validate_json(v_json, endpoint_key)` before `JSON_TABLE(...)`. If invalid, log and skip the clear+load step for that scope.

- Two-phase load guard:
  - Parse into STG; then verify row counts > 0 (or expected minimal fields present). Only then proceed to clear and load core for that scope. If 0 rows and error status recorded for the API call, do NOT clear core.

- Implement (or remove) `check_duplicate_key(...)`:
  - Either implement properly for diagnostics or remove from the spec to avoid a false sense of coverage.

- Post-load statistics:
  - Gather table stats after large loads: call `DBMS_STATS.GATHER_TABLE_STATS` for heavily used tables to keep plans optimal.

---

## Error Logging & Failure Modes Review

### What Exists Today
- Centralized error logging via `PKG_ETL_LOGGING.log_error(...)` and conversion logging via `PKG_ETL_VALIDATION.log_conversion_error(...)` (autonomous transaction).
- API client logs non-2xx responses as `API_CALL_ERROR` with URL and error message in `ETL_ERROR_LOG`.
- ETL run lifecycle is recorded in `ETL_RUN_LOG` and operation stats in `ETL_STATISTICS`.

### Identity vs Sequence in Logging
- `ETL_ERROR_LOG` and `ETL_RUN_LOG` use identity columns in DDL but the logging code uses sequences (`ETL_ERROR_SEQ.NEXTVAL`, `ETL_RUN_SEQ.NEXTVAL`). This will fail at runtime unless sequences exist. Standardize (recommended: identity only) and update inserts accordingly.

### Failure Scenarios and Current Behavior
- API endpoint call fails (non-2xx or exception):
  - `PKG_API_CLIENT` still inserts a RAW_JSON row (payload may be NULL) and logs an error.
  - Parsers will still run. If `JSON_TABLE(...)` returns 0 rows (e.g., empty JSON or wrong root path), the procedure will delete from core and then insert 0 rows — wiping core for that scope without new data. If `JSON_TABLE(...)` raises due to malformed JSON, the exception stops before core delete, so core remains intact.
  - Recommendation: Gate the core delete+load behind successful validation and non-zero staging rows. If the associated API call logged an error status, skip clearing core.

- Null or malformed JSON:
  - Malformed JSON typically raises during the STG insert from `JSON_TABLE(...)`, hitting the exception handler. In that path, core is not cleared (good). However, a null/empty JSON that does not error will lead to 0 rows in STG and a full clear of core for that scope (risky).

- Numeric/date conversion failures:
  - Where safe conversions are used, the error is logged to `ETL_ERROR_LOG` with `DATA_CONVERSION_*` type and the default (often NULL) is returned so the row loads with NULL. Where raw `TO_NUMBER(...)` remains, an `ORA-01722` will raise and abort the operation. This inconsistency needs to be resolved in favor of safe conversions everywhere.

- Mid-run failures and idempotency:
  - The orchestrator uses a clear-and-reload approach and is idempotent across runs. However, because parsing does the STG clear and then conditionally clears core, a partial failure in one reference type can leave some tables refreshed and others stale. This is acceptable if the process logs and can be rerun — but avoiding silent data loss on empty JSON is key.

### Recommendations (Errors & Resilience)
- Fail-fast gating:
  - If the API status is not 2xx for a batch segment, skip corresponding parsing and core clearing; log and continue.
  - If JSON validation fails or `JSON_TABLE(...)` yields 0 rows while the API call signaled an error, do not clear core.

- Enrich error context:
  - Add `PCS_NAME` and `DETAIL_TYPE` to `ETL_ERROR_LOG` to avoid overloading `ISSUE_REVISION` with unrelated context (e.g., PCS name in detail errors).
  - Consider recording the run_id in `ETL_ERROR_LOG` for easier correlation.

- Standardize logging transactions:
  - Keep conversion logging autonomous (good). For general error logging, current behavior (commit in-session) is fine; just ensure it can’t block the main flow.

- Add health checks:
  - After each parse, log STG row count and core row count, and record a `WARNING` statistic when cleared-to-zero due to empty STG.

- Add data retention and purging:
   - Create maintenance procedures/jobs to purge old rows from `RAW_JSON`, `ETL_ERROR_LOG`, and `ETL_STATISTICS` based on retention policy.

- Concurrency guard:
   - Prevent overlapping ETL runs (e.g., check `ETL_RUN_LOG` for `RUNNING` or use `DBMS_LOCK` to acquire a named lock before starting a run).

- Deterministic selection for limited PCS details:
   - When `MAX_PCS_DETAILS_PER_RUN` > 0, add `ORDER BY` (e.g., `pcs_name`) before applying `ROWNUM` to ensure stable, predictable selection.

- Integrate API call timing into stats:
   - Capture duration and payload sizes per API call and write to `ETL_STATISTICS` via `PKG_ETL_LOGGING.log_api_call`; today only the gateway stats table records this.

---

## Concrete Fix List (Actionable)

1) Standardize on identity columns; remove sequence usage from inserts in:
   - `PKG_API_CLIENT`, `PKG_ETL_LOGGING`, `PKG_ETL_VALIDATION`, and any others inserting into identity tables (`RAW_JSON`, `ETL_ERROR_LOG`, `ETL_RUN_LOG`, `ETL_STATISTICS` already uses `RETURNING`).

2) Add `deploy/00_prerequisites/` scripts to:
   - Provision `API_SERVICE`, `GRANT CONNECT THROUGH API_SERVICE` to `TR2000_STAGING`.
   - Grant execute on `API_SERVICE.API_GATEWAY` to `TR2000_STAGING`.
   - Configure network ACLs for the API host.

3) Complete `deploy/07_control_data/load_control_data.sql` with required `CONTROL_SETTINGS` and `CONTROL_ENDPOINTS` rows (see above list).

4) Remove duplicate package bodies in `PKG_MAIN_ETL_CONTROL.sql` and `PKG_ETL_PROCESSOR.sql`.

5) Fix DDL file boundaries: remove STG DDL from `04_reference_tables.sql`.

6) Replace remaining raw conversions with safe conversions in `PKG_ETL_PROCESSOR` (and anywhere else):
   - Use `PKG_ETL_VALIDATION.safe_to_number(...)` and a single safe date parser consistently.

7) Add URL-encoding for path parameters in `PKG_API_CLIENT`.

8) Introduce load gating:
   - Validate JSON; if invalid or upstream API call errored, skip core delete.
   - Only clear and load core when STG rows > 0 for that scope.

9) Optional schema tweaks for better logging:
   - Add `PCS_NAME`, `DETAIL_TYPE`, and `RUN_ID` columns to `ETL_ERROR_LOG`.

10) Housekeeping and performance:
    - Add `SET DEFINE OFF` to parser scripts where needed.
    - Standardize package DDL to use `EDITIONABLE` and schema qualifiers consistently.
    - Add `DBMS_STATS.GATHER_TABLE_STATS` after heavy loads.
    - Add purge procedures/jobs for `RAW_JSON`, `ETL_ERROR_LOG`, `ETL_STATISTICS`.
    - Add concurrency guard to avoid overlapping runs.
    - Add deterministic `ORDER BY` before `ROWNUM` limiting in PCS details.

---

## Safe Test Plan

1) Clean deploy (non-destructive to other schemas):
   - `@deploy/DROP_ALL_OBJECTS.sql`
   - `@deploy/DEPLOY_ALL.sql`

2) Post-deploy validation:
   - `SELECT * FROM CONTROL_SETTINGS WHERE setting_key IN ('API_BASE_URL','MAX_PCS_DETAILS_PER_RUN');`
   - `SELECT endpoint_key, endpoint_template FROM CONTROL_ENDPOINTS;`
   - `SELECT object_name, object_type FROM user_objects WHERE status = 'INVALID';`

3) Run ETL:
   - Optional reset: `EXEC PKG_ETL_TEST_UTILS.reset_for_testing;`
   - Main: `EXEC PKG_MAIN_ETL_CONTROL.run_main_etl;`

4) Monitor:
   - `SELECT * FROM ETL_RUN_LOG ORDER BY run_id DESC;`
   - `SELECT * FROM ETL_ERROR_LOG ORDER BY error_timestamp DESC;`
   - `SELECT * FROM API_SERVICE.API_CALL_STATS ORDER BY call_timestamp DESC;`

5) Spot-check data:
   - `SELECT COUNT(*) FROM PCS_REFERENCES;`
   - `SELECT COUNT(*) FROM PCS_LIST;`
   - `SELECT COUNT(*) FROM PCS_HEADER_PROPERTIES;`

---

## Appendix: Notable Code References

- Identity vs Sequence usage:
  - Identities in DDL: `deploy/01_tables/02_audit_tables.sql`
  - Sequence usage in code: `deploy/04_packages/PKG_API_CLIENT.sql`, `deploy/04_packages/PKG_ETL_LOGGING.sql`, `deploy/04_packages/PKG_ETL_VALIDATION.sql`

- Duplicate bodies:
  - `deploy/04_packages/PKG_MAIN_ETL_CONTROL.sql`
  - `deploy/04_packages/PKG_ETL_PROCESSOR.sql`
  - `deploy/04_packages/PKG_ETL_LOGGING.sql`

- STG DDL duplication:
  - `deploy/01_tables/04_reference_tables.sql` (contains STG DDL that belongs in `03_staging_tables.sql`)

- Safe conversion gaps:
  - `deploy/04_packages/PKG_ETL_PROCESSOR.sql` (replace remaining `TO_NUMBER(...)`, standardize date parsing)

- JSON robustness helpers:
  - `deploy/05_procedures/FIX_PCS_LIST_PARSER.sql` (supports alternate JSON shapes; should be integrated or feature-flagged)

---

# Master Checklist (Actionable Tasks)

Use the following checklists to implement and validate all recommendations. Do not delete any prior content; these tasks mirror the sections above for execution tracking.

## Deployment Readiness Tasks
- [ ] Remove sequence usage in code for identity-backed tables (`PKG_API_CLIENT`, `PKG_ETL_LOGGING`, `PKG_ETL_VALIDATION`).
- [ ] Fix `deploy/02_sequences/all_sequences.sql` (remove or only define truly needed sequences).
- [ ] Populate `deploy/00_prerequisites/` with scripts to: create/verify `API_SERVICE`, grant proxy connect-through, grant execute on `API_SERVICE.API_GATEWAY`, and configure network ACLs.
- [ ] Complete `deploy/07_control_data/load_control_data.sql` with inserts for `CONTROL_SETTINGS` (at least `API_BASE_URL`, `MAX_PCS_DETAILS_PER_RUN`).
- [ ] Seed `CONTROL_ENDPOINTS` with all endpoint templates (refs + PCS list + optional PCS details) using placeholders `{plant_id}`, `{issue_revision}`, `{pcs_name}`, `{pcs_revision}`.
- [ ] Remove duplicate package bodies from `PKG_MAIN_ETL_CONTROL.sql`, `PKG_ETL_PROCESSOR.sql`, and `PKG_ETL_LOGGING.sql`.
- [ ] Remove STG DDL from `deploy/01_tables/04_reference_tables.sql` (keep STG DDL only in `03_staging_tables.sql`).
- [ ] Add URL-encoding for path params in `PKG_API_CLIENT` (e.g., `UTL_URL.ESCAPE` for `PCS_NAME`, `PCS_REVISION`, and other path values).
- [ ] Standardize packages to `CREATE OR REPLACE EDITIONABLE PACKAGE "TR2000_STAGING"...` across all package scripts.
- [ ] Add `SET DEFINE OFF` to scripts that include JSON/brace-heavy content; re-enable if needed.

## Validation Tasks
- [ ] Replace all raw `TO_NUMBER(...)` conversions in `PKG_ETL_PROCESSOR.sql` with `PKG_ETL_VALIDATION.safe_to_number(...)` (populate `p_source_table/field/record_id`).
- [ ] Ensure all date parsing uses a single safe entry-point (`PKG_DATE_UTILS.safe_parse_date(...)` or `PKG_ETL_VALIDATION.safe_to_date(...)`) consistently.
- [ ] Call `PKG_ETL_VALIDATION.validate_json(...)` at the start of each `parse_and_load_*` before `JSON_TABLE(...)`.
- [ ] Implement two-phase gating per scope: parse into STG, verify row count > 0, only then clear+load core.
- [ ] Implement (or remove) `check_duplicate_key(...)`; if implemented, use it to log detailed duplicate diagnostics before inserts.
- [ ] Gather stats after large loads (add `DBMS_STATS.GATHER_TABLE_STATS` into end-of-step or batch summary).

## Error Logging & Resilience Tasks
- [ ] Update logging code to stop using sequences on identity-backed tables; omit ID columns in inserts.
- [ ] If API call status is non-2xx, skip parsing and core clearing for that scope; just log and continue.
- [ ] If JSON validation fails or STG row count is 0 while API call errored, do NOT clear core; log a `WARNING` statistic.
- [ ] Enrich `ETL_ERROR_LOG` schema: add `PCS_NAME`, `DETAIL_TYPE`, `RUN_ID` columns.
- [ ] Log STG/core counts per operation; record a `WARNING` when clearing to zero.
- [ ] Add purge jobs/procedures for `RAW_JSON`, `ETL_ERROR_LOG`, `ETL_STATISTICS` with retention policy.
- [ ] Add an ETL concurrency guard (single-run check or `DBMS_LOCK` named lock).
- [ ] For limited PCS detail runs, add `ORDER BY` before `ROWNUM` to ensure deterministic selection.
- [ ] Integrate per-call timing/payload size in `PKG_API_CLIENT` and write via `PKG_ETL_LOGGING.log_api_call`.

## Test Plan Tasks
- [ ] Run `@deploy/DROP_ALL_OBJECTS.sql`.
- [ ] Run `@deploy/DEPLOY_ALL.sql`.
- [ ] Validate settings: `CONTROL_SETTINGS` and `CONTROL_ENDPOINTS` contain required rows.
- [ ] Check for invalid objects: `SELECT ... FROM user_objects WHERE status = 'INVALID'`.
- [ ] Optionally reset: `EXEC PKG_ETL_TEST_UTILS.reset_for_testing;`.
- [ ] Execute ETL: `EXEC PKG_MAIN_ETL_CONTROL.run_main_etl;`.
- [ ] Review `ETL_RUN_LOG`, `ETL_ERROR_LOG`, and `API_SERVICE.API_CALL_STATS`.
- [ ] Spot-check data counts in core tables (e.g., `PCS_REFERENCES`, `PCS_LIST`, `PCS_HEADER_PROPERTIES`).

## Optional Enhancements Tasks
- [ ] Use `CONTROL_ENDPOINTS.JSON_ROOT_PATH` and `STAGING_TABLE` metadata to drive parser JSON paths dynamically instead of hardcoded paths.
- [ ] Add read-only views or synonyms for consumer access if other schemas will query core tables.
- [ ] Add retry with backoff for transient API failures (bounded retries in `PKG_API_CLIENT`).
- [ ] Add offline test harness to load canned payloads into `RAW_JSON` and drive parsers without live API.
