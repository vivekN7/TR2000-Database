-- =====================================================
-- TR2000_STAGING Complete Database Export
-- Generated: 2025-01-05
-- =====================================================

-- =====================================================
-- TABLES
-- =====================================================
-- Table: CONTROL_ENDPOINTS

  CREATE TABLE "CONTROL_ENDPOINTS" 
   (	"ENDPOINT_ID" NUMBER GENERATED BY DEFAULT AS IDENTITY MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  NOT NULL ENABLE, 
	"ENDPOINT_KEY" VARCHAR2(100) NOT NULL ENABLE, 
	"ENDPOINT_TEMPLATE" VARCHAR2(500), 
	"ENDPOINT_TYPE" VARCHAR2(50), 
	"PARENT_ENDPOINT" VARCHAR2(100), 
	"CREATED_DATE" DATE DEFAULT SYSDATE, 
	"COMMENTS" VARCHAR2(500), 
	"JSON_ROOT_PATH" VARCHAR2(200), 
	"STAGING_TABLE" VARCHAR2(50), 
	"CORE_TABLE" VARCHAR2(50), 
	 PRIMARY KEY ("ENDPOINT_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE, 
	 UNIQUE ("ENDPOINT_KEY")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE, 
	 CONSTRAINT "CHK_ENDPOINT_KEY_UPPERCASE" CHECK (endpoint_key = UPPER(endpoint_key)) ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: CONTROL_SETTINGS

  CREATE TABLE "CONTROL_SETTINGS" 
   (	"SETTING_KEY" VARCHAR2(100), 
	"SETTING_VALUE" VARCHAR2(4000), 
	"SETTING_TYPE" VARCHAR2(50), 
	"DESCRIPTION" VARCHAR2(4000), 
	"CREATED_DATE" DATE DEFAULT SYSDATE, 
	"MODIFIED_DATE" DATE DEFAULT SYSDATE, 
	"MODIFIED_BY" VARCHAR2(50), 
	 PRIMARY KEY ("SETTING_KEY")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: EDS_REFERENCES

  CREATE TABLE "EDS_REFERENCES" 
   (	"EDS_REFERENCES_GUID" RAW(16) DEFAULT SYS_GUID(), 
	"PLANT_ID" VARCHAR2(50) NOT NULL ENABLE, 
	"ISSUE_REVISION" VARCHAR2(50) NOT NULL ENABLE, 
	"EDS_NAME" VARCHAR2(100) NOT NULL ENABLE, 
	"REVISION" VARCHAR2(50), 
	"REV_DATE" DATE, 
	"STATUS" VARCHAR2(50), 
	"OFFICIAL_REVISION" VARCHAR2(50), 
	"DELTA" VARCHAR2(50), 
	"CREATED_DATE" DATE DEFAULT SYSDATE, 
	"LAST_MODIFIED_DATE" DATE DEFAULT SYSDATE, 
	 PRIMARY KEY ("EDS_REFERENCES_GUID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE, 
	 CONSTRAINT "UK_EDS_REF" UNIQUE ("PLANT_ID", "ISSUE_REVISION", "EDS_NAME")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: ESK_REFERENCES

  CREATE TABLE "ESK_REFERENCES" 
   (	"ESK_REFERENCES_GUID" RAW(16) DEFAULT SYS_GUID(), 
	"PLANT_ID" VARCHAR2(50) NOT NULL ENABLE, 
	"ISSUE_REVISION" VARCHAR2(50) NOT NULL ENABLE, 
	"ESK_NAME" VARCHAR2(100) NOT NULL ENABLE, 
	"REVISION" VARCHAR2(50), 
	"REV_DATE" DATE, 
	"STATUS" VARCHAR2(50), 
	"OFFICIAL_REVISION" VARCHAR2(50), 
	"DELTA" VARCHAR2(50), 
	"CREATED_DATE" DATE DEFAULT SYSDATE, 
	"LAST_MODIFIED_DATE" DATE DEFAULT SYSDATE, 
	 PRIMARY KEY ("ESK_REFERENCES_GUID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE, 
	 CONSTRAINT "UK_ESK_REF" UNIQUE ("PLANT_ID", "ISSUE_REVISION", "ESK_NAME")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: ETL_ERROR_LOG

  CREATE TABLE "ETL_ERROR_LOG" 
   (	"ERROR_ID" NUMBER GENERATED BY DEFAULT AS IDENTITY MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  NOT NULL ENABLE, 
	"ENDPOINT_KEY" VARCHAR2(100), 
	"PLANT_ID" VARCHAR2(50), 
	"ISSUE_REVISION" VARCHAR2(50), 
	"ERROR_TIMESTAMP" TIMESTAMP (6) DEFAULT SYSTIMESTAMP NOT NULL ENABLE, 
	"ERROR_TYPE" VARCHAR2(50), 
	"ERROR_CODE" VARCHAR2(50), 
	"ERROR_MESSAGE" VARCHAR2(4000), 
	"ERROR_STACK" CLOB, 
	"RAW_DATA" CLOB, 
	"RESOLUTION_STATUS" VARCHAR2(50), 
	"RESOLVED_BY" VARCHAR2(50), 
	"RESOLUTION_NOTES" VARCHAR2(4000), 
	 PRIMARY KEY ("ERROR_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" 
 LOB ("ERROR_STACK") STORE AS SECUREFILE (
  TABLESPACE "USERS" ENABLE STORAGE IN ROW 4000 CHUNK 8192
  NOCACHE LOGGING  NOCOMPRESS  KEEP_DUPLICATES 
  STORAGE(INITIAL 262144 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)) 
 LOB ("RAW_DATA") STORE AS SECUREFILE (
  TABLESPACE "USERS" ENABLE STORAGE IN ROW 4000 CHUNK 8192
  NOCACHE LOGGING  NOCOMPRESS  KEEP_DUPLICATES 
  STORAGE(INITIAL 262144 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT))
/
-- Table: ETL_FILTER

  CREATE TABLE "ETL_FILTER" 
   (	"FILTER_ID" NUMBER GENERATED BY DEFAULT AS IDENTITY MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  NOT NULL ENABLE, 
	"PLANT_ID" VARCHAR2(50) NOT NULL ENABLE, 
	"PLANT_NAME" VARCHAR2(200), 
	"ISSUE_REVISION" VARCHAR2(50) NOT NULL ENABLE, 
	"ADDED_DATE" DATE DEFAULT SYSDATE, 
	"ADDED_BY_USER_ID" VARCHAR2(100), 
	"NOTES" VARCHAR2(500), 
	 PRIMARY KEY ("FILTER_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE, 
	 CONSTRAINT "UK_ETL_FILTER" UNIQUE ("PLANT_ID", "ISSUE_REVISION")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: ETL_RUN_LOG

  CREATE TABLE "ETL_RUN_LOG" 
   (	"RUN_ID" NUMBER GENERATED BY DEFAULT AS IDENTITY MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  NOT NULL ENABLE, 
	"RUN_TYPE" VARCHAR2(50) NOT NULL ENABLE, 
	"START_TIME" TIMESTAMP (6) DEFAULT SYSTIMESTAMP NOT NULL ENABLE, 
	"END_TIME" TIMESTAMP (6), 
	"STATUS" VARCHAR2(50) DEFAULT 'RUNNING' NOT NULL ENABLE, 
	"INITIATED_BY" VARCHAR2(50), 
	 PRIMARY KEY ("RUN_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: ETL_STATISTICS

  CREATE TABLE "ETL_STATISTICS" 
   (	"STAT_ID" NUMBER GENERATED BY DEFAULT AS IDENTITY MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  NOT NULL ENABLE, 
	"RUN_ID" NUMBER, 
	"STAT_TYPE" VARCHAR2(50) NOT NULL ENABLE, 
	"ENDPOINT_KEY" VARCHAR2(100), 
	"OPERATION_NAME" VARCHAR2(100), 
	"PLANT_ID" VARCHAR2(50), 
	"ISSUE_REVISION" VARCHAR2(50), 
	"PCS_NAME" VARCHAR2(100), 
	"START_TIME" TIMESTAMP (6) NOT NULL ENABLE, 
	"END_TIME" TIMESTAMP (6), 
	"DURATION_MS" NUMBER GENERATED ALWAYS AS (CASE  WHEN "END_TIME" IS NOT NULL THEN EXTRACT(DAY FROM ("END_TIME"-"START_TIME")DAY(9) TO SECOND(6))*86400000+EXTRACT(HOUR FROM ("END_TIME"-"START_TIME")DAY(9) TO SECOND(6))*3600000+EXTRACT(MINUTE FROM ("END_TIME"-"START_TIME")DAY(9) TO SECOND(6))*60000+EXTRACT(SECOND FROM ("END_TIME"-"START_TIME")DAY(9) TO SECOND(6))*1000 ELSE NULL END) VIRTUAL , 
	"RECORDS_PROCESSED" NUMBER DEFAULT 0, 
	"RECORDS_INSERTED" NUMBER DEFAULT 0, 
	"RECORDS_UPDATED" NUMBER DEFAULT 0, 
	"RECORDS_DELETED" NUMBER DEFAULT 0, 
	"RECORDS_FAILED" NUMBER DEFAULT 0, 
	"API_RESPONSE_SIZE" NUMBER, 
	"API_STATUS_CODE" NUMBER, 
	"STATUS" VARCHAR2(50) DEFAULT 'RUNNING', 
	"ERROR_MESSAGE" VARCHAR2(4000), 
	"CREATED_DATE" DATE DEFAULT SYSDATE, 
	"CREATED_BY" VARCHAR2(50) DEFAULT USER, 
	 PRIMARY KEY ("STAT_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: MDS_REFERENCES

  CREATE TABLE "MDS_REFERENCES" 
   (	"MDS_REFERENCES_GUID" RAW(16) DEFAULT SYS_GUID(), 
	"PLANT_ID" VARCHAR2(50) NOT NULL ENABLE, 
	"ISSUE_REVISION" VARCHAR2(50) NOT NULL ENABLE, 
	"MDS_NAME" VARCHAR2(100) NOT NULL ENABLE, 
	"REVISION" VARCHAR2(50), 
	"AREA" VARCHAR2(100), 
	"REV_DATE" DATE, 
	"STATUS" VARCHAR2(50), 
	"OFFICIAL_REVISION" VARCHAR2(50), 
	"DELTA" VARCHAR2(50), 
	"CREATED_DATE" DATE DEFAULT SYSDATE, 
	"LAST_MODIFIED_DATE" DATE DEFAULT SYSDATE, 
	 PRIMARY KEY ("MDS_REFERENCES_GUID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE, 
	 CONSTRAINT "UK_MDS_REF" UNIQUE ("PLANT_ID", "ISSUE_REVISION", "MDS_NAME")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: PCS_EMBEDDED_NOTES

  CREATE TABLE "PCS_EMBEDDED_NOTES" 
   (	"PCS_EMBEDDED_NOTES_GUID" RAW(16) DEFAULT SYS_GUID() NOT NULL ENABLE, 
	"PLANT_ID" VARCHAR2(50) NOT NULL ENABLE, 
	"PCS_NAME" VARCHAR2(100) NOT NULL ENABLE, 
	"PCS_REVISION" VARCHAR2(50) NOT NULL ENABLE, 
	"PCSNAME" VARCHAR2(100), 
	"REVISION" VARCHAR2(50), 
	"TEXT_SECTION_ID" VARCHAR2(50), 
	"TEXT_SECTION_DESCRIPTION" VARCHAR2(500), 
	"PAGE_BREAK" VARCHAR2(50), 
	"HTML_CLOB" CLOB, 
	"CREATED_DATE" DATE DEFAULT SYSDATE, 
	"LAST_MODIFIED_DATE" DATE DEFAULT SYSDATE, 
	 CONSTRAINT "PK_PCS_EMBEDDED_NOTES" PRIMARY KEY ("PCS_EMBEDDED_NOTES_GUID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE, 
	 CONSTRAINT "UK_PCS_EMBEDDED_NOTES" UNIQUE ("PLANT_ID", "PCS_NAME", "PCS_REVISION", "TEXT_SECTION_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" 
 LOB ("HTML_CLOB") STORE AS SECUREFILE (
  TABLESPACE "USERS" ENABLE STORAGE IN ROW 4000 CHUNK 8192
  NOCACHE LOGGING  NOCOMPRESS  KEEP_DUPLICATES 
  STORAGE(INITIAL 262144 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT))
/
-- Table: PCS_HEADER_PROPERTIES

  CREATE TABLE "PCS_HEADER_PROPERTIES" 
   (	"PCS_HEADER_PROPERTIES_GUID" RAW(16) DEFAULT SYS_GUID() NOT NULL ENABLE, 
	"PLANT_ID" VARCHAR2(50) NOT NULL ENABLE, 
	"PCS_NAME" VARCHAR2(100) NOT NULL ENABLE, 
	"PCS_REVISION" VARCHAR2(50) NOT NULL ENABLE, 
	"PCS" VARCHAR2(100), 
	"REVISION" VARCHAR2(50), 
	"STATUS" VARCHAR2(50), 
	"REV_DATE" DATE, 
	"RATING_CLASS" VARCHAR2(100), 
	"TEST_PRESSURE" NUMBER(10,2), 
	"MATERIAL_GROUP" VARCHAR2(100), 
	"DESIGN_CODE" VARCHAR2(100), 
	"LAST_UPDATE" DATE, 
	"LAST_UPDATE_BY" VARCHAR2(100), 
	"APPROVER" VARCHAR2(100), 
	"NOTEPAD" CLOB, 
	"SC" VARCHAR2(100), 
	"VSM" VARCHAR2(100), 
	"DESIGN_CODE_REV_MARK" VARCHAR2(50), 
	"CORR_ALLOWANCE" NUMBER(10,2), 
	"CORR_ALLOWANCE_REV_MARK" VARCHAR2(50), 
	"LONG_WELD_EFF" NUMBER(5,2), 
	"LONG_WELD_EFF_REV_MARK" VARCHAR2(50), 
	"WALL_THK_TOL" VARCHAR2(200), 
	"WALL_THK_TOL_REV_MARK" VARCHAR2(50), 
	"SERVICE_REMARK" VARCHAR2(500), 
	"SERVICE_REMARK_REV_MARK" VARCHAR2(50), 
	"DESIGN_PRESS01" NUMBER(10,2), 
	"DESIGN_PRESS02" NUMBER(10,2), 
	"DESIGN_PRESS03" NUMBER(10,2), 
	"DESIGN_PRESS04" NUMBER(10,2), 
	"DESIGN_PRESS05" NUMBER(10,2), 
	"DESIGN_PRESS06" NUMBER(10,2), 
	"DESIGN_PRESS07" NUMBER(10,2), 
	"DESIGN_PRESS08" NUMBER(10,2), 
	"DESIGN_PRESS09" NUMBER(10,2), 
	"DESIGN_PRESS10" NUMBER(10,2), 
	"DESIGN_PRESS11" NUMBER(10,2), 
	"DESIGN_PRESS12" NUMBER(10,2), 
	"DESIGN_PRESS_REV_MARK" VARCHAR2(50), 
	"DESIGN_TEMP01" NUMBER(10,2), 
	"DESIGN_TEMP02" NUMBER(10,2), 
	"DESIGN_TEMP03" NUMBER(10,2), 
	"DESIGN_TEMP04" NUMBER(10,2), 
	"DESIGN_TEMP05" NUMBER(10,2), 
	"DESIGN_TEMP06" NUMBER(10,2), 
	"DESIGN_TEMP07" NUMBER(10,2), 
	"DESIGN_TEMP08" NUMBER(10,2), 
	"DESIGN_TEMP09" NUMBER(10,2), 
	"DESIGN_TEMP10" NUMBER(10,2), 
	"DESIGN_TEMP11" NUMBER(10,2), 
	"DESIGN_TEMP12" NUMBER(10,2), 
	"DESIGN_TEMP_REV_MARK" VARCHAR2(50), 
	"NOTE_ID_CORR_ALLOWANCE" NUMBER(10,0), 
	"NOTE_ID_SERVICE_CODE" NUMBER(10,0), 
	"NOTE_ID_WALL_THK_TOL" NUMBER(10,0), 
	"NOTE_ID_LONG_WELD_EFF" NUMBER(10,0), 
	"NOTE_ID_GENERAL_PCS" NUMBER(10,0), 
	"NOTE_ID_DESIGN_CODE" NUMBER(10,0), 
	"NOTE_ID_PRESS_TEMP_TABLE" NUMBER(10,0), 
	"NOTE_ID_PIPE_SIZE_WTH_TABLE" NUMBER(10,0), 
	"PRESS_ELEMENT_CHANGE" VARCHAR2(50), 
	"TEMP_ELEMENT_CHANGE" VARCHAR2(50), 
	"MATERIAL_GROUP_ID" NUMBER(10,0), 
	"SPECIAL_REQ_ID" NUMBER(10,0), 
	"SPECIAL_REQ" VARCHAR2(500), 
	"NEW_VDS_SECTION" VARCHAR2(100), 
	"TUBE_PCS" VARCHAR2(100), 
	"EDS_MJ_MATRIX" VARCHAR2(100), 
	"MJ_REDUCTION_FACTOR" NUMBER(5,2), 
	"CREATED_DATE" DATE DEFAULT SYSDATE, 
	"LAST_MODIFIED_DATE" DATE DEFAULT SYSDATE, 
	 CONSTRAINT "PK_PCS_HEADER_PROPS" PRIMARY KEY ("PCS_HEADER_PROPERTIES_GUID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE, 
	 CONSTRAINT "UK_PCS_HEADER" UNIQUE ("PLANT_ID", "PCS_NAME", "PCS_REVISION")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" 
 LOB ("NOTEPAD") STORE AS SECUREFILE (
  TABLESPACE "USERS" ENABLE STORAGE IN ROW 4000 CHUNK 8192
  NOCACHE LOGGING  NOCOMPRESS  KEEP_DUPLICATES 
  STORAGE(INITIAL 262144 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT))
/
-- Table: PCS_LIST

  CREATE TABLE "PCS_LIST" 
   (	"PCS_LIST_GUID" RAW(16) DEFAULT SYS_GUID() NOT NULL ENABLE, 
	"PLANT_ID" VARCHAR2(50) NOT NULL ENABLE, 
	"PCS_NAME" VARCHAR2(100) NOT NULL ENABLE, 
	"REVISION" VARCHAR2(50) NOT NULL ENABLE, 
	"STATUS" VARCHAR2(50), 
	"REV_DATE" DATE, 
	"RATING_CLASS" VARCHAR2(100), 
	"TEST_PRESSURE" NUMBER(10,2), 
	"MATERIAL_GROUP" VARCHAR2(100), 
	"DESIGN_CODE" VARCHAR2(100), 
	"LAST_UPDATE" DATE, 
	"LAST_UPDATE_BY" VARCHAR2(100), 
	"APPROVER" VARCHAR2(100), 
	"NOTEPAD" CLOB, 
	"SPECIAL_REQ_ID" NUMBER(10,0), 
	"TUBE_PCS" VARCHAR2(100), 
	"NEW_VDS_SECTION" VARCHAR2(100), 
	"CREATED_DATE" DATE DEFAULT SYSDATE, 
	"LAST_MODIFIED_DATE" DATE DEFAULT SYSDATE, 
	 CONSTRAINT "PK_PCS_LIST" PRIMARY KEY ("PCS_LIST_GUID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE, 
	 CONSTRAINT "UK_PCS_LIST" UNIQUE ("PLANT_ID", "PCS_NAME", "REVISION")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" 
 LOB ("NOTEPAD") STORE AS SECUREFILE (
  TABLESPACE "USERS" ENABLE STORAGE IN ROW 4000 CHUNK 8192
  NOCACHE LOGGING  NOCOMPRESS  KEEP_DUPLICATES 
  STORAGE(INITIAL 262144 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT))
/
-- Table: PCS_PIPE_ELEMENTS

  CREATE TABLE "PCS_PIPE_ELEMENTS" 
   (	"PCS_PIPE_ELEMENTS_GUID" RAW(16) DEFAULT SYS_GUID() NOT NULL ENABLE, 
	"PLANT_ID" VARCHAR2(50) NOT NULL ENABLE, 
	"PCS_NAME" VARCHAR2(100) NOT NULL ENABLE, 
	"PCS_REVISION" VARCHAR2(50) NOT NULL ENABLE, 
	"PCS" VARCHAR2(100), 
	"REVISION" VARCHAR2(50), 
	"MATERIAL_GROUP_ID" NUMBER(10,0), 
	"ELEMENT_GROUP_NO" NUMBER(10,0), 
	"LINE_NO" NUMBER(10,0), 
	"ELEMENT" VARCHAR2(200), 
	"DIM_STANDARD" VARCHAR2(100), 
	"FROM_SIZE" VARCHAR2(50), 
	"TO_SIZE" VARCHAR2(50), 
	"PRODUCT_FORM" VARCHAR2(100), 
	"MATERIAL" VARCHAR2(200), 
	"MDS" VARCHAR2(100), 
	"EDS" VARCHAR2(100), 
	"EDS_REVISION" VARCHAR2(50), 
	"ESK" VARCHAR2(100), 
	"REVMARK" VARCHAR2(50), 
	"REMARK" VARCHAR2(500), 
	"PAGE_BREAK" VARCHAR2(50), 
	"ELEMENT_ID" NUMBER(10,0), 
	"FREE_TEXT" VARCHAR2(500), 
	"NEW_DELETED_LINE" VARCHAR2(50), 
	"INITIAL_INFO" VARCHAR2(200), 
	"INITIAL_REVMARK" VARCHAR2(50), 
	"MDS_VARIANT" VARCHAR2(100), 
	"MDS_REVISION" VARCHAR2(50), 
	"AREA" VARCHAR2(100), 
	"CREATED_DATE" DATE DEFAULT SYSDATE, 
	"LAST_MODIFIED_DATE" DATE DEFAULT SYSDATE, 
	"NOTE_ID" VARCHAR2(50), 
	 CONSTRAINT "PK_PCS_PIPE_ELEMENTS" PRIMARY KEY ("PCS_PIPE_ELEMENTS_GUID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE, 
	 CONSTRAINT "UK_PCS_PIPE_ELEMENTS" UNIQUE ("PLANT_ID", "PCS_NAME", "PCS_REVISION", "ELEMENT_GROUP_NO", "LINE_NO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: PCS_PIPE_SIZES

  CREATE TABLE "PCS_PIPE_SIZES" 
   (	"PCS_PIPE_SIZES_GUID" RAW(16) DEFAULT SYS_GUID() NOT NULL ENABLE, 
	"PLANT_ID" VARCHAR2(50) NOT NULL ENABLE, 
	"PCS_NAME" VARCHAR2(100) NOT NULL ENABLE, 
	"PCS_REVISION" VARCHAR2(50) NOT NULL ENABLE, 
	"PCS" VARCHAR2(100), 
	"REVISION" VARCHAR2(50), 
	"NOM_SIZE" VARCHAR2(50), 
	"OUTER_DIAM" NUMBER(10,2), 
	"WALL_THICKNESS" NUMBER(10,3), 
	"SCHEDULE" VARCHAR2(50), 
	"UNDER_TOLERANCE" NUMBER(10,3), 
	"CORROSION_ALLOWANCE" NUMBER(10,3), 
	"WELDING_FACTOR" NUMBER(5,3), 
	"DIM_ELEMENT_CHANGE" VARCHAR2(50), 
	"SCHEDULE_IN_MATRIX" VARCHAR2(50), 
	"CREATED_DATE" DATE DEFAULT SYSDATE, 
	"LAST_MODIFIED_DATE" DATE DEFAULT SYSDATE, 
	 CONSTRAINT "PK_PCS_PIPE_SIZES" PRIMARY KEY ("PCS_PIPE_SIZES_GUID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE, 
	 CONSTRAINT "UK_PCS_PIPE_SIZES" UNIQUE ("PLANT_ID", "PCS_NAME", "PCS_REVISION", "NOM_SIZE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: PCS_REFERENCES

  CREATE TABLE "PCS_REFERENCES" 
   (	"PCS_REFERENCES_GUID" RAW(16) DEFAULT SYS_GUID(), 
	"PLANT_ID" VARCHAR2(50) NOT NULL ENABLE, 
	"ISSUE_REVISION" VARCHAR2(50) NOT NULL ENABLE, 
	"PCS_NAME" VARCHAR2(100) NOT NULL ENABLE, 
	"REVISION" VARCHAR2(50), 
	"REV_DATE" DATE, 
	"STATUS" VARCHAR2(50), 
	"OFFICIAL_REVISION" VARCHAR2(50), 
	"REVISION_SUFFIX" VARCHAR2(50), 
	"RATING_CLASS" VARCHAR2(100), 
	"MATERIAL_GROUP" VARCHAR2(100), 
	"HISTORICAL_PCS" VARCHAR2(500), 
	"DELTA" VARCHAR2(50), 
	"CREATED_DATE" DATE DEFAULT SYSDATE, 
	"LAST_MODIFIED_DATE" DATE DEFAULT SYSDATE, 
	 PRIMARY KEY ("PCS_REFERENCES_GUID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE, 
	 CONSTRAINT "UK_PCS_REF" UNIQUE ("PLANT_ID", "ISSUE_REVISION", "PCS_NAME")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: PCS_TEMP_PRESSURES

  CREATE TABLE "PCS_TEMP_PRESSURES" 
   (	"PCS_TEMP_PRESSURES_GUID" RAW(16) DEFAULT SYS_GUID() NOT NULL ENABLE, 
	"PLANT_ID" VARCHAR2(50) NOT NULL ENABLE, 
	"PCS_NAME" VARCHAR2(100) NOT NULL ENABLE, 
	"PCS_REVISION" VARCHAR2(50) NOT NULL ENABLE, 
	"TEMPERATURE" NUMBER(10,2), 
	"PRESSURE" NUMBER(10,2), 
	"CREATED_DATE" DATE DEFAULT SYSDATE, 
	"LAST_MODIFIED_DATE" DATE DEFAULT SYSDATE, 
	 CONSTRAINT "PK_PCS_TEMP_PRESSURES" PRIMARY KEY ("PCS_TEMP_PRESSURES_GUID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE, 
	 CONSTRAINT "UK_PCS_TEMP_PRESSURES" UNIQUE ("PLANT_ID", "PCS_NAME", "PCS_REVISION", "TEMPERATURE", "PRESSURE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: PCS_VALVE_ELEMENTS

  CREATE TABLE "PCS_VALVE_ELEMENTS" 
   (	"PCS_VALVE_ELEMENTS_GUID" RAW(16) DEFAULT SYS_GUID() NOT NULL ENABLE, 
	"PLANT_ID" VARCHAR2(50) NOT NULL ENABLE, 
	"PCS_NAME" VARCHAR2(100) NOT NULL ENABLE, 
	"PCS_REVISION" VARCHAR2(50) NOT NULL ENABLE, 
	"VALVE_GROUP_NO" NUMBER(10,0), 
	"LINE_NO" NUMBER(10,0), 
	"VALVE_TYPE" VARCHAR2(100), 
	"VDS" VARCHAR2(100), 
	"VALVE_DESCRIPTION" VARCHAR2(500), 
	"FROM_SIZE" VARCHAR2(50), 
	"TO_SIZE" VARCHAR2(50), 
	"REVMARK" VARCHAR2(50), 
	"REMARK" VARCHAR2(500), 
	"PAGE_BREAK" VARCHAR2(50), 
	"NOTE_ID" VARCHAR2(50), 
	"PREVIOUS_VDS" VARCHAR2(100), 
	"NEW_DELETED_LINE" VARCHAR2(50), 
	"INITIAL_INFO" VARCHAR2(200), 
	"INITIAL_REVMARK" VARCHAR2(50), 
	"SIZE_RANGE" VARCHAR2(100), 
	"STATUS" VARCHAR2(50), 
	"REVISION" VARCHAR2(50), 
	"CREATED_DATE" DATE DEFAULT SYSDATE, 
	"LAST_MODIFIED_DATE" DATE DEFAULT SYSDATE, 
	 CONSTRAINT "PK_PCS_VALVE_ELEMENTS" PRIMARY KEY ("PCS_VALVE_ELEMENTS_GUID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE, 
	 CONSTRAINT "UK_PCS_VALVE_ELEMENTS" UNIQUE ("PLANT_ID", "PCS_NAME", "PCS_REVISION", "VALVE_GROUP_NO", "LINE_NO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: PIPE_ELEMENT_REFERENCES

  CREATE TABLE "PIPE_ELEMENT_REFERENCES" 
   (	"PIPE_ELEMENT_REFERENCES_GUID" RAW(16) DEFAULT SYS_GUID() NOT NULL ENABLE, 
	"PLANT_ID" VARCHAR2(50) NOT NULL ENABLE, 
	"ISSUE_REVISION" VARCHAR2(50) NOT NULL ENABLE, 
	"ELEMENT_ID" NUMBER NOT NULL ENABLE, 
	"ELEMENT_GROUP" VARCHAR2(200), 
	"DIMENSION_STANDARD" VARCHAR2(200), 
	"PRODUCT_FORM" VARCHAR2(200), 
	"MATERIAL_GRADE" VARCHAR2(200), 
	"MDS" VARCHAR2(100), 
	"MDS_REVISION" VARCHAR2(50), 
	"AREA" VARCHAR2(100), 
	"REVISION" VARCHAR2(50), 
	"REV_DATE" DATE, 
	"STATUS" VARCHAR2(50), 
	"DELTA" VARCHAR2(50), 
	"CREATED_DATE" DATE DEFAULT SYSDATE NOT NULL ENABLE, 
	"LAST_MODIFIED_DATE" DATE DEFAULT SYSDATE NOT NULL ENABLE, 
	 CONSTRAINT "PK_PIPE_ELEMENT_REFERENCES" PRIMARY KEY ("PIPE_ELEMENT_REFERENCES_GUID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE, 
	 CONSTRAINT "UK_PIPE_ELEMENT_REF" UNIQUE ("PLANT_ID", "ISSUE_REVISION", "ELEMENT_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: RAW_JSON

  CREATE TABLE "RAW_JSON" 
   (	"RAW_JSON_ID" NUMBER GENERATED BY DEFAULT AS IDENTITY MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  NOT NULL ENABLE, 
	"ENDPOINT_KEY" VARCHAR2(100), 
	"ENDPOINT_TEMPLATE" VARCHAR2(500), 
	"ENDPOINT_VALUE" VARCHAR2(500) NOT NULL ENABLE, 
	"PAYLOAD" CLOB, 
	"BATCH_ID" VARCHAR2(36), 
	"API_CALL_TIMESTAMP" TIMESTAMP (6) DEFAULT SYSTIMESTAMP, 
	"CREATED_DATE" DATE DEFAULT SYSDATE NOT NULL ENABLE, 
	"KEY_FINGERPRINT" VARCHAR2(64), 
	 PRIMARY KEY ("RAW_JSON_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" 
 LOB ("PAYLOAD") STORE AS SECUREFILE (
  TABLESPACE "USERS" ENABLE STORAGE IN ROW 4000 CHUNK 8192
  NOCACHE LOGGING  NOCOMPRESS  KEEP_DUPLICATES 
  STORAGE(INITIAL 262144 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT))
/
-- Table: SC_REFERENCES

  CREATE TABLE "SC_REFERENCES" 
   (	"SC_REFERENCES_GUID" RAW(16) DEFAULT SYS_GUID(), 
	"PLANT_ID" VARCHAR2(50) NOT NULL ENABLE, 
	"ISSUE_REVISION" VARCHAR2(50) NOT NULL ENABLE, 
	"SC_NAME" VARCHAR2(100) NOT NULL ENABLE, 
	"REVISION" VARCHAR2(50), 
	"REV_DATE" DATE, 
	"STATUS" VARCHAR2(50), 
	"OFFICIAL_REVISION" VARCHAR2(50), 
	"DELTA" VARCHAR2(50), 
	"CREATED_DATE" DATE DEFAULT SYSDATE, 
	"LAST_MODIFIED_DATE" DATE DEFAULT SYSDATE, 
	 PRIMARY KEY ("SC_REFERENCES_GUID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE, 
	 CONSTRAINT "UK_SC_REF" UNIQUE ("PLANT_ID", "ISSUE_REVISION", "SC_NAME")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: STG_EDS_REFERENCES

  CREATE TABLE "STG_EDS_REFERENCES" 
   (	"PLANT_ID" VARCHAR2(50), 
	"ISSUE_REVISION" VARCHAR2(50), 
	"EDS" VARCHAR2(100), 
	"Revision" VARCHAR2(50), 
	"RevDate" VARCHAR2(50), 
	"Status" VARCHAR2(50), 
	"OfficialRevision" VARCHAR2(50), 
	"Delta" VARCHAR2(50)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: STG_ESK_REFERENCES

  CREATE TABLE "STG_ESK_REFERENCES" 
   (	"PLANT_ID" VARCHAR2(50), 
	"ISSUE_REVISION" VARCHAR2(50), 
	"ESK" VARCHAR2(100), 
	"Revision" VARCHAR2(50), 
	"RevDate" VARCHAR2(50), 
	"Status" VARCHAR2(50), 
	"OfficialRevision" VARCHAR2(50), 
	"Delta" VARCHAR2(50)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: STG_MDS_REFERENCES

  CREATE TABLE "STG_MDS_REFERENCES" 
   (	"PLANT_ID" VARCHAR2(50), 
	"ISSUE_REVISION" VARCHAR2(50), 
	"MDS" VARCHAR2(100), 
	"Revision" VARCHAR2(50), 
	"Area" VARCHAR2(100), 
	"RevDate" VARCHAR2(50), 
	"Status" VARCHAR2(50), 
	"OfficialRevision" VARCHAR2(50), 
	"Delta" VARCHAR2(50)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: STG_PCS_EMBEDDED_NOTES

  CREATE TABLE "STG_PCS_EMBEDDED_NOTES" 
   (	"PLANT_ID" VARCHAR2(50), 
	"PCS_NAME" VARCHAR2(100), 
	"PCS_REVISION" VARCHAR2(50), 
	"PCSName" VARCHAR2(100), 
	"Revision" VARCHAR2(50), 
	"TextSectionID" VARCHAR2(50), 
	"TextSectionDescription" VARCHAR2(500), 
	"PageBreak" VARCHAR2(50), 
	"HTMLCLOB" CLOB
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" 
 LOB ("HTMLCLOB") STORE AS SECUREFILE (
  TABLESPACE "USERS" ENABLE STORAGE IN ROW 4000 CHUNK 8192
  NOCACHE LOGGING  NOCOMPRESS  KEEP_DUPLICATES 
  STORAGE(INITIAL 262144 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT))
/
-- Table: STG_PCS_HEADER_PROPERTIES

  CREATE TABLE "STG_PCS_HEADER_PROPERTIES" 
   (	"PLANT_ID" VARCHAR2(50), 
	"PCS_NAME" VARCHAR2(100), 
	"PCS_REVISION" VARCHAR2(50), 
	"PCS" VARCHAR2(100), 
	"Revision" VARCHAR2(50), 
	"Status" VARCHAR2(50), 
	"RevDate" VARCHAR2(50), 
	"RatingClass" VARCHAR2(100), 
	"TestPressure" VARCHAR2(50), 
	"MaterialGroup" VARCHAR2(100), 
	"DesignCode" VARCHAR2(100), 
	"LastUpdate" VARCHAR2(50), 
	"LastUpdateBy" VARCHAR2(100), 
	"Approver" VARCHAR2(100), 
	"Notepad" VARCHAR2(4000), 
	"SC" VARCHAR2(100), 
	"VSM" VARCHAR2(100), 
	"DesignCodeRevMark" VARCHAR2(50), 
	"CorrAllowance" VARCHAR2(50), 
	"CorrAllowanceRevMark" VARCHAR2(50), 
	"LongWeldEff" VARCHAR2(50), 
	"LongWeldEffRevMark" VARCHAR2(50), 
	"WallThkTol" VARCHAR2(50), 
	"WallThkTolRevMark" VARCHAR2(50), 
	"ServiceRemark" VARCHAR2(500), 
	"ServiceRemarkRevMark" VARCHAR2(50), 
	"DesignPress01" VARCHAR2(50), 
	"DesignPress02" VARCHAR2(50), 
	"DesignPress03" VARCHAR2(50), 
	"DesignPress04" VARCHAR2(50), 
	"DesignPress05" VARCHAR2(50), 
	"DesignPress06" VARCHAR2(50), 
	"DesignPress07" VARCHAR2(50), 
	"DesignPress08" VARCHAR2(50), 
	"DesignPress09" VARCHAR2(50), 
	"DesignPress10" VARCHAR2(50), 
	"DesignPress11" VARCHAR2(50), 
	"DesignPress12" VARCHAR2(50), 
	"DesignPressRevMark" VARCHAR2(50), 
	"DesignTemp01" VARCHAR2(50), 
	"DesignTemp02" VARCHAR2(50), 
	"DesignTemp03" VARCHAR2(50), 
	"DesignTemp04" VARCHAR2(50), 
	"DesignTemp05" VARCHAR2(50), 
	"DesignTemp06" VARCHAR2(50), 
	"DesignTemp07" VARCHAR2(50), 
	"DesignTemp08" VARCHAR2(50), 
	"DesignTemp09" VARCHAR2(50), 
	"DesignTemp10" VARCHAR2(50), 
	"DesignTemp11" VARCHAR2(50), 
	"DesignTemp12" VARCHAR2(50), 
	"DesignTempRevMark" VARCHAR2(50), 
	"NoteIDCorrAllowance" VARCHAR2(50), 
	"NoteIDServiceCode" VARCHAR2(50), 
	"NoteIDWallThkTol" VARCHAR2(50), 
	"NoteIDLongWeldEff" VARCHAR2(50), 
	"NoteIDGeneralPCS" VARCHAR2(50), 
	"NoteIDDesignCode" VARCHAR2(50), 
	"NoteIDPressTempTable" VARCHAR2(50), 
	"NoteIDPipeSizeWthTable" VARCHAR2(50), 
	"PressElementChange" VARCHAR2(50), 
	"TempElementChange" VARCHAR2(50), 
	"MaterialGroupID" VARCHAR2(50), 
	"SpecialReqID" VARCHAR2(50), 
	"SpecialReq" VARCHAR2(500), 
	"NewVDSSection" VARCHAR2(100), 
	"TubePCS" VARCHAR2(100), 
	"EDSMJMatrix" VARCHAR2(100), 
	"MJReductionFactor" VARCHAR2(50)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: STG_PCS_LIST

  CREATE TABLE "STG_PCS_LIST" 
   (	"PLANT_ID" VARCHAR2(50), 
	"PCS" VARCHAR2(100), 
	"Revision" VARCHAR2(50), 
	"Status" VARCHAR2(50), 
	"RevDate" VARCHAR2(50), 
	"RatingClass" VARCHAR2(100), 
	"TestPressure" VARCHAR2(50), 
	"MaterialGroup" VARCHAR2(100), 
	"DesignCode" VARCHAR2(100), 
	"LastUpdate" VARCHAR2(50), 
	"LastUpdateBy" VARCHAR2(100), 
	"Approver" VARCHAR2(100), 
	"Notepad" VARCHAR2(4000), 
	"SpecialReqID" VARCHAR2(50), 
	"TubePCS" VARCHAR2(100), 
	"NewVDSSection" VARCHAR2(100)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: STG_PCS_PIPE_ELEMENTS

  CREATE TABLE "STG_PCS_PIPE_ELEMENTS" 
   (	"PLANT_ID" VARCHAR2(50), 
	"PCS_NAME" VARCHAR2(100), 
	"PCS_REVISION" VARCHAR2(50), 
	"PCS" VARCHAR2(100), 
	"Revision" VARCHAR2(50), 
	"MaterialGroupID" VARCHAR2(50), 
	"ElementGroupNo" VARCHAR2(50), 
	"LineNo" VARCHAR2(50), 
	"Element" VARCHAR2(200), 
	"DimStandard" VARCHAR2(100), 
	"FromSize" VARCHAR2(50), 
	"ToSize" VARCHAR2(50), 
	"ProductForm" VARCHAR2(100), 
	"Material" VARCHAR2(200), 
	"MDS" VARCHAR2(100), 
	"EDS" VARCHAR2(100), 
	"EDSRevision" VARCHAR2(50), 
	"ESK" VARCHAR2(100), 
	"Revmark" VARCHAR2(50), 
	"Remark" VARCHAR2(4000), 
	"PageBreak" VARCHAR2(50), 
	"ElementID" VARCHAR2(50), 
	"FreeText" VARCHAR2(500), 
	"NoteID" VARCHAR2(50), 
	"NewDeletedLine" VARCHAR2(50), 
	"InitialInfo" VARCHAR2(4000), 
	"InitialRevmark" VARCHAR2(50), 
	"MDSVariant" VARCHAR2(100), 
	"MDSRevision" VARCHAR2(50), 
	"Area" VARCHAR2(100)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: STG_PCS_PIPE_SIZES

  CREATE TABLE "STG_PCS_PIPE_SIZES" 
   (	"PLANT_ID" VARCHAR2(50), 
	"PCS_NAME" VARCHAR2(100), 
	"PCS_REVISION" VARCHAR2(50), 
	"PCS" VARCHAR2(100), 
	"Revision" VARCHAR2(50), 
	"NomSize" VARCHAR2(50), 
	"OuterDiam" VARCHAR2(50), 
	"WallThickness" VARCHAR2(50), 
	"Schedule" VARCHAR2(50), 
	"UnderTolerance" VARCHAR2(50), 
	"CorrosionAllowance" VARCHAR2(50), 
	"WeldingFactor" VARCHAR2(50), 
	"DimElementChange" VARCHAR2(50), 
	"ScheduleInMatrix" VARCHAR2(50)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: STG_PCS_REFERENCES

  CREATE TABLE "STG_PCS_REFERENCES" 
   (	"PLANT_ID" VARCHAR2(50), 
	"ISSUE_REVISION" VARCHAR2(50), 
	"PCS" VARCHAR2(100), 
	"Revision" VARCHAR2(50), 
	"RevDate" VARCHAR2(50), 
	"Status" VARCHAR2(50), 
	"OfficialRevision" VARCHAR2(50), 
	"RevisionSuffix" VARCHAR2(50), 
	"RatingClass" VARCHAR2(100), 
	"MaterialGroup" VARCHAR2(100), 
	"HistoricalPCS" VARCHAR2(500), 
	"Delta" VARCHAR2(50)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: STG_PCS_TEMP_PRESSURES

  CREATE TABLE "STG_PCS_TEMP_PRESSURES" 
   (	"PLANT_ID" VARCHAR2(50), 
	"PCS_NAME" VARCHAR2(100), 
	"PCS_REVISION" VARCHAR2(50), 
	"Temperature" VARCHAR2(50), 
	"Pressure" VARCHAR2(50)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: STG_PCS_VALVE_ELEMENTS

  CREATE TABLE "STG_PCS_VALVE_ELEMENTS" 
   (	"PLANT_ID" VARCHAR2(50), 
	"PCS_NAME" VARCHAR2(100), 
	"PCS_REVISION" VARCHAR2(50), 
	"ValveGroupNo" VARCHAR2(50), 
	"LineNo" VARCHAR2(50), 
	"ValveType" VARCHAR2(100), 
	"VDS" VARCHAR2(100), 
	"ValveDescription" VARCHAR2(4000), 
	"FromSize" VARCHAR2(50), 
	"ToSize" VARCHAR2(50), 
	"Revmark" VARCHAR2(50), 
	"Remark" VARCHAR2(4000), 
	"PageBreak" VARCHAR2(50), 
	"NoteID" VARCHAR2(50), 
	"PreviousVDS" VARCHAR2(100), 
	"NewDeletedLine" VARCHAR2(50), 
	"InitialInfo" VARCHAR2(4000), 
	"InitialRevmark" VARCHAR2(50), 
	"SizeRange" VARCHAR2(100), 
	"Status" VARCHAR2(50), 
	"Revision" VARCHAR2(50)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: STG_PIPE_ELEMENT_REFERENCES

  CREATE TABLE "STG_PIPE_ELEMENT_REFERENCES" 
   (	"PLANT_ID" VARCHAR2(50), 
	"ISSUE_REVISION" VARCHAR2(50), 
	"ElementGroup" VARCHAR2(200), 
	"DimensionStandard" VARCHAR2(200), 
	"ProductForm" VARCHAR2(200), 
	"MaterialGrade" VARCHAR2(200), 
	"MDS" VARCHAR2(100), 
	"MDSRevision" VARCHAR2(50), 
	"Area" VARCHAR2(100), 
	"ElementID" VARCHAR2(50), 
	"Revision" VARCHAR2(50), 
	"RevDate" VARCHAR2(50), 
	"Status" VARCHAR2(50), 
	"Delta" VARCHAR2(50)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: STG_SC_REFERENCES

  CREATE TABLE "STG_SC_REFERENCES" 
   (	"PLANT_ID" VARCHAR2(50), 
	"ISSUE_REVISION" VARCHAR2(50), 
	"SC" VARCHAR2(100), 
	"Revision" VARCHAR2(50), 
	"RevDate" VARCHAR2(50), 
	"Status" VARCHAR2(50), 
	"OfficialRevision" VARCHAR2(50), 
	"Delta" VARCHAR2(50)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: STG_VDS_LIST

  CREATE TABLE "STG_VDS_LIST" 
   (	"VDS" VARCHAR2(100), 
	"Revision" VARCHAR2(50), 
	"Status" VARCHAR2(50), 
	"RevDate" VARCHAR2(50), 
	"LastUpdate" VARCHAR2(50), 
	"LastUpdateBy" VARCHAR2(100), 
	"Description" VARCHAR2(500), 
	"Notepad" VARCHAR2(4000), 
	"SpecialReqID" VARCHAR2(50), 
	"ValveTypeID" VARCHAR2(50), 
	"RatingClassID" VARCHAR2(50), 
	"MaterialGroupID" VARCHAR2(50), 
	"EndConnectionID" VARCHAR2(50), 
	"BoreID" VARCHAR2(50), 
	"VDSSizeID" VARCHAR2(50), 
	"SizeRange" VARCHAR2(100), 
	"CustomName" VARCHAR2(200), 
	"SubsegmentList" VARCHAR2(500)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: STG_VDS_REFERENCES

  CREATE TABLE "STG_VDS_REFERENCES" 
   (	"PLANT_ID" VARCHAR2(50), 
	"ISSUE_REVISION" VARCHAR2(50), 
	"VDS" VARCHAR2(100), 
	"Revision" VARCHAR2(50), 
	"RevDate" VARCHAR2(50), 
	"Status" VARCHAR2(50), 
	"OfficialRevision" VARCHAR2(50), 
	"Delta" VARCHAR2(50)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: STG_VSK_REFERENCES

  CREATE TABLE "STG_VSK_REFERENCES" 
   (	"PLANT_ID" VARCHAR2(50), 
	"ISSUE_REVISION" VARCHAR2(50), 
	"VSK" VARCHAR2(100), 
	"Revision" VARCHAR2(50), 
	"RevDate" VARCHAR2(50), 
	"Status" VARCHAR2(50), 
	"OfficialRevision" VARCHAR2(50), 
	"Delta" VARCHAR2(50)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: STG_VSM_REFERENCES

  CREATE TABLE "STG_VSM_REFERENCES" 
   (	"PLANT_ID" VARCHAR2(50), 
	"ISSUE_REVISION" VARCHAR2(50), 
	"VSM" VARCHAR2(100), 
	"Revision" VARCHAR2(50), 
	"RevDate" VARCHAR2(50), 
	"Status" VARCHAR2(50), 
	"OfficialRevision" VARCHAR2(50), 
	"Delta" VARCHAR2(50)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: VDS_LIST

  CREATE TABLE "VDS_LIST" 
   (	"VDS_LIST_GUID" RAW(16) DEFAULT SYS_GUID() NOT NULL ENABLE, 
	"VDS_NAME" VARCHAR2(100) NOT NULL ENABLE, 
	"REVISION" VARCHAR2(50), 
	"STATUS" VARCHAR2(50), 
	"REV_DATE" DATE, 
	"LAST_UPDATE" DATE, 
	"LAST_UPDATE_BY" VARCHAR2(100), 
	"DESCRIPTION" VARCHAR2(4000), 
	"NOTEPAD" VARCHAR2(4000), 
	"SPECIAL_REQ_ID" NUMBER, 
	"VALVE_TYPE_ID" NUMBER, 
	"RATING_CLASS_ID" NUMBER, 
	"MATERIAL_GROUP_ID" NUMBER, 
	"END_CONNECTION_ID" NUMBER, 
	"BORE_ID" NUMBER, 
	"VDS_SIZE_ID" NUMBER, 
	"SIZE_RANGE" VARCHAR2(100), 
	"CUSTOM_NAME" VARCHAR2(200), 
	"SUBSEGMENT_LIST" VARCHAR2(4000), 
	"CREATED_DATE" DATE DEFAULT SYSDATE, 
	"LAST_MODIFIED_DATE" DATE DEFAULT SYSDATE, 
	 CONSTRAINT "PK_VDS_LIST" PRIMARY KEY ("VDS_LIST_GUID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE, 
	 CONSTRAINT "UK_VDS_LIST_NAME_REV" UNIQUE ("VDS_NAME", "REVISION")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: VDS_REFERENCES

  CREATE TABLE "VDS_REFERENCES" 
   (	"VDS_REFERENCES_GUID" RAW(16) DEFAULT SYS_GUID(), 
	"PLANT_ID" VARCHAR2(50) NOT NULL ENABLE, 
	"ISSUE_REVISION" VARCHAR2(50) NOT NULL ENABLE, 
	"VDS_NAME" VARCHAR2(100) NOT NULL ENABLE, 
	"REVISION" VARCHAR2(50), 
	"REV_DATE" DATE, 
	"STATUS" VARCHAR2(50), 
	"OFFICIAL_REVISION" VARCHAR2(50), 
	"DELTA" VARCHAR2(50), 
	"CREATED_DATE" DATE DEFAULT SYSDATE, 
	"LAST_MODIFIED_DATE" DATE DEFAULT SYSDATE, 
	 PRIMARY KEY ("VDS_REFERENCES_GUID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE, 
	 CONSTRAINT "UK_VDS_REF" UNIQUE ("PLANT_ID", "ISSUE_REVISION", "VDS_NAME")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: VSK_REFERENCES

  CREATE TABLE "VSK_REFERENCES" 
   (	"VSK_REFERENCES_GUID" RAW(16) DEFAULT SYS_GUID(), 
	"PLANT_ID" VARCHAR2(50) NOT NULL ENABLE, 
	"ISSUE_REVISION" VARCHAR2(50) NOT NULL ENABLE, 
	"VSK_NAME" VARCHAR2(100) NOT NULL ENABLE, 
	"REVISION" VARCHAR2(50), 
	"REV_DATE" DATE, 
	"STATUS" VARCHAR2(50), 
	"OFFICIAL_REVISION" VARCHAR2(50), 
	"DELTA" VARCHAR2(50), 
	"CREATED_DATE" DATE DEFAULT SYSDATE, 
	"LAST_MODIFIED_DATE" DATE DEFAULT SYSDATE, 
	 PRIMARY KEY ("VSK_REFERENCES_GUID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE, 
	 CONSTRAINT "UK_VSK_REF" UNIQUE ("PLANT_ID", "ISSUE_REVISION", "VSK_NAME")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- Table: VSM_REFERENCES

  CREATE TABLE "VSM_REFERENCES" 
   (	"VSM_REFERENCES_GUID" RAW(16) DEFAULT SYS_GUID(), 
	"PLANT_ID" VARCHAR2(50) NOT NULL ENABLE, 
	"ISSUE_REVISION" VARCHAR2(50) NOT NULL ENABLE, 
	"VSM_NAME" VARCHAR2(100) NOT NULL ENABLE, 
	"REVISION" VARCHAR2(50), 
	"REV_DATE" DATE, 
	"STATUS" VARCHAR2(50), 
	"OFFICIAL_REVISION" VARCHAR2(50), 
	"DELTA" VARCHAR2(50), 
	"CREATED_DATE" DATE DEFAULT SYSDATE, 
	"LAST_MODIFIED_DATE" DATE DEFAULT SYSDATE, 
	 PRIMARY KEY ("VSM_REFERENCES_GUID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE, 
	 CONSTRAINT "UK_VSM_REF" UNIQUE ("PLANT_ID", "ISSUE_REVISION", "VSM_NAME")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/
-- =====================================================
-- SEQUENCES
-- =====================================================
ERROR:
ORA-31603: object "ISEQ$$_98025" of type SEQUENCE not found in schema "TR2000_STAGING"
ORA-06512: at "SYS.DBMS_METADATA", line 6781
ORA-06512: at "SYS.DBMS_SYS_ERROR", line 105
ORA-06512: at "SYS.DBMS_METADATA", line 6768
ORA-06512: at "SYS.DBMS_METADATA", line 9815
ORA-06512: at line 1


-- =====================================================
-- INDEXES
-- =====================================================

  CREATE INDEX "TR2000_STAGING"."IDX_EDS_REF_ISSUE" ON "TR2000_STAGING"."EDS_REFERENCES" ("ISSUE_REVISION")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_EDS_REF_PLANT" ON "TR2000_STAGING"."EDS_REFERENCES" ("PLANT_ID")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_ESK_REF_ISSUE" ON "TR2000_STAGING"."ESK_REFERENCES" ("ISSUE_REVISION")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_ESK_REF_PLANT" ON "TR2000_STAGING"."ESK_REFERENCES" ("PLANT_ID")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_ETL_ERROR_COMPOSITE" ON "TR2000_STAGING"."ETL_ERROR_LOG" ("PLANT_ID", "ENDPOINT_KEY", "ERROR_TIMESTAMP")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_ETL_ERROR_TIMESTAMP" ON "TR2000_STAGING"."ETL_ERROR_LOG" ("ERROR_TIMESTAMP")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_ETL_LOG_STATUS" ON "TR2000_STAGING"."ETL_RUN_LOG" ("STATUS")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_ETL_LOG_TIME" ON "TR2000_STAGING"."ETL_RUN_LOG" ("START_TIME")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_ETL_STATS_ENDPOINT" ON "TR2000_STAGING"."ETL_STATISTICS" ("ENDPOINT_KEY")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_ETL_STATS_RUN_ID" ON "TR2000_STAGING"."ETL_STATISTICS" ("RUN_ID")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_ETL_STATS_START_TIME" ON "TR2000_STAGING"."ETL_STATISTICS" ("START_TIME")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_ETL_STATS_TYPE" ON "TR2000_STAGING"."ETL_STATISTICS" ("STAT_TYPE")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_MDS_REF_AREA" ON "TR2000_STAGING"."MDS_REFERENCES" ("AREA")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_MDS_REF_ISSUE" ON "TR2000_STAGING"."MDS_REFERENCES" ("ISSUE_REVISION")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_MDS_REF_PLANT" ON "TR2000_STAGING"."MDS_REFERENCES" ("PLANT_ID")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_PCS_HEADER_PCS" ON "TR2000_STAGING"."PCS_HEADER_PROPERTIES" ("PCS_NAME")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_PCS_HEADER_PLANT" ON "TR2000_STAGING"."PCS_HEADER_PROPERTIES" ("PLANT_ID")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_PCS_HEADER_REV" ON "TR2000_STAGING"."PCS_HEADER_PROPERTIES" ("PCS_REVISION")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_PCS_LIST_PCS" ON "TR2000_STAGING"."PCS_LIST" ("PCS_NAME")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_PCS_LIST_PLANT" ON "TR2000_STAGING"."PCS_LIST" ("PLANT_ID")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_PCS_LIST_REV" ON "TR2000_STAGING"."PCS_LIST" ("REVISION")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_PCS_REF_ISSUE" ON "TR2000_STAGING"."PCS_REFERENCES" ("ISSUE_REVISION")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_PCS_REF_PLANT" ON "TR2000_STAGING"."PCS_REFERENCES" ("PLANT_ID")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_PIPE_ELEM_REF_ELEMENT_ID" ON "TR2000_STAGING"."PIPE_ELEMENT_REFERENCES" ("ELEMENT_ID")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_PIPE_ELEM_REF_PLANT_ISSUE" ON "TR2000_STAGING"."PIPE_ELEMENT_REFERENCES" ("PLANT_ID", "ISSUE_REVISION")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_RAW_JSON_BATCH_ID" ON "TR2000_STAGING"."RAW_JSON" ("BATCH_ID")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_RAW_JSON_CREATED" ON "TR2000_STAGING"."RAW_JSON" ("CREATED_DATE")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_RAW_JSON_ENDPOINT_KEY" ON "TR2000_STAGING"."RAW_JSON" ("ENDPOINT_KEY")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_RAW_JSON_FINGERPRINT" ON "TR2000_STAGING"."RAW_JSON" ("KEY_FINGERPRINT")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_SC_REF_ISSUE" ON "TR2000_STAGING"."SC_REFERENCES" ("ISSUE_REVISION")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_SC_REF_PLANT" ON "TR2000_STAGING"."SC_REFERENCES" ("PLANT_ID")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_VDS_LIST_NAME" ON "TR2000_STAGING"."VDS_LIST" ("VDS_NAME")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_VDS_LIST_STATUS" ON "TR2000_STAGING"."VDS_LIST" ("STATUS")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_VDS_REF_ISSUE" ON "TR2000_STAGING"."VDS_REFERENCES" ("ISSUE_REVISION")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_VDS_REF_PLANT" ON "TR2000_STAGING"."VDS_REFERENCES" ("PLANT_ID")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_VSK_REF_ISSUE" ON "TR2000_STAGING"."VSK_REFERENCES" ("ISSUE_REVISION")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_VSK_REF_PLANT" ON "TR2000_STAGING"."VSK_REFERENCES" ("PLANT_ID")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_VSM_REF_ISSUE" ON "TR2000_STAGING"."VSM_REFERENCES" ("ISSUE_REVISION")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE INDEX "TR2000_STAGING"."IDX_VSM_REF_PLANT" ON "TR2000_STAGING"."VSM_REFERENCES" ("PLANT_ID")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE UNIQUE INDEX "TR2000_STAGING"."PK_PCS_EMBEDDED_NOTES" ON "TR2000_STAGING"."PCS_EMBEDDED_NOTES" ("PCS_EMBEDDED_NOTES_GUID")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE UNIQUE INDEX "TR2000_STAGING"."PK_PCS_HEADER_PROPS" ON "TR2000_STAGING"."PCS_HEADER_PROPERTIES" ("PCS_HEADER_PROPERTIES_GUID")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE UNIQUE INDEX "TR2000_STAGING"."PK_PCS_LIST" ON "TR2000_STAGING"."PCS_LIST" ("PCS_LIST_GUID")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE UNIQUE INDEX "TR2000_STAGING"."PK_PCS_PIPE_ELEMENTS" ON "TR2000_STAGING"."PCS_PIPE_ELEMENTS" ("PCS_PIPE_ELEMENTS_GUID")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE UNIQUE INDEX "TR2000_STAGING"."PK_PCS_PIPE_SIZES" ON "TR2000_STAGING"."PCS_PIPE_SIZES" ("PCS_PIPE_SIZES_GUID")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE UNIQUE INDEX "TR2000_STAGING"."PK_PCS_TEMP_PRESSURES" ON "TR2000_STAGING"."PCS_TEMP_PRESSURES" ("PCS_TEMP_PRESSURES_GUID")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE UNIQUE INDEX "TR2000_STAGING"."PK_PCS_VALVE_ELEMENTS" ON "TR2000_STAGING"."PCS_VALVE_ELEMENTS" ("PCS_VALVE_ELEMENTS_GUID")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE UNIQUE INDEX "TR2000_STAGING"."PK_PIPE_ELEMENT_REFERENCES" ON "TR2000_STAGING"."PIPE_ELEMENT_REFERENCES" ("PIPE_ELEMENT_REFERENCES_GUID")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE UNIQUE INDEX "TR2000_STAGING"."PK_VDS_LIST" ON "TR2000_STAGING"."VDS_LIST" ("VDS_LIST_GUID")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE UNIQUE INDEX "TR2000_STAGING"."UK_EDS_REF" ON "TR2000_STAGING"."EDS_REFERENCES" ("PLANT_ID", "ISSUE_REVISION", "EDS_NAME")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE UNIQUE INDEX "TR2000_STAGING"."UK_ESK_REF" ON "TR2000_STAGING"."ESK_REFERENCES" ("PLANT_ID", "ISSUE_REVISION", "ESK_NAME")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE UNIQUE INDEX "TR2000_STAGING"."UK_ETL_FILTER" ON "TR2000_STAGING"."ETL_FILTER" ("PLANT_ID", "ISSUE_REVISION")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE UNIQUE INDEX "TR2000_STAGING"."UK_MDS_REF" ON "TR2000_STAGING"."MDS_REFERENCES" ("PLANT_ID", "ISSUE_REVISION", "MDS_NAME")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE UNIQUE INDEX "TR2000_STAGING"."UK_PCS_EMBEDDED_NOTES" ON "TR2000_STAGING"."PCS_EMBEDDED_NOTES" ("PLANT_ID", "PCS_NAME", "PCS_REVISION", "TEXT_SECTION_ID")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE UNIQUE INDEX "TR2000_STAGING"."UK_PCS_HEADER" ON "TR2000_STAGING"."PCS_HEADER_PROPERTIES" ("PLANT_ID", "PCS_NAME", "PCS_REVISION")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE UNIQUE INDEX "TR2000_STAGING"."UK_PCS_LIST" ON "TR2000_STAGING"."PCS_LIST" ("PLANT_ID", "PCS_NAME", "REVISION")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE UNIQUE INDEX "TR2000_STAGING"."UK_PCS_PIPE_ELEMENTS" ON "TR2000_STAGING"."PCS_PIPE_ELEMENTS" ("PLANT_ID", "PCS_NAME", "PCS_REVISION", "ELEMENT_GROUP_NO", "LINE_NO")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE UNIQUE INDEX "TR2000_STAGING"."UK_PCS_PIPE_SIZES" ON "TR2000_STAGING"."PCS_PIPE_SIZES" ("PLANT_ID", "PCS_NAME", "PCS_REVISION", "NOM_SIZE")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE UNIQUE INDEX "TR2000_STAGING"."UK_PCS_REF" ON "TR2000_STAGING"."PCS_REFERENCES" ("PLANT_ID", "ISSUE_REVISION", "PCS_NAME")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE UNIQUE INDEX "TR2000_STAGING"."UK_PCS_TEMP_PRESSURES" ON "TR2000_STAGING"."PCS_TEMP_PRESSURES" ("PLANT_ID", "PCS_NAME", "PCS_REVISION", "TEMPERATURE", "PRESSURE")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE UNIQUE INDEX "TR2000_STAGING"."UK_PCS_VALVE_ELEMENTS" ON "TR2000_STAGING"."PCS_VALVE_ELEMENTS" ("PLANT_ID", "PCS_NAME", "PCS_REVISION", "VALVE_GROUP_NO", "LINE_NO")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE UNIQUE INDEX "TR2000_STAGING"."UK_PIPE_ELEMENT_REF" ON "TR2000_STAGING"."PIPE_ELEMENT_REFERENCES" ("PLANT_ID", "ISSUE_REVISION", "ELEMENT_ID")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE UNIQUE INDEX "TR2000_STAGING"."UK_SC_REF" ON "TR2000_STAGING"."SC_REFERENCES" ("PLANT_ID", "ISSUE_REVISION", "SC_NAME")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE UNIQUE INDEX "TR2000_STAGING"."UK_VDS_LIST_NAME_REV" ON "TR2000_STAGING"."VDS_LIST" ("VDS_NAME", "REVISION")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE UNIQUE INDEX "TR2000_STAGING"."UK_VDS_REF" ON "TR2000_STAGING"."VDS_REFERENCES" ("PLANT_ID", "ISSUE_REVISION", "VDS_NAME")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE UNIQUE INDEX "TR2000_STAGING"."UK_VSK_REF" ON "TR2000_STAGING"."VSK_REFERENCES" ("PLANT_ID", "ISSUE_REVISION", "VSK_NAME")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/


  CREATE UNIQUE INDEX "TR2000_STAGING"."UK_VSM_REF" ON "TR2000_STAGING"."VSM_REFERENCES" ("PLANT_ID", "ISSUE_REVISION", "VSM_NAME")
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"
/

-- =====================================================
-- VIEWS
-- =====================================================

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "TR2000_STAGING"."V_API_CALLS_PER_RUN" ("RUN_ID", "RUN_TYPE", "RUN_START", "RUN_END", "RUN_STATUS", "UNIQUE_ENDPOINTS_CALLED", "TOTAL_API_CALLS", "API_CALL_COUNT", "PROCESSING_COUNT", "TOTAL_DATA_MB", "AVG_DURATION_MS", "TOTAL_DURATION_SECONDS", "TOTAL_RECORDS_PROCESSED", "TOTAL_RECORDS_INSERTED") AS
  SELECT
    r.run_id,
    r.run_type,
    r.start_time as run_start,
    r.end_time as run_end,
    r.status as run_status,
    COUNT(DISTINCT s.endpoint_key) as unique_endpoints_called,
    COUNT(*) as total_api_calls,
    SUM(CASE WHEN s.stat_type = 'API_CALL' THEN 1 ELSE 0 END) as api_call_count,
    SUM(CASE WHEN s.stat_type = 'PROCESSING' THEN 1 ELSE 0 END) as processing_count,
    SUM(s.api_response_size)/1024/1024 as total_data_mb,
    AVG(s.duration_ms) as avg_duration_ms,
    SUM(s.duration_ms)/1000 as total_duration_seconds,
    SUM(s.records_processed) as total_records_processed,
    SUM(s.records_inserted) as total_records_inserted
FROM ETL_RUN_LOG r
LEFT JOIN ETL_STATISTICS s ON r.run_id = s.run_id
GROUP BY r.run_id, r.run_type, r.start_time, r.end_time, r.status
ORDER BY r.run_id DESC
/


  CREATE OR REPLACE FORCE EDITIONABLE VIEW "TR2000_STAGING"."V_API_CALL_STATISTICS" ("ENDPOINT_KEY", "TOTAL_CALLS", "AVG_RESPONSE_TIME_MS", "MIN_RESPONSE_TIME_MS", "MAX_RESPONSE_TIME_MS", "TOTAL_DATA_MB", "AVG_RESPONSE_KB", "SUCCESSFUL_CALLS", "FAILED_CALLS", "LAST_CALL_TIME") AS
  SELECT
    endpoint_key,
    COUNT(*) as total_calls,
    AVG(duration_ms) as avg_response_time_ms,
    MIN(duration_ms) as min_response_time_ms,
    MAX(duration_ms) as max_response_time_ms,
    SUM(api_response_size)/1024/1024 as total_data_mb,
    AVG(api_response_size)/1024 as avg_response_kb,
    SUM(CASE WHEN api_status_code BETWEEN 200 AND 299 THEN 1 ELSE 0 END) as successful_calls,
    SUM(CASE WHEN api_status_code >= 400 THEN 1 ELSE 0 END) as failed_calls,
    MAX(start_time) as last_call_time
FROM ETL_STATISTICS
WHERE stat_type = 'API_CALL'
GROUP BY endpoint_key
ORDER BY total_calls DESC
/


  CREATE OR REPLACE FORCE EDITIONABLE VIEW "TR2000_STAGING"."V_API_OPTIMIZATION_CANDIDATES" ("ENDPOINT_KEY", "CALL_COUNT", "RUN_COUNT", "AVG_CALLS_PER_RUN", "AVG_DURATION_MS", "TOTAL_TIME_SECONDS", "PCT_OF_TOTAL_TIME", "VOLUME_CATEGORY", "OPTIMIZATION_PRIORITY") AS
  WITH endpoint_stats AS (
    SELECT
        endpoint_key,
        COUNT(*) as call_count,
        AVG(duration_ms) as avg_duration_ms,
        SUM(duration_ms) as total_duration_ms,
        COUNT(DISTINCT run_id) as run_count
    FROM ETL_STATISTICS
    WHERE stat_type = 'API_CALL'
    AND endpoint_key IS NOT NULL
    GROUP BY endpoint_key
)
SELECT
    endpoint_key,
    call_count,
    run_count,
    ROUND(call_count / NULLIF(run_count, 0), 2) as avg_calls_per_run,
    ROUND(avg_duration_ms, 2) as avg_duration_ms,
    ROUND(total_duration_ms/1000, 2) as total_time_seconds,
    ROUND(total_duration_ms * 100.0 / SUM(total_duration_ms) OVER(), 2) as pct_of_total_time,
    CASE
        WHEN call_count / NULLIF(run_count, 0) > 50 THEN 'HIGH_VOLUME'
        WHEN call_count / NULLIF(run_count, 0) > 10 THEN 'MEDIUM_VOLUME'
        ELSE 'LOW_VOLUME'
    END as volume_category,
    CASE
        WHEN total_duration_ms > 60000 THEN 'OPTIMIZE_CRITICAL'
        WHEN total_duration_ms > 30000 THEN 'OPTIMIZE_RECOMMENDED'
        ELSE 'OK'
    END as optimization_priority
FROM endpoint_stats
ORDER BY call_count DESC
/


  CREATE OR REPLACE FORCE EDITIONABLE VIEW "TR2000_STAGING"."V_ENDPOINT_TABLE_STATISTICS" ("ENDPOINT_KEY", "TARGET_TABLE", "TOTAL_CALLS", "RUNS_WITH_THIS_ENDPOINT", "AVG_CALLS_PER_RUN", "TOTAL_RECORDS_PROCESSED", "TOTAL_RECORDS_INSERTED", "AVG_DURATION_MS", "MAX_DURATION_MS", "TOTAL_DATA_MB", "LAST_CALLED") AS
  SELECT
    endpoint_key,
    CASE
        WHEN endpoint_key = 'PCS_REFERENCES' THEN 'PCS_REFERENCES'
        WHEN endpoint_key = 'VDS_REFERENCES' THEN 'VDS_REFERENCES'
        WHEN endpoint_key = 'MDS_REFERENCES' THEN 'MDS_REFERENCES'
        WHEN endpoint_key = 'EDS_REFERENCES' THEN 'EDS_REFERENCES'
        WHEN endpoint_key = 'VSK_REFERENCES' THEN 'VSK_REFERENCES'
        WHEN endpoint_key = 'ESK_REFERENCES' THEN 'ESK_REFERENCES'
        WHEN endpoint_key = 'PIPE_ELEMENT_REFERENCES' THEN 'PIPE_ELEMENT_REFERENCES'
        WHEN endpoint_key = 'SC_REFERENCES' THEN 'SC_REFERENCES'
        WHEN endpoint_key = 'VSM_REFERENCES' THEN 'VSM_REFERENCES'
        WHEN endpoint_key = 'PCS_LIST' THEN 'PCS_LIST'
        WHEN endpoint_key = 'PCS_HEADER_PROPERTIES' THEN 'PCS_HEADER_PROPERTIES'
        WHEN endpoint_key = 'PCS_TEMP_PRESSURES' THEN 'PCS_TEMP_PRESSURES'
        WHEN endpoint_key = 'PCS_PIPE_SIZES' THEN 'PCS_PIPE_SIZES'
        WHEN endpoint_key = 'PCS_PIPE_ELEMENTS' THEN 'PCS_PIPE_ELEMENTS'
        WHEN endpoint_key = 'PCS_VALVE_ELEMENTS' THEN 'PCS_VALVE_ELEMENTS'
        WHEN endpoint_key = 'PCS_EMBEDDED_NOTES' THEN 'PCS_EMBEDDED_NOTES'
        WHEN endpoint_key = 'VDS_CATALOG' THEN 'VDS_LIST'
        ELSE 'UNKNOWN'
    END as target_table,
    COUNT(*) as total_calls,
    COUNT(DISTINCT run_id) as runs_with_this_endpoint,
    ROUND(COUNT(*) / COUNT(DISTINCT run_id), 2) as avg_calls_per_run,
    SUM(records_processed) as total_records_processed,
    SUM(records_inserted) as total_records_inserted,
    AVG(duration_ms) as avg_duration_ms,
    MAX(duration_ms) as max_duration_ms,
    SUM(api_response_size)/1024/1024 as total_data_mb,
    MAX(start_time) as last_called
FROM ETL_STATISTICS
WHERE endpoint_key IS NOT NULL
GROUP BY endpoint_key
ORDER BY total_calls DESC
/


  CREATE OR REPLACE FORCE EDITIONABLE VIEW "TR2000_STAGING"."V_ETL_RUN_SUMMARY" ("RUN_ID", "RUN_TYPE", "START_TIME", "END_TIME", "RUN_DURATION_SECONDS", "STATUS", "UNIQUE_API_ENDPOINTS", "TOTAL_API_CALLS", "TOTAL_DATA_MB", "TOTAL_RECORDS", "ERROR_COUNT") AS
  SELECT
    r.run_id,
    r.run_type,
    r.start_time,
    r.end_time,
    ROUND(EXTRACT(MINUTE FROM (r.end_time - r.start_time)) * 60 +
          EXTRACT(SECOND FROM (r.end_time - r.start_time)), 2) as run_duration_seconds,
    r.status,
    (SELECT COUNT(DISTINCT endpoint_key) FROM ETL_STATISTICS WHERE run_id = r.run_id AND stat_type = 'API_CALL') as unique_api_endpoints,
    (SELECT COUNT(*) FROM ETL_STATISTICS WHERE run_id = r.run_id AND stat_type = 'API_CALL') as total_api_calls,
    (SELECT SUM(api_response_size)/1024/1024 FROM ETL_STATISTICS WHERE run_id = r.run_id) as total_data_mb,
    (SELECT SUM(records_processed) FROM ETL_STATISTICS WHERE run_id = r.run_id) as total_records,
    (SELECT COUNT(*) FROM ETL_ERROR_LOG WHERE error_timestamp BETWEEN r.start_time AND NVL(r.end_time, SYSTIMESTAMP)) as error_count
FROM ETL_RUN_LOG r
ORDER BY r.run_id DESC
/


  CREATE OR REPLACE FORCE EDITIONABLE VIEW "TR2000_STAGING"."V_ETL_STATISTICS_SUMMARY" ("RUN_ID", "ENDPOINT_KEY", "OPERATION_COUNT", "TOTAL_RECORDS_PROCESSED", "TOTAL_RECORDS_INSERTED", "TOTAL_RECORDS_FAILED", "AVG_DURATION_MS", "MIN_DURATION_MS", "MAX_DURATION_MS", "TOTAL_DURATION_MS", "FIRST_OPERATION", "LAST_OPERATION", "SUCCESS_COUNT", "FAILURE_COUNT", "SUCCESS_RATE_PCT") AS
  SELECT
    run_id,
    endpoint_key,
    COUNT(*) as operation_count,
    SUM(records_processed) as total_records_processed,
    SUM(records_inserted) as total_records_inserted,
    SUM(records_failed) as total_records_failed,
    AVG(duration_ms) as avg_duration_ms,
    MIN(duration_ms) as min_duration_ms,
    MAX(duration_ms) as max_duration_ms,
    SUM(duration_ms) as total_duration_ms,
    MIN(start_time) as first_operation,
    MAX(end_time) as last_operation,
    SUM(CASE WHEN status = 'SUCCESS' THEN 1 ELSE 0 END) as success_count,
    SUM(CASE WHEN status = 'FAILED' THEN 1 ELSE 0 END) as failure_count,
    ROUND(SUM(CASE WHEN status = 'SUCCESS' THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) as success_rate_pct
FROM ETL_STATISTICS
GROUP BY run_id, endpoint_key
/


  CREATE OR REPLACE FORCE EDITIONABLE VIEW "TR2000_STAGING"."V_OPERATION_STATISTICS" ("OPERATION_NAME", "EXECUTION_COUNT", "AVG_DURATION_MS", "MIN_DURATION_MS", "MAX_DURATION_MS", "TOTAL_RECORDS_PROCESSED", "TOTAL_RECORDS_INSERTED", "TOTAL_RECORDS_UPDATED", "TOTAL_RECORDS_DELETED", "TOTAL_RECORDS_FAILED", "SUCCESS_COUNT", "FAILURE_COUNT", "SUCCESS_RATE") AS
  SELECT
    operation_name,
    COUNT(*) as execution_count,
    AVG(duration_ms) as avg_duration_ms,
    MIN(duration_ms) as min_duration_ms,
    MAX(duration_ms) as max_duration_ms,
    SUM(records_processed) as total_records_processed,
    SUM(records_inserted) as total_records_inserted,
    SUM(records_updated) as total_records_updated,
    SUM(records_deleted) as total_records_deleted,
    SUM(records_failed) as total_records_failed,
    SUM(CASE WHEN status = 'SUCCESS' THEN 1 ELSE 0 END) as success_count,
    SUM(CASE WHEN status = 'FAILED' THEN 1 ELSE 0 END) as failure_count,
    ROUND(SUM(CASE WHEN status = 'SUCCESS' THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) as success_rate
FROM ETL_STATISTICS
WHERE operation_name IS NOT NULL
GROUP BY operation_name
ORDER BY execution_count DESC
/


  CREATE OR REPLACE FORCE EDITIONABLE VIEW "TR2000_STAGING"."V_RAW_JSON" ("RAW_JSON_ID", "ENDPOINT_KEY", "ENDPOINT_TEMPLATE", "ENDPOINT_VALUE", "PLANT_ID", "ISSUE_REVISION", "PCS_NAME", "PCS_REVISION", "ENDPOINT_CATEGORY", "DATA_STATUS", "BATCH_ID", "API_CALL_TIMESTAMP", "CREATED_DATE", "PAYLOAD_SIZE", "PAYLOAD_PREVIEW") AS
  SELECT
    raw_json_id,
    endpoint_key,
    endpoint_template,
    endpoint_value,
    -- Extract plant_id from endpoint_value
    CASE
        WHEN endpoint_value LIKE '/plants/%' THEN
            REGEXP_SUBSTR(endpoint_value, '/plants/([^/]+)', 1, 1, NULL, 1)
        ELSE NULL
    END AS plant_id,
    -- Extract issue_revision from endpoint_value
    CASE
        WHEN endpoint_value LIKE '%/issues/rev/%' THEN
            REGEXP_SUBSTR(endpoint_value, '/issues/rev/([^/]+)', 1, 1, NULL, 1)
        ELSE NULL
    END AS issue_revision,
    -- Extract pcs_name from endpoint_value
    CASE
        WHEN endpoint_value LIKE '%/pcs/%/rev/%' THEN
            REGEXP_SUBSTR(endpoint_value, '/pcs/([^/]+)/rev/', 1, 1, NULL, 1)
        ELSE NULL
    END AS pcs_name,
    -- Extract pcs_revision from endpoint_value
    CASE
        WHEN endpoint_value LIKE '%/pcs/%/rev/%' THEN
            REGEXP_SUBSTR(endpoint_value, '/pcs/[^/]+/rev/([^/]+)', 1, 1, NULL, 1)
        ELSE NULL
    END AS pcs_revision,
    -- Categorize endpoint type
    CASE
        WHEN endpoint_key LIKE '%_REFERENCES' THEN 'Reference Data'
        WHEN endpoint_key LIKE 'PCS_%' AND endpoint_key != 'PCS_LIST' THEN 'PCS Details'
        WHEN endpoint_key = 'PCS_LIST' THEN 'PCS List'
        WHEN endpoint_key = 'VDS_CATALOG' THEN 'VDS Catalog'
        WHEN endpoint_key = 'PLANTS' THEN 'Plants'
        WHEN endpoint_key = 'ISSUES' THEN 'Issues'
        ELSE 'Other'
    END AS endpoint_category,
    -- Processing status based on payload
    CASE
        WHEN payload IS NULL THEN 'No Data'
        WHEN DBMS_LOB.GETLENGTH(payload) < 50 THEN 'Empty/Error'
        WHEN DBMS_LOB.INSTR(payload, '"error"') > 0 THEN 'API Error'
        WHEN DBMS_LOB.SUBSTR(payload, 2, 1) = '[]' OR DBMS_LOB.SUBSTR(payload, 2, 1) = '{}' THEN 'Empty Result'
        ELSE 'Has Data'
    END AS data_status,
    batch_id,
    api_call_timestamp,
    created_date,
    -- Payload info
    DBMS_LOB.GETLENGTH(payload) AS payload_size,
    -- Payload preview (handle CLOB properly)
    CASE
        WHEN payload IS NULL THEN 'NULL'
        WHEN DBMS_LOB.GETLENGTH(payload) < 50 THEN TO_CHAR(DBMS_LOB.SUBSTR(payload, 50, 1))
        ELSE DBMS_LOB.SUBSTR(payload, 100, 1) || '...'
    END AS payload_preview
FROM RAW_JSON
/


  CREATE OR REPLACE FORCE EDITIONABLE VIEW "TR2000_STAGING"."V_RAW_JSON_SUMMARY" ("ENDPOINT_KEY", "ENDPOINT_CATEGORY", "CALL_COUNT", "BATCH_COUNT", "PLANT_COUNT", "ISSUE_COUNT", "PCS_COUNT", "SUCCESSFUL_CALLS", "FAILED_CALLS", "MIN_PAYLOAD_SIZE", "MAX_PAYLOAD_SIZE", "AVG_PAYLOAD_SIZE", "TOTAL_PAYLOAD_SIZE", "FIRST_CALL", "LAST_CALL") AS
  WITH raw_data AS (
    SELECT
        endpoint_key,
        CASE
            WHEN endpoint_key LIKE '%_REFERENCES' THEN 'Reference Data'
            WHEN endpoint_key LIKE 'PCS_%' AND endpoint_key != 'PCS_LIST' THEN 'PCS Details'
            WHEN endpoint_key = 'PCS_LIST' THEN 'PCS List'
            WHEN endpoint_key = 'VDS_CATALOG' THEN 'VDS Catalog'
            ELSE 'Other'
        END AS endpoint_category,
        CASE
            WHEN endpoint_value LIKE '/plants/%' THEN
                REGEXP_SUBSTR(endpoint_value, '/plants/([^/]+)', 1, 1, NULL, 1)
            ELSE NULL
        END AS plant_id,
        CASE
            WHEN endpoint_value LIKE '%/issues/rev/%' THEN
                REGEXP_SUBSTR(endpoint_value, '/issues/rev/([^/]+)', 1, 1, NULL, 1)
            ELSE NULL
        END AS issue_revision,
        CASE
            WHEN endpoint_value LIKE '%/pcs/%/rev/%' THEN
                REGEXP_SUBSTR(endpoint_value, '/pcs/([^/]+)/rev/', 1, 1, NULL, 1)
            ELSE NULL
        END AS pcs_name,
        CASE
            WHEN payload IS NULL THEN 'No Data'
            WHEN DBMS_LOB.GETLENGTH(payload) < 50 THEN 'Empty/Error'
            ELSE 'Has Data'
        END AS data_status,
        DBMS_LOB.GETLENGTH(payload) AS payload_size,
        batch_id,
        api_call_timestamp
    FROM RAW_JSON
)
SELECT
    endpoint_key,
    endpoint_category,
    COUNT(*) as call_count,
    COUNT(DISTINCT batch_id) as batch_count,
    COUNT(DISTINCT plant_id) as plant_count,
    COUNT(DISTINCT issue_revision) as issue_count,
    COUNT(DISTINCT pcs_name) as pcs_count,
    SUM(CASE WHEN data_status = 'Has Data' THEN 1 ELSE 0 END) as successful_calls,
    SUM(CASE WHEN data_status != 'Has Data' THEN 1 ELSE 0 END) as failed_calls,
    MIN(payload_size) as min_payload_size,
    MAX(payload_size) as max_payload_size,
    ROUND(AVG(payload_size)) as avg_payload_size,
    SUM(payload_size) as total_payload_size,
    MIN(api_call_timestamp) as first_call,
    MAX(api_call_timestamp) as last_call
FROM raw_data
GROUP BY endpoint_key, endpoint_category
ORDER BY endpoint_category, endpoint_key
/

-- =====================================================
-- TRIGGERS
-- =====================================================

  CREATE OR REPLACE EDITIONABLE TRIGGER "TR2000_STAGING"."TRG_BLOCK_EMPTY_PKG_BODY"
AFTER CREATE ON SCHEMA
DECLARE
    v_lines NUMBER;
    v_non_empty_lines NUMBER;
BEGIN
    -- Only check package bodies
    IF ORA_DICT_OBJ_TYPE = 'PACKAGE BODY' THEN
        -- Count total lines
        SELECT COUNT(*)
        INTO v_lines
        FROM USER_SOURCE
        WHERE name = ORA_DICT_OBJ_NAME
        AND type = 'PACKAGE BODY';

        -- Count non-whitespace lines
        SELECT COUNT(*)
        INTO v_non_empty_lines
        FROM USER_SOURCE
        WHERE name = ORA_DICT_OBJ_NAME
        AND type = 'PACKAGE BODY'
        AND REGEXP_LIKE(text, '\S'); -- any non-whitespace

        -- Block if too small (less than 5 non-empty lines is suspicious)
        IF v_non_empty_lines < 5 THEN
            RAISE_APPLICATION_ERROR(-20001,
                'BLOCKED: Package body ' || ORA_DICT_OBJ_NAME ||
                ' appears empty or minimal (only ' || v_non_empty_lines ||
                ' non-empty lines). Please check your code before creating.');
        END IF;

        -- Log successful package body creation
        DBMS_OUTPUT.PUT_LINE('Package body ' || ORA_DICT_OBJ_NAME ||
                           ' created successfully with ' || v_lines ||
                           ' total lines (' || v_non_empty_lines || ' non-empty).');
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        -- Don't block on errors in the trigger itself
        DBMS_OUTPUT.PUT_LINE('Warning: Guard trigger error: ' || SQLERRM);
END;
ALTER TRIGGER "TR2000_STAGING"."TRG_BLOCK_EMPTY_PKG_BODY" ENABLE
/

-- =====================================================
-- PACKAGE SPECIFICATIONS
-- =====================================================

  CREATE OR REPLACE EDITIONABLE PACKAGE "TR2000_STAGING"."PKG_API_CLIENT" AS
    -- Fetch reference data
    FUNCTION fetch_reference_data(
        p_plant_id VARCHAR2,
        p_issue_revision VARCHAR2,
        p_ref_type VARCHAR2,
        p_batch_id VARCHAR2
    ) RETURN NUMBER;

    -- Fetch PCS list
    FUNCTION fetch_pcs_list(
        p_plant_id VARCHAR2,
        p_batch_id VARCHAR2
    ) RETURN NUMBER;

    -- Fetch PCS detail (NEW)
    FUNCTION fetch_pcs_detail(
        p_plant_id VARCHAR2,
        p_pcs_name VARCHAR2,
        p_revision VARCHAR2,
        p_detail_type VARCHAR2,
        p_batch_id VARCHAR2
    ) RETURN NUMBER;

    -- Fetch VDS catalog
    FUNCTION fetch_vds_catalog(
        p_batch_id VARCHAR2
    ) RETURN NUMBER;

    -- Build endpoint URL
    FUNCTION build_endpoint_url(
        p_endpoint_key VARCHAR2,
        p_plant_id VARCHAR2 DEFAULT NULL,
        p_issue_revision VARCHAR2 DEFAULT NULL,
        p_pcs_name VARCHAR2 DEFAULT NULL,
        p_pcs_revision VARCHAR2 DEFAULT NULL
    ) RETURN VARCHAR2;
END PKG_API_CLIENT;
CREATE OR REPLACE EDITIONABLE PACKAGE BODY "TR2000_STAGING"."PKG_API_CLIENT" AS

    -- Build endpoint URL from template
    FUNCTION build_endpoint_url(
        p_endpoint_key VARCHAR2,
        p_plant_id VARCHAR2 DEFAULT NULL,
        p_issue_revision VARCHAR2 DEFAULT NULL,
        p_pcs_name VARCHAR2 DEFAULT NULL,
        p_pcs_revision VARCHAR2 DEFAULT NULL
    ) RETURN VARCHAR2 IS
        v_url VARCHAR2(500);
        v_template VARCHAR2(500);
    BEGIN
        -- Get template from CONTROL_ENDPOINTS
        BEGIN
            SELECT endpoint_template INTO v_template
            FROM CONTROL_ENDPOINTS
            WHERE endpoint_key = p_endpoint_key;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                -- If not found, build manually for PCS details
                IF p_endpoint_key LIKE 'PCS_%' THEN
                    v_template := '/plants/{plant_id}/pcs/{pcs_name}/rev/{pcs_revision}';
                    IF p_endpoint_key = 'PCS_HEADER_PROPERTIES' THEN
                        v_template := v_template;  -- Base endpoint
                    ELSIF p_endpoint_key = 'PCS_TEMP_PRESSURES' THEN
                        v_template := v_template || '/temp-pressures';
                    ELSIF p_endpoint_key = 'PCS_PIPE_SIZES' THEN
                        v_template := v_template || '/pipe-sizes';
                    ELSIF p_endpoint_key = 'PCS_PIPE_ELEMENTS' THEN
                        v_template := v_template || '/pipe-elements';
                    ELSIF p_endpoint_key = 'PCS_VALVE_ELEMENTS' THEN
                        v_template := v_template || '/valve-elements';
                    ELSIF p_endpoint_key = 'PCS_EMBEDDED_NOTES' THEN
                        v_template := v_template || '/embedded-notes';
                    END IF;
                ELSE
                    RAISE_APPLICATION_ERROR(-20001, 'Endpoint key not found: ' || p_endpoint_key);
                END IF;
        END;

        -- Replace placeholders
        v_url := v_template;
        v_url := REPLACE(v_url, '{plant_id}', p_plant_id);
        v_url := REPLACE(v_url, '{issue_revision}', p_issue_revision);
        v_url := REPLACE(v_url, '{pcs_name}', p_pcs_name);
        v_url := REPLACE(v_url, '{pcs_revision}', p_pcs_revision);

        RETURN v_url;
    END build_endpoint_url;

    -- Fetch reference data (PCS, VDS, MDS, etc.) - API → RAW_JSON only
    FUNCTION fetch_reference_data(
        p_plant_id VARCHAR2,
        p_issue_revision VARCHAR2,
        p_ref_type VARCHAR2,
        p_batch_id VARCHAR2
    ) RETURN NUMBER IS
        v_path VARCHAR2(500);
        v_response CLOB;
        v_raw_json_id NUMBER;
        v_base_url VARCHAR2(500);
        v_endpoint_key VARCHAR2(100);
        v_url VARCHAR2(4000);
        v_template VARCHAR2(500);
        v_http_status PLS_INTEGER;
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Get base URL from configuration
        SELECT setting_value INTO v_base_url
        FROM CONTROL_SETTINGS
        WHERE setting_key = 'API_BASE_URL';

        -- Map reference type to endpoint key
        v_endpoint_key := UPPER(p_ref_type) || '_REFERENCES';

        -- Build actual path using template
        v_path := build_endpoint_url(
            p_endpoint_key => v_endpoint_key,
            p_plant_id => p_plant_id,
            p_issue_revision => p_issue_revision
        );

        -- Get template for logging
        v_template := build_endpoint_url(v_endpoint_key, '{plant_id}', '{issue_revision}');

        -- Construct full URL
        v_url := v_base_url || v_path;

        -- Make API call through API_SERVICE proxy
        BEGIN
            v_response := API_SERVICE.API_GATEWAY.get_clob(
                p_url => v_url,
                p_method => 'GET',
                p_body => NULL,
                p_headers => NULL,
                p_credential_static_id => NULL,
                p_status_code => v_http_status
            );
        EXCEPTION
            WHEN OTHERS THEN
                v_http_status := -1;
                v_error_msg := SUBSTR(SQLERRM, 1, 4000);
        END;

        -- Store in RAW_JSON only - no direct loading to core tables
        INSERT INTO RAW_JSON (
            raw_json_id,
            endpoint_key,
            endpoint_template,
            endpoint_value,
            payload,
            batch_id,
            api_call_timestamp,
            created_date,
            key_fingerprint
        ) VALUES (
            RAW_JSON_SEQ.NEXTVAL,
            v_endpoint_key,
            v_template,
            v_path,
            v_response,
            p_batch_id,
            SYSTIMESTAMP,
            SYSDATE,
            STANDARD_HASH(v_path || '|' || p_batch_id, 'SHA256')
        ) RETURNING raw_json_id INTO v_raw_json_id;

        -- Log error if HTTP status is not success
        IF v_http_status IS NULL OR v_http_status NOT BETWEEN 200 AND 299 THEN
            INSERT INTO ETL_ERROR_LOG (
                error_id,
                endpoint_key,
                plant_id,
                issue_revision,
                error_timestamp,
                error_type,
                error_code,
                error_message
            ) VALUES (
                ETL_ERROR_SEQ.NEXTVAL,
                v_endpoint_key,
                p_plant_id,
                p_issue_revision,
                SYSTIMESTAMP,
                'API_CALL_ERROR',
                TO_CHAR(v_http_status),
                'HTTP ' || NVL(TO_CHAR(v_http_status), 'NULL') || ' for ' || v_url ||
                CASE WHEN v_error_msg IS NOT NULL THEN CHR(10) || v_error_msg ELSE '' END
            );
            COMMIT;
        END IF;

        RETURN v_raw_json_id;

    EXCEPTION
        WHEN OTHERS THEN
            DECLARE
                v_error_code VARCHAR2(50) := TO_CHAR(SQLCODE);
                v_error_msg VARCHAR2(4000) := SUBSTR(SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE, 1, 4000);
            BEGIN
                INSERT INTO ETL_ERROR_LOG (
                    error_id,
                    endpoint_key,
                    plant_id,
                    issue_revision,
                    error_timestamp,
                    error_type,
                    error_code,
                    error_message
                ) VALUES (
                    ETL_ERROR_SEQ.NEXTVAL,
                    v_endpoint_key,
                    p_plant_id,
                    p_issue_revision,
                    SYSTIMESTAMP,
                    'UNEXPECTED_ERROR',
                    v_error_code,
                    v_error_msg
                );
                COMMIT;
            END;
            RETURN NULL;
    END fetch_reference_data;

    -- Fetch PCS list for a plant - API → RAW_JSON only
    FUNCTION fetch_pcs_list(
        p_plant_id VARCHAR2,
        p_batch_id VARCHAR2
    ) RETURN NUMBER IS
        v_path VARCHAR2(500);
        v_response CLOB;
        v_raw_json_id NUMBER;
        v_base_url VARCHAR2(500);
        v_url VARCHAR2(4000);
        v_http_status PLS_INTEGER;
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Get base URL from configuration
        SELECT setting_value INTO v_base_url
        FROM CONTROL_SETTINGS
        WHERE setting_key = 'API_BASE_URL';

        -- Build path
        v_path := build_endpoint_url(
            p_endpoint_key => 'PCS_LIST',
            p_plant_id => p_plant_id
        );

        -- Construct full URL
        v_url := v_base_url || v_path;

        -- Make API call through API_SERVICE proxy
        BEGIN
            v_response := API_SERVICE.API_GATEWAY.get_clob(
                p_url => v_url,
                p_method => 'GET',
                p_body => NULL,
                p_headers => NULL,
                p_credential_static_id => NULL,
                p_status_code => v_http_status
            );
        EXCEPTION
            WHEN OTHERS THEN
                v_http_status := -1;
                v_error_msg := SUBSTR(SQLERRM, 1, 4000);
        END;

        -- Store in RAW_JSON only - no direct loading to core tables
        INSERT INTO RAW_JSON (
            raw_json_id,
            endpoint_key,
            endpoint_template,
            endpoint_value,
            payload,
            batch_id,
            api_call_timestamp,
            created_date,
            key_fingerprint
        ) VALUES (
            RAW_JSON_SEQ.NEXTVAL,
            'PCS_LIST',
            '/plants/{plant_id}/pcs',
            v_path,
            v_response,
            p_batch_id,
            SYSTIMESTAMP,
            SYSDATE,
            STANDARD_HASH(v_path || '|' || p_batch_id, 'SHA256')
        ) RETURNING raw_json_id INTO v_raw_json_id;

        -- Log error if HTTP status is not success
        IF v_http_status IS NULL OR v_http_status NOT BETWEEN 200 AND 299 THEN
            INSERT INTO ETL_ERROR_LOG (
                error_id,
                endpoint_key,
                plant_id,
                error_timestamp,
                error_type,
                error_code,
                error_message
            ) VALUES (
                ETL_ERROR_SEQ.NEXTVAL,
                'PCS_LIST',
                p_plant_id,
                SYSTIMESTAMP,
                'API_CALL_ERROR',
                TO_CHAR(v_http_status),
                'HTTP ' || NVL(TO_CHAR(v_http_status), 'NULL') || ' for ' || v_url ||
                CASE WHEN v_error_msg IS NOT NULL THEN CHR(10) || v_error_msg ELSE '' END
            );
            COMMIT;
        END IF;

        RETURN v_raw_json_id;

    EXCEPTION
        WHEN OTHERS THEN
            DECLARE
                v_error_code VARCHAR2(50) := TO_CHAR(SQLCODE);
                v_error_msg VARCHAR2(4000) := SUBSTR(SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE, 1, 4000);
            BEGIN
                INSERT INTO ETL_ERROR_LOG (
                    error_id,
                    endpoint_key,
                    plant_id,
                    error_timestamp,
                    error_type,
                    error_code,
                    error_message
                ) VALUES (
                    ETL_ERROR_SEQ.NEXTVAL,
                    'PCS_LIST',
                    p_plant_id,
                    SYSTIMESTAMP,
                    'UNEXPECTED_ERROR',
                    v_error_code,
                    v_error_msg
                );
                COMMIT;
            END;
            RETURN NULL;
    END fetch_pcs_list;

    -- Fetch PCS detail - API → RAW_JSON only (called by PKG_MAIN_ETL_CONTROL)
    FUNCTION fetch_pcs_detail(
        p_plant_id VARCHAR2,
        p_pcs_name VARCHAR2,
        p_revision VARCHAR2,
        p_detail_type VARCHAR2,
        p_batch_id VARCHAR2
    ) RETURN NUMBER IS
        v_path VARCHAR2(500);
        v_response CLOB;
        v_raw_json_id NUMBER;
        v_base_url VARCHAR2(500);
        v_endpoint_key VARCHAR2(100);
        v_url VARCHAR2(4000);
        v_template VARCHAR2(500);
        v_http_status PLS_INTEGER;
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Get base URL from configuration
        SELECT setting_value INTO v_base_url
        FROM CONTROL_SETTINGS
        WHERE setting_key = 'API_BASE_URL';

        -- Map detail type to endpoint key
        v_endpoint_key := 'PCS_' || UPPER(REPLACE(p_detail_type, '-', '_'));

        -- Build actual path using template
        v_path := build_endpoint_url(
            p_endpoint_key => v_endpoint_key,
            p_plant_id => p_plant_id,
            p_pcs_name => p_pcs_name,
            p_pcs_revision => p_revision
        );

        -- Get template for logging
        v_template := build_endpoint_url(v_endpoint_key, '{plant_id}', NULL, '{pcs_name}', '{pcs_revision}');

        -- Construct full URL
        v_url := v_base_url || v_path;

        -- Make API call through API_SERVICE proxy
        BEGIN
            v_response := API_SERVICE.API_GATEWAY.get_clob(
                p_url => v_url,
                p_method => 'GET',
                p_body => NULL,
                p_headers => NULL,
                p_credential_static_id => NULL,
                p_status_code => v_http_status
            );
        EXCEPTION
            WHEN OTHERS THEN
                v_http_status := -1;
                v_error_msg := SUBSTR(SQLERRM, 1, 4000);
        END;

        -- Store in RAW_JSON only - PKG_PCS_DETAIL_PROCESSOR will handle STG_* → Core
        INSERT INTO RAW_JSON (
            raw_json_id,
            endpoint_key,
            endpoint_template,
            endpoint_value,
            payload,
            batch_id,
            api_call_timestamp,
            created_date,
            key_fingerprint
        ) VALUES (
            RAW_JSON_SEQ.NEXTVAL,
            v_endpoint_key,
            v_template,
            v_path,
            v_response,
            p_batch_id,
            SYSTIMESTAMP,
            SYSDATE,
            STANDARD_HASH(v_path || '|' || p_batch_id, 'SHA256')
        ) RETURNING raw_json_id INTO v_raw_json_id;

        -- Log error if HTTP status is not success
        IF v_http_status IS NULL OR v_http_status NOT BETWEEN 200 AND 299 THEN
            INSERT INTO ETL_ERROR_LOG (
                error_id,
                endpoint_key,
                plant_id,
                issue_revision,  -- Using issue_revision column for PCS name
                error_timestamp,
                error_type,
                error_code,
                error_message
            ) VALUES (
                ETL_ERROR_SEQ.NEXTVAL,
                v_endpoint_key,
                p_plant_id,
                p_pcs_name,  -- Store PCS name in issue_revision column
                SYSTIMESTAMP,
                'API_CALL_ERROR',
                TO_CHAR(v_http_status),
                'HTTP ' || NVL(TO_CHAR(v_http_status), 'NULL') || ' for ' || v_url ||
                CASE WHEN v_error_msg IS NOT NULL THEN CHR(10) || v_error_msg ELSE '' END
            );
            COMMIT;
        END IF;

        RETURN v_raw_json_id;

    EXCEPTION
        WHEN OTHERS THEN
            DECLARE
                v_error_code VARCHAR2(50) := TO_CHAR(SQLCODE);
                v_error_msg VARCHAR2(4000) := SUBSTR(SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE, 1, 4000);
            BEGIN
                INSERT INTO ETL_ERROR_LOG (
                    error_id,
                    endpoint_key,
                    plant_id,
                    issue_revision,  -- Using issue_revision column for PCS name
                    error_timestamp,
                    error_type,
                    error_code,
                    error_message
                ) VALUES (
                    ETL_ERROR_SEQ.NEXTVAL,
                    v_endpoint_key,
                    p_plant_id,
                    p_pcs_name,  -- Store PCS name in issue_revision column
                    SYSTIMESTAMP,
                    'UNEXPECTED_ERROR',
                    v_error_code,
                    v_error_msg
                );
                COMMIT;
            END;
            RETURN NULL;
    END fetch_pcs_detail;

    -- Fetch VDS catalog - API → RAW_JSON only
    FUNCTION fetch_vds_catalog(
        p_batch_id VARCHAR2
    ) RETURN NUMBER IS
        v_response CLOB;
        v_raw_json_id NUMBER;
        v_base_url VARCHAR2(500);
        v_url VARCHAR2(4000);
        v_http_status PLS_INTEGER;
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Get base URL from configuration
        SELECT setting_value INTO v_base_url
        FROM CONTROL_SETTINGS
        WHERE setting_key = 'API_BASE_URL';

        -- VDS catalog endpoint is simple
        v_url := v_base_url || '/vds';

        -- Make API call through API_SERVICE proxy
        BEGIN
            v_response := API_SERVICE.API_GATEWAY.get_clob(
                p_url => v_url,
                p_method => 'GET',
                p_body => NULL,
                p_headers => NULL,
                p_credential_static_id => NULL,
                p_status_code => v_http_status
            );
        EXCEPTION
            WHEN OTHERS THEN
                v_http_status := -1;
                v_error_msg := SUBSTR(SQLERRM, 1, 4000);
        END;

        -- Store in RAW_JSON only - no direct loading to core tables
        INSERT INTO RAW_JSON (
            raw_json_id,
            endpoint_key,
            endpoint_template,
            endpoint_value,
            payload,
            batch_id,
            api_call_timestamp,
            created_date,
            key_fingerprint
        ) VALUES (
            RAW_JSON_SEQ.NEXTVAL,
            'VDS_LIST',
            '/vds',
            '/vds',
            v_response,
            p_batch_id,
            SYSTIMESTAMP,
            SYSDATE,
            STANDARD_HASH('/vds|' || p_batch_id, 'SHA256')
        ) RETURNING raw_json_id INTO v_raw_json_id;

        -- Log error if HTTP status is not success
        IF v_http_status IS NULL OR v_http_status NOT BETWEEN 200 AND 299 THEN
            INSERT INTO ETL_ERROR_LOG (
                error_id,
                endpoint_key,
                error_timestamp,
                error_type,
                error_code,
                error_message
            ) VALUES (
                ETL_ERROR_SEQ.NEXTVAL,
                'VDS_LIST',
                SYSTIMESTAMP,
                'API_CALL_ERROR',
                TO_CHAR(v_http_status),
                'HTTP ' || NVL(TO_CHAR(v_http_status), 'NULL') || ' for ' || v_url ||
                CASE WHEN v_error_msg IS NOT NULL THEN CHR(10) || v_error_msg ELSE '' END
            );
            COMMIT;
        END IF;

        RETURN v_raw_json_id;

    EXCEPTION
        WHEN OTHERS THEN
            DECLARE
                v_error_code VARCHAR2(50) := TO_CHAR(SQLCODE);
                v_error_msg VARCHAR2(4000) := SUBSTR(SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE, 1, 4000);
            BEGIN
                INSERT INTO ETL_ERROR_LOG (
                    error_id,
                    endpoint_key,
                    error_timestamp,
                    error_type,
                    error_code,
                    error_message
                ) VALUES (
                    ETL_ERROR_SEQ.NEXTVAL,
                    'VDS_LIST',
                    SYSTIMESTAMP,
                    'UNEXPECTED_ERROR',
                    v_error_code,
                    v_error_msg
                );
                COMMIT;
            END;
            RETURN NULL;
    END fetch_vds_catalog;

END PKG_API_CLIENT;
/


  CREATE OR REPLACE EDITIONABLE PACKAGE "TR2000_STAGING"."PKG_DATE_UTILS" AS

    -- Parse date string with multiple format attempts
    FUNCTION parse_date(p_date_string IN VARCHAR2) RETURN DATE;

    -- Parse date string, return NULL if unparseable instead of error
    FUNCTION safe_parse_date(p_date_string IN VARCHAR2) RETURN DATE;

    -- Parse timestamp string with multiple format attempts
    FUNCTION parse_timestamp(p_timestamp_string IN VARCHAR2) RETURN TIMESTAMP;

    -- Parse timestamp string, return NULL if unparseable
    FUNCTION safe_parse_timestamp(p_timestamp_string IN VARCHAR2) RETURN TIMESTAMP;

END PKG_DATE_UTILS;
CREATE OR REPLACE EDITIONABLE PACKAGE BODY "TR2000_STAGING"."PKG_DATE_UTILS" AS

    -- Parse date string with multiple format attempts
    FUNCTION parse_date(p_date_string IN VARCHAR2) RETURN DATE IS
        v_date DATE;
        v_clean_string VARCHAR2(100);
    BEGIN
        -- Return NULL for empty strings
        IF p_date_string IS NULL OR TRIM(p_date_string) IS NULL THEN
            RETURN NULL;
        END IF;

        -- Clean the string (remove extra spaces, normalize)
        v_clean_string := TRIM(p_date_string);

        -- Try various date formats in order of likelihood
        BEGIN
            -- Format 1: DD.MM.YYYY (European with dots - most common in TR2000)
            v_date := TO_DATE(v_clean_string, 'DD.MM.YYYY');
            RETURN v_date;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 2: DD/MM/YYYY (European with slashes)
            v_date := TO_DATE(v_clean_string, 'DD/MM/YYYY');
            RETURN v_date;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 3: DD-MM-YYYY (European with dashes)
            v_date := TO_DATE(v_clean_string, 'DD-MM-YYYY');
            RETURN v_date;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 4: YYYY-MM-DD (ISO format)
            v_date := TO_DATE(v_clean_string, 'YYYY-MM-DD');
            RETURN v_date;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 5: YYYY/MM/DD (ISO with slashes)
            v_date := TO_DATE(v_clean_string, 'YYYY/MM/DD');
            RETURN v_date;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 6: MM/DD/YYYY (US format)
            v_date := TO_DATE(v_clean_string, 'MM/DD/YYYY');
            RETURN v_date;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 7: MM-DD-YYYY (US with dashes)
            v_date := TO_DATE(v_clean_string, 'MM-DD-YYYY');
            RETURN v_date;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 8: DD.MM.YYYY HH24:MI:SS (European with time)
            v_date := TO_DATE(v_clean_string, 'DD.MM.YYYY HH24:MI:SS');
            RETURN v_date;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 9: YYYY-MM-DD HH24:MI:SS (ISO with time)
            v_date := TO_DATE(v_clean_string, 'YYYY-MM-DD HH24:MI:SS');
            RETURN v_date;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 10: DD/MM/YYYY HH24:MI:SS (European with time and slashes)
            v_date := TO_DATE(v_clean_string, 'DD/MM/YYYY HH24:MI:SS');
            RETURN v_date;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 11: YYYY-MM-DD"T"HH24:MI:SS (ISO 8601 with T separator)
            v_date := TO_DATE(v_clean_string, 'YYYY-MM-DD"T"HH24:MI:SS');
            RETURN v_date;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 12: DD-MON-YYYY (Oracle default)
            v_date := TO_DATE(v_clean_string, 'DD-MON-YYYY');
            RETURN v_date;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 13: DD-MON-YY (Oracle short year)
            v_date := TO_DATE(v_clean_string, 'DD-MON-YY');
            RETURN v_date;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 14: YYYYMMDD (Compact format)
            IF LENGTH(v_clean_string) = 8 AND REGEXP_LIKE(v_clean_string, '^\d{8}$') THEN
                v_date := TO_DATE(v_clean_string, 'YYYYMMDD');
                RETURN v_date;
            END IF;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 15: DD.MM.YY (European short year)
            v_date := TO_DATE(v_clean_string, 'DD.MM.YY');
            RETURN v_date;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        -- If we get here, none of the formats worked
        RAISE_APPLICATION_ERROR(-20901,
            'Unable to parse date string: ' || p_date_string ||
            '. Tried DD.MM.YYYY, DD/MM/YYYY, YYYY-MM-DD, MM/DD/YYYY and other formats.');

    END parse_date;

    -- Safe version that returns NULL instead of raising error
    FUNCTION safe_parse_date(p_date_string IN VARCHAR2) RETURN DATE IS
    BEGIN
        RETURN parse_date(p_date_string);
    EXCEPTION
        WHEN OTHERS THEN
            -- Log the parsing error but return NULL
            DBMS_OUTPUT.PUT_LINE('Warning: Could not parse date "' || p_date_string || '": ' || SQLERRM);
            RETURN NULL;
    END safe_parse_date;

    -- Parse timestamp string with multiple format attempts
    FUNCTION parse_timestamp(p_timestamp_string IN VARCHAR2) RETURN TIMESTAMP IS
        v_timestamp TIMESTAMP;
        v_clean_string VARCHAR2(100);
    BEGIN
        -- Return NULL for empty strings
        IF p_timestamp_string IS NULL OR TRIM(p_timestamp_string) IS NULL THEN
            RETURN NULL;
        END IF;

        -- Clean the string
        v_clean_string := TRIM(p_timestamp_string);

        -- Try various timestamp formats
        BEGIN
            -- Format 1: YYYY-MM-DD HH24:MI:SS.FF (ISO with fractional seconds)
            v_timestamp := TO_TIMESTAMP(v_clean_string, 'YYYY-MM-DD HH24:MI:SS.FF');
            RETURN v_timestamp;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 2: YYYY-MM-DD HH24:MI:SS (ISO without fractional seconds)
            v_timestamp := TO_TIMESTAMP(v_clean_string, 'YYYY-MM-DD HH24:MI:SS');
            RETURN v_timestamp;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 3: DD.MM.YYYY HH24:MI:SS.FF (European with fractional seconds)
            v_timestamp := TO_TIMESTAMP(v_clean_string, 'DD.MM.YYYY HH24:MI:SS.FF');
            RETURN v_timestamp;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 4: DD.MM.YYYY HH24:MI:SS (European without fractional seconds)
            v_timestamp := TO_TIMESTAMP(v_clean_string, 'DD.MM.YYYY HH24:MI:SS');
            RETURN v_timestamp;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 5: YYYY-MM-DD"T"HH24:MI:SS.FF"Z" (ISO 8601 with timezone)
            v_timestamp := TO_TIMESTAMP(REPLACE(REPLACE(v_clean_string, 'T', ' '), 'Z', ''),
                                        'YYYY-MM-DD HH24:MI:SS.FF');
            RETURN v_timestamp;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 6: YYYY-MM-DD"T"HH24:MI:SS (ISO 8601 without fractional seconds)
            v_timestamp := TO_TIMESTAMP(v_clean_string, 'YYYY-MM-DD"T"HH24:MI:SS');
            RETURN v_timestamp;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 7: MM/DD/YYYY HH24:MI:SS (US format)
            v_timestamp := TO_TIMESTAMP(v_clean_string, 'MM/DD/YYYY HH24:MI:SS');
            RETURN v_timestamp;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 8: Just try as a date if no time component detected
            IF NOT REGEXP_LIKE(v_clean_string, '\d{1,2}:\d{2}') THEN
                v_timestamp := CAST(parse_date(v_clean_string) AS TIMESTAMP);
                RETURN v_timestamp;
            END IF;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        -- If we get here, none of the formats worked
        RAISE_APPLICATION_ERROR(-20902,
            'Unable to parse timestamp string: ' || p_timestamp_string);

    END parse_timestamp;

    -- Safe version for timestamps
    FUNCTION safe_parse_timestamp(p_timestamp_string IN VARCHAR2) RETURN TIMESTAMP IS
    BEGIN
        RETURN parse_timestamp(p_timestamp_string);
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('Warning: Could not parse timestamp "' || p_timestamp_string || '": ' || SQLERRM);
            RETURN NULL;
    END safe_parse_timestamp;

END PKG_DATE_UTILS;
/


  CREATE OR REPLACE EDITIONABLE PACKAGE "TR2000_STAGING"."PKG_DDL_BACKUP" AS
    -- Main backup procedures
    PROCEDURE backup_schema(
        p_schema_name VARCHAR2 DEFAULT USER,
        p_notes VARCHAR2 DEFAULT NULL,
        p_include_control_data BOOLEAN DEFAULT TRUE
    );

    PROCEDURE backup_control_data(
        p_schema_name VARCHAR2 DEFAULT USER,
        p_notes VARCHAR2 DEFAULT NULL,
        p_ddl_backup_id NUMBER DEFAULT NULL
    );

    -- Recovery procedures
    FUNCTION get_ddl_from_backup(
        p_backup_id NUMBER
    ) RETURN CLOB;

    FUNCTION restore_control_data(
        p_backup_id NUMBER,
        p_dry_run BOOLEAN DEFAULT TRUE
    ) RETURN VARCHAR2;

    -- Utility procedures
    PROCEDURE list_backups(
        p_days_back NUMBER DEFAULT 7,
        p_schema_name VARCHAR2 DEFAULT USER
    );

    PROCEDURE compare_backups(
        p_backup_id_1 NUMBER,
        p_backup_id_2 NUMBER
    );

    FUNCTION get_latest_backup_id(
        p_schema_name VARCHAR2 DEFAULT USER
    ) RETURN NUMBER;

END PKG_DDL_BACKUP;
CREATE OR REPLACE EDITIONABLE PACKAGE BODY "TR2000_STAGING"."PKG_DDL_BACKUP" AS

    -- Main backup procedure with fixed LOB handling
    PROCEDURE backup_schema(
        p_schema_name VARCHAR2 DEFAULT USER,
        p_notes VARCHAR2 DEFAULT NULL,
        p_include_control_data BOOLEAN DEFAULT TRUE
    ) IS
        v_ddl_content CLOB;
        v_object_count NUMBER := 0;
        v_view_count NUMBER := 0;
        v_package_count NUMBER := 0;
        v_table_count NUMBER := 0;
        v_sequence_count NUMBER := 0;
        v_trigger_count NUMBER := 0;
        v_ddl_backup_id NUMBER;
        v_start_time TIMESTAMP := SYSTIMESTAMP;
        v_end_time TIMESTAMP;
        v_duration_seconds NUMBER;
        v_hash VARCHAR2(64);
        v_temp_ddl CLOB;
        v_ddl_size NUMBER := 0;  -- Store size before freeing LOB

        CURSOR c_objects IS
            SELECT object_type, object_name
            FROM user_objects
            WHERE object_type IN ('TABLE', 'VIEW', 'PACKAGE', 'PACKAGE BODY',
                                  'PROCEDURE', 'FUNCTION', 'SEQUENCE', 'TRIGGER',
                                  'SYNONYM', 'TYPE', 'TYPE BODY', 'INDEX')
            AND object_name NOT LIKE 'BIN$%'
            AND object_name NOT IN ('DDL_BACKUP', 'CONTROL_DATA_BACKUP')
            AND object_name NOT LIKE 'SYS_%'
            AND object_name NOT LIKE 'ISEQ$$%'
            ORDER BY
                DECODE(object_type,
                       'TABLE', 1,
                       'SEQUENCE', 2,
                       'TYPE', 3,
                       'TYPE BODY', 4,
                       'FUNCTION', 5,
                       'PROCEDURE', 6,
                       'PACKAGE', 7,
                       'PACKAGE BODY', 8,
                       'VIEW', 9,
                       'TRIGGER', 10,
                       'INDEX', 11,
                       'SYNONYM', 12,
                       99),
                object_name;
    BEGIN
        DBMS_OUTPUT.PUT_LINE('Starting full DDL backup for schema: ' || p_schema_name);
        DBMS_OUTPUT.PUT_LINE('This will extract actual DDL for all objects...');

        -- Initialize DDL content
        DBMS_LOB.CREATETEMPORARY(v_ddl_content, TRUE);
        DBMS_LOB.APPEND(v_ddl_content,
            '-- Full DDL Backup for schema: ' || p_schema_name || CHR(10) ||
            '-- Generated: ' || TO_CHAR(SYSTIMESTAMP, 'YYYY-MM-DD HH24:MI:SS.FF TZH:TZM') || CHR(10) ||
            '-- Notes: ' || NVL(p_notes, 'No notes provided') || CHR(10) ||
            '-- WARNING: Execute this script carefully!' || CHR(10) || CHR(10)
        );

        -- Set DBMS_METADATA parameters
        DBMS_METADATA.SET_TRANSFORM_PARAM(DBMS_METADATA.SESSION_TRANSFORM, 'SQLTERMINATOR', TRUE);
        DBMS_METADATA.SET_TRANSFORM_PARAM(DBMS_METADATA.SESSION_TRANSFORM, 'PRETTY', TRUE);
        DBMS_METADATA.SET_TRANSFORM_PARAM(DBMS_METADATA.SESSION_TRANSFORM, 'SEGMENT_ATTRIBUTES', TRUE);
        DBMS_METADATA.SET_TRANSFORM_PARAM(DBMS_METADATA.SESSION_TRANSFORM, 'STORAGE', FALSE);

        -- Extract DDL for each object
        FOR obj IN c_objects LOOP
            BEGIN
                -- Skip backup tables and certain object types
                IF obj.object_name IN ('DDL_BACKUP', 'CONTROL_DATA_BACKUP') THEN
                    CONTINUE;
                END IF;

                IF obj.object_type = 'PACKAGE BODY' THEN
                    CONTINUE;  -- Will be included with PACKAGE
                END IF;

                IF obj.object_type = 'INDEX' THEN
                    -- Skip constraint-based indexes
                    DECLARE
                        v_constraint_type VARCHAR2(1);
                    BEGIN
                        SELECT constraint_type INTO v_constraint_type
                        FROM user_constraints
                        WHERE constraint_name = obj.object_name
                        AND constraint_type IN ('P', 'U');
                        CONTINUE;
                    EXCEPTION
                        WHEN NO_DATA_FOUND THEN
                            NULL; -- Not a constraint index
                    END;
                END IF;

                -- Extract DDL (simplified to avoid errors)
                BEGIN
                    DBMS_LOB.APPEND(v_ddl_content,
                        CHR(10) || '-- ' || obj.object_type || ': ' || obj.object_name || CHR(10));

                    -- Count object types
                    IF obj.object_type = 'TABLE' THEN
                        v_table_count := v_table_count + 1;
                    ELSIF obj.object_type = 'VIEW' THEN
                        v_view_count := v_view_count + 1;
                    ELSIF obj.object_type = 'PACKAGE' THEN
                        v_package_count := v_package_count + 1;
                    ELSIF obj.object_type = 'SEQUENCE' THEN
                        v_sequence_count := v_sequence_count + 1;
                    ELSIF obj.object_type = 'TRIGGER' THEN
                        v_trigger_count := v_trigger_count + 1;
                    END IF;

                    -- Try to extract DDL
                    BEGIN
                        DBMS_LOB.CREATETEMPORARY(v_temp_ddl, TRUE);

                        IF obj.object_type IN ('TABLE', 'VIEW', 'SEQUENCE', 'PROCEDURE', 'FUNCTION', 'TRIGGER', 'SYNONYM') THEN
                            v_temp_ddl := DBMS_METADATA.GET_DDL(obj.object_type, obj.object_name, p_schema_name);
                        ELSIF obj.object_type = 'PACKAGE' THEN
                            v_temp_ddl := DBMS_METADATA.GET_DDL('PACKAGE', obj.object_name, p_schema_name);
                            -- Try to get body
                            BEGIN
                                DBMS_LOB.APPEND(v_temp_ddl, CHR(10) || '/' || CHR(10));
                                DBMS_LOB.APPEND(v_temp_ddl,
                                    DBMS_METADATA.GET_DDL('PACKAGE_BODY', obj.object_name, p_schema_name));
                            EXCEPTION
                                WHEN OTHERS THEN
                                    NULL;
                            END;
                        ELSIF obj.object_type = 'TYPE' THEN
                            v_temp_ddl := DBMS_METADATA.GET_DDL('TYPE', obj.object_name, p_schema_name);
                            -- Try to get body
                            BEGIN
                                DBMS_LOB.APPEND(v_temp_ddl, CHR(10) || '/' || CHR(10));
                                DBMS_LOB.APPEND(v_temp_ddl,
                                    DBMS_METADATA.GET_DDL('TYPE_BODY', obj.object_name, p_schema_name));
                            EXCEPTION
                                WHEN OTHERS THEN
                                    NULL;
                            END;
                        END IF;

                        -- Append to main DDL
                        IF DBMS_LOB.GETLENGTH(v_temp_ddl) > 0 THEN
                            DBMS_LOB.APPEND(v_ddl_content, v_temp_ddl);
                            DBMS_LOB.APPEND(v_ddl_content, CHR(10) || '/' || CHR(10));
                        END IF;

                        DBMS_LOB.FREETEMPORARY(v_temp_ddl);

                    EXCEPTION
                        WHEN OTHERS THEN
                            -- Log but continue
                            DBMS_LOB.APPEND(v_ddl_content,
                                '-- Error extracting DDL: ' || SUBSTR(SQLERRM, 1, 200) || CHR(10));
                            IF DBMS_LOB.ISTEMPORARY(v_temp_ddl) = 1 THEN
                                DBMS_LOB.FREETEMPORARY(v_temp_ddl);
                            END IF;
                    END;

                    v_object_count := v_object_count + 1;

                    IF MOD(v_object_count, 10) = 0 THEN
                        DBMS_OUTPUT.PUT_LINE('  Processed ' || v_object_count || ' objects...');
                    END IF;

                EXCEPTION
                    WHEN OTHERS THEN
                        DBMS_OUTPUT.PUT_LINE('  Warning: Error processing ' || obj.object_type ||
                                           ' ' || obj.object_name || ': ' || SUBSTR(SQLERRM, 1, 100));
                END;
            END;
        END LOOP;

        -- Add footer
        DBMS_LOB.APPEND(v_ddl_content, CHR(10) || CHR(10) ||
            '-- ============================================' || CHR(10) ||
            '-- End of DDL Backup' || CHR(10) ||
            '-- Total Objects: ' || v_object_count || CHR(10) ||
            '-- ============================================' || CHR(10));

        -- Calculate values BEFORE insert
        v_end_time := SYSTIMESTAMP;
        v_duration_seconds := EXTRACT(SECOND FROM (v_end_time - v_start_time)) +
                             EXTRACT(MINUTE FROM (v_end_time - v_start_time)) * 60 +
                             EXTRACT(HOUR FROM (v_end_time - v_start_time)) * 3600;

        v_ddl_size := DBMS_LOB.GETLENGTH(v_ddl_content);
        v_hash := 'SIZE:' || v_ddl_size || ':COUNT:' || v_object_count;

        -- Get sequence value
        SELECT DDL_BACKUP_SEQ.NEXTVAL INTO v_ddl_backup_id FROM DUAL;

        -- Insert into backup table
        INSERT INTO DDL_BACKUP_OWNER.DDL_BACKUP (
            backup_id,
            backup_timestamp,
            schema_name,
            backup_type,
            object_count,
            view_count,
            package_count,
            table_count,
            sequence_count,
            trigger_count,
            ddl_content,
            ddl_size_bytes,
            ddl_hash,
            backup_notes,
            backup_user,
            os_user,
            ip_address,
            program,
            duration_seconds
        ) VALUES (
            v_ddl_backup_id,
            v_start_time,
            p_schema_name,
            'FULL_SCHEMA_DDL',
            v_object_count,
            v_view_count,
            v_package_count,
            v_table_count,
            v_sequence_count,
            v_trigger_count,
            v_ddl_content,
            v_ddl_size,
            v_hash,
            p_notes,
            USER,
            SYS_CONTEXT('USERENV', 'OS_USER'),
            SYS_CONTEXT('USERENV', 'IP_ADDRESS'),
            SYS_CONTEXT('USERENV', 'MODULE'),
            v_duration_seconds
        );

        -- Backup control data if requested
        IF p_include_control_data THEN
            backup_control_data(
                p_schema_name => p_schema_name,
                p_notes => p_notes,
                p_ddl_backup_id => v_ddl_backup_id
            );
        END IF;

        COMMIT;

        -- Cleanup AFTER commit
        DBMS_LOB.FREETEMPORARY(v_ddl_content);

        DBMS_OUTPUT.PUT_LINE('');
        DBMS_OUTPUT.PUT_LINE('===== Backup Completed Successfully! =====');
        DBMS_OUTPUT.PUT_LINE('Backup ID: ' || v_ddl_backup_id);
        DBMS_OUTPUT.PUT_LINE('Total objects backed up: ' || v_object_count);
        DBMS_OUTPUT.PUT_LINE('  Tables: ' || v_table_count);
        DBMS_OUTPUT.PUT_LINE('  Views: ' || v_view_count);
        DBMS_OUTPUT.PUT_LINE('  Packages: ' || v_package_count);
        DBMS_OUTPUT.PUT_LINE('  Sequences: ' || v_sequence_count);
        DBMS_OUTPUT.PUT_LINE('  Triggers: ' || v_trigger_count);
        DBMS_OUTPUT.PUT_LINE('DDL Size: ' || ROUND(v_ddl_size/1024) || ' KB');
        DBMS_OUTPUT.PUT_LINE('Duration: ' || ROUND(v_duration_seconds, 2) || ' seconds');
        DBMS_OUTPUT.PUT_LINE('==========================================');

    EXCEPTION
        WHEN OTHERS THEN
            IF DBMS_LOB.ISTEMPORARY(v_ddl_content) = 1 THEN
                DBMS_LOB.FREETEMPORARY(v_ddl_content);
            END IF;
            DBMS_OUTPUT.PUT_LINE('BACKUP FAILED: ' || SQLERRM);
            RAISE_APPLICATION_ERROR(-20001, 'Backup failed: ' || SQLERRM);
    END backup_schema;

    -- Keep all other procedures unchanged
    PROCEDURE backup_control_data(
        p_schema_name VARCHAR2 DEFAULT USER,
        p_notes VARCHAR2 DEFAULT NULL,
        p_ddl_backup_id NUMBER DEFAULT NULL
    ) IS
        v_control_settings_json CLOB;
        v_control_endpoints_json CLOB;
        v_etl_filter_json CLOB;
        v_settings_count NUMBER := 0;
        v_endpoints_count NUMBER := 0;
        v_filter_count NUMBER := 0;
        v_backup_id NUMBER;
    BEGIN
        -- Initialize CLOBs
        DBMS_LOB.CREATETEMPORARY(v_control_settings_json, TRUE);
        DBMS_LOB.CREATETEMPORARY(v_control_endpoints_json, TRUE);
        DBMS_LOB.CREATETEMPORARY(v_etl_filter_json, TRUE);

        -- Build JSON for CONTROL_SETTINGS
        DBMS_LOB.APPEND(v_control_settings_json, '[');
        FOR rec IN (SELECT setting_key, setting_value, description
                   FROM CONTROL_SETTINGS ORDER BY setting_key) LOOP
            IF v_settings_count > 0 THEN
                DBMS_LOB.APPEND(v_control_settings_json, ',');
            END IF;
            DBMS_LOB.APPEND(v_control_settings_json,
                '{"setting_key":"' || rec.setting_key ||
                '","setting_value":"' || REPLACE(rec.setting_value, '"', '\"') ||
                '","description":"' || REPLACE(NVL(rec.description, ''), '"', '\"') || '"}');
            v_settings_count := v_settings_count + 1;
        END LOOP;
        DBMS_LOB.APPEND(v_control_settings_json, ']');

        -- Build JSON for CONTROL_ENDPOINTS
        DBMS_LOB.APPEND(v_control_endpoints_json, '[');
        FOR rec IN (SELECT endpoint_id, endpoint_key, endpoint_template, comments
                   FROM CONTROL_ENDPOINTS ORDER BY endpoint_id) LOOP
            IF v_endpoints_count > 0 THEN
                DBMS_LOB.APPEND(v_control_endpoints_json, ',');
            END IF;
            DBMS_LOB.APPEND(v_control_endpoints_json,
                '{"endpoint_id":' || rec.endpoint_id ||
                ',"endpoint_key":"' || rec.endpoint_key ||
                '","endpoint_template":"' || REPLACE(rec.endpoint_template, '"', '\"') ||
                '","comments":"' || REPLACE(NVL(rec.comments, ''), '"', '\"') || '"}');
            v_endpoints_count := v_endpoints_count + 1;
        END LOOP;
        DBMS_LOB.APPEND(v_control_endpoints_json, ']');

        -- Build JSON for ETL_FILTER
        DBMS_LOB.APPEND(v_etl_filter_json, '[');
        FOR rec IN (SELECT filter_id, plant_id, plant_name, issue_revision,
                          added_date, added_by_user_id, notes
                   FROM ETL_FILTER ORDER BY filter_id) LOOP
            IF v_filter_count > 0 THEN
                DBMS_LOB.APPEND(v_etl_filter_json, ',');
            END IF;
            DBMS_LOB.APPEND(v_etl_filter_json,
                '{"filter_id":' || rec.filter_id ||
                ',"plant_id":"' || rec.plant_id ||
                '","plant_name":"' || REPLACE(rec.plant_name, '"', '\"') ||
                '","issue_revision":"' || rec.issue_revision ||
                '","added_date":"' || TO_CHAR(rec.added_date, 'YYYY-MM-DD HH24:MI:SS') ||
                '","added_by_user_id":"' || rec.added_by_user_id ||
                '","notes":"' || REPLACE(NVL(rec.notes, ''), '"', '\"') || '"}');
            v_filter_count := v_filter_count + 1;
        END LOOP;
        DBMS_LOB.APPEND(v_etl_filter_json, ']');

        -- Get sequence value
        SELECT CONTROL_DATA_BACKUP_SEQ.NEXTVAL INTO v_backup_id FROM DUAL;

        -- Insert into backup table
        INSERT INTO DDL_BACKUP_OWNER.CONTROL_DATA_BACKUP (
            backup_id,
            backup_timestamp,
            schema_name,
            control_settings_json,
            control_endpoints_json,
            etl_filter_json,
            settings_count,
            endpoints_count,
            filter_count,
            backup_notes,
            backup_user,
            ddl_backup_id
        ) VALUES (
            v_backup_id,
            SYSTIMESTAMP,
            p_schema_name,
            v_control_settings_json,
            v_control_endpoints_json,
            v_etl_filter_json,
            v_settings_count,
            v_endpoints_count,
            v_filter_count,
            p_notes,
            USER,
            p_ddl_backup_id
        );

        COMMIT;

        -- Cleanup
        DBMS_LOB.FREETEMPORARY(v_control_settings_json);
        DBMS_LOB.FREETEMPORARY(v_control_endpoints_json);
        DBMS_LOB.FREETEMPORARY(v_etl_filter_json);

        DBMS_OUTPUT.PUT_LINE('Control data backup completed. Backup ID: ' || v_backup_id);
        DBMS_OUTPUT.PUT_LINE('  Settings: ' || v_settings_count);
        DBMS_OUTPUT.PUT_LINE('  Endpoints: ' || v_endpoints_count);
        DBMS_OUTPUT.PUT_LINE('  Filters: ' || v_filter_count);

    EXCEPTION
        WHEN OTHERS THEN
            IF DBMS_LOB.ISTEMPORARY(v_control_settings_json) = 1 THEN
                DBMS_LOB.FREETEMPORARY(v_control_settings_json);
            END IF;
            IF DBMS_LOB.ISTEMPORARY(v_control_endpoints_json) = 1 THEN
                DBMS_LOB.FREETEMPORARY(v_control_endpoints_json);
            END IF;
            IF DBMS_LOB.ISTEMPORARY(v_etl_filter_json) = 1 THEN
                DBMS_LOB.FREETEMPORARY(v_etl_filter_json);
            END IF;
            RAISE_APPLICATION_ERROR(-20002, 'Control data backup failed: ' || SQLERRM);
    END backup_control_data;

    FUNCTION get_ddl_from_backup(p_backup_id NUMBER) RETURN CLOB IS
        v_ddl_content CLOB;
    BEGIN
        SELECT ddl_content INTO v_ddl_content
        FROM DDL_BACKUP_OWNER.DDL_BACKUP
        WHERE backup_id = p_backup_id;

        RETURN v_ddl_content;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20003, 'Backup ID ' || p_backup_id || ' not found');
    END get_ddl_from_backup;

    FUNCTION restore_control_data(
        p_backup_id NUMBER,
        p_dry_run BOOLEAN DEFAULT TRUE
    ) RETURN VARCHAR2 IS
        v_control_settings_json CLOB;
        v_control_endpoints_json CLOB;
        v_etl_filter_json CLOB;
        v_result VARCHAR2(4000);
        v_restored_count NUMBER := 0;
    BEGIN
        SELECT control_settings_json, control_endpoints_json, etl_filter_json
        INTO v_control_settings_json, v_control_endpoints_json, v_etl_filter_json
        FROM DDL_BACKUP_OWNER.CONTROL_DATA_BACKUP
        WHERE backup_id = p_backup_id;

        IF p_dry_run THEN
            v_result := 'DRY RUN - No changes made. Would restore:' || CHR(10);

            SELECT COUNT(*) INTO v_restored_count
            FROM JSON_TABLE(v_control_settings_json, '$[*]'
                COLUMNS (setting_key VARCHAR2(100) PATH '$.setting_key'));
            v_result := v_result || 'CONTROL_SETTINGS: ' || v_restored_count || ' records' || CHR(10);

            SELECT COUNT(*) INTO v_restored_count
            FROM JSON_TABLE(v_control_endpoints_json, '$[*]'
                COLUMNS (endpoint_id NUMBER PATH '$.endpoint_id'));
            v_result := v_result || 'CONTROL_ENDPOINTS: ' || v_restored_count || ' records' || CHR(10);

            SELECT COUNT(*) INTO v_restored_count
            FROM JSON_TABLE(v_etl_filter_json, '$[*]'
                COLUMNS (filter_id NUMBER PATH '$.filter_id'));
            v_result := v_result || 'ETL_FILTER: ' || v_restored_count || ' records';

        ELSE
            v_result := 'RESTORE COMPLETED:' || CHR(10);

            DELETE FROM CONTROL_SETTINGS;
            DELETE FROM CONTROL_ENDPOINTS;
            DELETE FROM ETL_FILTER;

            INSERT INTO CONTROL_SETTINGS (setting_key, setting_value, description)
            SELECT setting_key, setting_value, description
            FROM JSON_TABLE(v_control_settings_json, '$[*]'
                COLUMNS (
                    setting_key VARCHAR2(100) PATH '$.setting_key',
                    setting_value VARCHAR2(4000) PATH '$.setting_value',
                    description VARCHAR2(4000) PATH '$.description'
                ));
            v_result := v_result || 'CONTROL_SETTINGS: ' || SQL%ROWCOUNT || ' records' || CHR(10);

            INSERT INTO CONTROL_ENDPOINTS (endpoint_id, endpoint_key, endpoint_template, comments)
            SELECT endpoint_id, endpoint_key, endpoint_template, comments
            FROM JSON_TABLE(v_control_endpoints_json, '$[*]'
                COLUMNS (
                    endpoint_id NUMBER PATH '$.endpoint_id',
                    endpoint_key VARCHAR2(100) PATH '$.endpoint_key',
                    endpoint_template VARCHAR2(500) PATH '$.endpoint_template',
                    comments VARCHAR2(500) PATH '$.comments'
                ));
            v_result := v_result || 'CONTROL_ENDPOINTS: ' || SQL%ROWCOUNT || ' records' || CHR(10);

            INSERT INTO ETL_FILTER (filter_id, plant_id, plant_name, issue_revision,
                                   added_date, added_by_user_id, notes)
            SELECT filter_id, plant_id, plant_name, issue_revision,
                   TO_DATE(added_date, 'YYYY-MM-DD HH24:MI:SS'), added_by_user_id, notes
            FROM JSON_TABLE(v_etl_filter_json, '$[*]'
                COLUMNS (
                    filter_id NUMBER PATH '$.filter_id',
                    plant_id VARCHAR2(50) PATH '$.plant_id',
                    plant_name VARCHAR2(100) PATH '$.plant_name',
                    issue_revision VARCHAR2(50) PATH '$.issue_revision',
                    added_date VARCHAR2(30) PATH '$.added_date',
                    added_by_user_id VARCHAR2(50) PATH '$.added_by_user_id',
                    notes VARCHAR2(500) PATH '$.notes'
                ));
            v_result := v_result || 'ETL_FILTER: ' || SQL%ROWCOUNT || ' records';

            COMMIT;
        END IF;

        RETURN v_result;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20004, 'Control data backup ID ' || p_backup_id || ' not found');
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE_APPLICATION_ERROR(-20005, 'Restore failed: ' || SQLERRM);
    END restore_control_data;

    PROCEDURE list_backups(
        p_days_back NUMBER DEFAULT 7,
        p_schema_name VARCHAR2 DEFAULT USER
    ) IS
    BEGIN
        DBMS_OUTPUT.PUT_LINE('=== DDL Backups for ' || p_schema_name || ' (Last ' || p_days_back || ' days) ===');
        DBMS_OUTPUT.PUT_LINE(RPAD('ID', 5) || RPAD('Timestamp', 25) || RPAD('Type', 20) ||
                           RPAD('Objects', 10) || RPAD('Size(KB)', 10) || 'Notes');
        DBMS_OUTPUT.PUT_LINE(RPAD('-', 100, '-'));

        FOR rec IN (
            SELECT backup_id, backup_timestamp, backup_type, object_count,
                   ROUND(ddl_size_bytes/1024) as size_kb, backup_notes
            FROM DDL_BACKUP_OWNER.DDL_BACKUP
            WHERE schema_name = p_schema_name
            AND backup_timestamp >= SYSTIMESTAMP - p_days_back
            ORDER BY backup_timestamp DESC
        ) LOOP
            DBMS_OUTPUT.PUT_LINE(
                RPAD(rec.backup_id, 5) ||
                RPAD(TO_CHAR(rec.backup_timestamp, 'YYYY-MM-DD HH24:MI:SS'), 25) ||
                RPAD(NVL(rec.backup_type, 'UNKNOWN'), 20) ||
                RPAD(rec.object_count, 10) ||
                RPAD(rec.size_kb || 'KB', 10) ||
                NVL(SUBSTR(rec.backup_notes, 1, 30), 'No notes')
            );
        END LOOP;
    END list_backups;

    PROCEDURE compare_backups(
        p_backup_id_1 NUMBER,
        p_backup_id_2 NUMBER
    ) IS
        v_count1 NUMBER;
        v_count2 NUMBER;
        v_size1 NUMBER;
        v_size2 NUMBER;
        v_date1 TIMESTAMP;
        v_date2 TIMESTAMP;
    BEGIN
        SELECT object_count, ddl_size_bytes, backup_timestamp
        INTO v_count1, v_size1, v_date1
        FROM DDL_BACKUP_OWNER.DDL_BACKUP
        WHERE backup_id = p_backup_id_1;

        SELECT object_count, ddl_size_bytes, backup_timestamp
        INTO v_count2, v_size2, v_date2
        FROM DDL_BACKUP_OWNER.DDL_BACKUP
        WHERE backup_id = p_backup_id_2;

        DBMS_OUTPUT.PUT_LINE('=== Backup Comparison ===');
        DBMS_OUTPUT.PUT_LINE('Backup ' || p_backup_id_1 || ' (' || TO_CHAR(v_date1, 'YYYY-MM-DD HH24:MI') || ')');
        DBMS_OUTPUT.PUT_LINE('  Objects: ' || v_count1 || ', Size: ' || ROUND(v_size1/1024) || 'KB');
        DBMS_OUTPUT.PUT_LINE('Backup ' || p_backup_id_2 || ' (' || TO_CHAR(v_date2, 'YYYY-MM-DD HH24:MI') || ')');
        DBMS_OUTPUT.PUT_LINE('  Objects: ' || v_count2 || ', Size: ' || ROUND(v_size2/1024) || 'KB');
        DBMS_OUTPUT.PUT_LINE('Differences:');
        DBMS_OUTPUT.PUT_LINE('  Object count: ' || (v_count2 - v_count1));
        DBMS_OUTPUT.PUT_LINE('  Size change: ' || ROUND((v_size2 - v_size1)/1024) || 'KB');
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('Error: One or both backup IDs not found');
    END compare_backups;

    FUNCTION get_latest_backup_id(
        p_schema_name VARCHAR2 DEFAULT USER
    ) RETURN NUMBER IS
        v_backup_id NUMBER;
    BEGIN
        SELECT MAX(backup_id) INTO v_backup_id
        FROM DDL_BACKUP_OWNER.DDL_BACKUP
        WHERE schema_name = p_schema_name;

        RETURN v_backup_id;
    END get_latest_backup_id;

END PKG_DDL_BACKUP;
/


  CREATE OR REPLACE EDITIONABLE PACKAGE "TR2000_STAGING"."PKG_ETL_LOGGING" AS

    -- Run logging procedures
    FUNCTION start_etl_run(
        p_run_type      VARCHAR2,
        p_initiated_by  VARCHAR2 DEFAULT USER
    ) RETURN NUMBER;

    PROCEDURE end_etl_run(
        p_run_id    NUMBER,
        p_status    VARCHAR2  -- SUCCESS, FAILED, WARNING
    );

    -- Statistics logging
    FUNCTION log_operation_start(
        p_run_id            NUMBER,
        p_stat_type         VARCHAR2,  -- API_CALL, PROCESSING, CLEAR, SUMMARY
        p_endpoint_key      VARCHAR2 DEFAULT NULL,
        p_operation_name    VARCHAR2 DEFAULT NULL,
        p_plant_id          VARCHAR2 DEFAULT NULL,
        p_issue_revision    VARCHAR2 DEFAULT NULL,
        p_pcs_name          VARCHAR2 DEFAULT NULL
    ) RETURN NUMBER;

    PROCEDURE log_operation_end(
        p_stat_id           NUMBER,
        p_status            VARCHAR2,  -- SUCCESS, FAILED, WARNING
        p_records_processed NUMBER DEFAULT 0,
        p_records_inserted  NUMBER DEFAULT 0,
        p_records_updated   NUMBER DEFAULT 0,
        p_records_deleted   NUMBER DEFAULT 0,
        p_records_failed    NUMBER DEFAULT 0,
        p_api_response_size NUMBER DEFAULT NULL,
        p_api_status_code   NUMBER DEFAULT NULL,
        p_error_message     VARCHAR2 DEFAULT NULL
    );

    -- Error logging
    PROCEDURE log_error(
        p_endpoint_key      VARCHAR2,
        p_plant_id          VARCHAR2 DEFAULT NULL,
        p_issue_revision    VARCHAR2 DEFAULT NULL,
        p_error_type        VARCHAR2 DEFAULT 'PROCESSING_ERROR',
        p_error_code        VARCHAR2 DEFAULT NULL,
        p_error_message     VARCHAR2,
        p_error_stack       CLOB DEFAULT NULL,
        p_raw_data          CLOB DEFAULT NULL
    );

    -- Quick logging procedures for common operations
    PROCEDURE log_api_call(
        p_run_id            NUMBER,
        p_endpoint_key      VARCHAR2,
        p_plant_id          VARCHAR2 DEFAULT NULL,
        p_issue_revision    VARCHAR2 DEFAULT NULL,
        p_duration_ms       NUMBER,
        p_response_size     NUMBER,
        p_status_code       NUMBER,
        p_status            VARCHAR2
    );

    PROCEDURE log_clear_operation(
        p_run_id            NUMBER,
        p_table_name        VARCHAR2,
        p_records_deleted   NUMBER,
        p_duration_ms       NUMBER DEFAULT NULL
    );

    -- Summary statistics
    PROCEDURE log_run_summary(
        p_run_id            NUMBER
    );

    -- Utility to get current run_id (for nested procedures)
    FUNCTION get_current_run_id RETURN NUMBER;
    PROCEDURE set_current_run_id(p_run_id NUMBER);

END PKG_ETL_LOGGING;
CREATE OR REPLACE EDITIONABLE PACKAGE BODY "TR2000_STAGING"."PKG_ETL_LOGGING" AS

    -- Package variable to store current run_id
    g_current_run_id NUMBER;

    -- Start ETL run
    FUNCTION start_etl_run(
        p_run_type      VARCHAR2,
        p_initiated_by  VARCHAR2 DEFAULT USER
    ) RETURN NUMBER IS
        v_run_id NUMBER;
    BEGIN
        -- Get next run_id
        SELECT ETL_RUN_SEQ.NEXTVAL INTO v_run_id FROM DUAL;

        -- Insert into ETL_RUN_LOG
        INSERT INTO ETL_RUN_LOG (
            run_id, run_type, start_time, status, initiated_by
        ) VALUES (
            v_run_id, p_run_type, SYSTIMESTAMP, 'RUNNING', p_initiated_by
        );

        -- Store run_id in package variable
        g_current_run_id := v_run_id;

        COMMIT;
        RETURN v_run_id;
    END start_etl_run;

    -- End ETL run
    PROCEDURE end_etl_run(
        p_run_id    NUMBER,
        p_status    VARCHAR2  -- SUCCESS, FAILED, WARNING
    ) IS
    BEGIN
        -- Update ETL_RUN_LOG
        UPDATE ETL_RUN_LOG
        SET end_time = SYSTIMESTAMP,
            status = p_status
        WHERE run_id = p_run_id;

        -- Log summary statistics
        log_run_summary(p_run_id);

        COMMIT;
    END end_etl_run;

    -- Statistics logging
    FUNCTION log_operation_start(
        p_run_id            NUMBER,
        p_stat_type         VARCHAR2,  -- API_CALL, PROCESSING, CLEAR, SUMMARY
        p_endpoint_key      VARCHAR2 DEFAULT NULL,
        p_operation_name    VARCHAR2 DEFAULT NULL,
        p_plant_id          VARCHAR2 DEFAULT NULL,
        p_issue_revision    VARCHAR2 DEFAULT NULL,
        p_pcs_name          VARCHAR2 DEFAULT NULL
    ) RETURN NUMBER IS
        v_stat_id NUMBER;
    BEGIN
        INSERT INTO ETL_STATISTICS (
            run_id, stat_type, endpoint_key, operation_name,
            plant_id, issue_revision, pcs_name,
            start_time, status
        ) VALUES (
            p_run_id, p_stat_type, p_endpoint_key, p_operation_name,
            p_plant_id, p_issue_revision, p_pcs_name,
            SYSTIMESTAMP, 'RUNNING'
        ) RETURNING stat_id INTO v_stat_id;

        COMMIT;
        RETURN v_stat_id;
    END log_operation_start;

    PROCEDURE log_operation_end(
        p_stat_id           NUMBER,
        p_status            VARCHAR2,  -- SUCCESS, FAILED, WARNING
        p_records_processed NUMBER DEFAULT 0,
        p_records_inserted  NUMBER DEFAULT 0,
        p_records_updated   NUMBER DEFAULT 0,
        p_records_deleted   NUMBER DEFAULT 0,
        p_records_failed    NUMBER DEFAULT 0,
        p_api_response_size NUMBER DEFAULT NULL,
        p_api_status_code   NUMBER DEFAULT NULL,
        p_error_message     VARCHAR2 DEFAULT NULL
    ) IS
    BEGIN
        UPDATE ETL_STATISTICS
        SET end_time = SYSTIMESTAMP,
            status = p_status,
            records_processed = p_records_processed,
            records_inserted = p_records_inserted,
            records_updated = p_records_updated,
            records_deleted = p_records_deleted,
            records_failed = p_records_failed,
            api_response_size = p_api_response_size,
            api_status_code = p_api_status_code,
            error_message = p_error_message
        WHERE stat_id = p_stat_id;

        COMMIT;
    END log_operation_end;

    -- Error logging
    PROCEDURE log_error(
        p_endpoint_key      VARCHAR2,
        p_plant_id          VARCHAR2 DEFAULT NULL,
        p_issue_revision    VARCHAR2 DEFAULT NULL,
        p_error_type        VARCHAR2 DEFAULT 'PROCESSING_ERROR',
        p_error_code        VARCHAR2 DEFAULT NULL,
        p_error_message     VARCHAR2,
        p_error_stack       CLOB DEFAULT NULL,
        p_raw_data          CLOB DEFAULT NULL
    ) IS
    BEGIN
        INSERT INTO ETL_ERROR_LOG (
            error_id, endpoint_key, plant_id, issue_revision,
            error_timestamp, error_type, error_code, error_message,
            error_stack, raw_data
        ) VALUES (
            ETL_ERROR_SEQ.NEXTVAL, p_endpoint_key, p_plant_id, p_issue_revision,
            SYSTIMESTAMP, p_error_type, p_error_code, p_error_message,
            p_error_stack, p_raw_data
        );

        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            NULL; -- Don't let logging errors break the main process
    END log_error;

    -- Quick logging procedures for common operations
    PROCEDURE log_api_call(
        p_run_id            NUMBER,
        p_endpoint_key      VARCHAR2,
        p_plant_id          VARCHAR2 DEFAULT NULL,
        p_issue_revision    VARCHAR2 DEFAULT NULL,
        p_duration_ms       NUMBER,
        p_response_size     NUMBER,
        p_status_code       NUMBER,
        p_status            VARCHAR2
    ) IS
        v_stat_id NUMBER;
    BEGIN
        INSERT INTO ETL_STATISTICS (
            run_id, stat_type, endpoint_key, plant_id, issue_revision,
            start_time, end_time, status,
            api_response_size, api_status_code
        ) VALUES (
            p_run_id, 'API_CALL', p_endpoint_key, p_plant_id, p_issue_revision,
            SYSTIMESTAMP - NUMTODSINTERVAL(p_duration_ms/1000, 'SECOND'),
            SYSTIMESTAMP, p_status,
            p_response_size, p_status_code
        );

        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            NULL; -- Don't let logging errors break the main process
    END log_api_call;

    PROCEDURE log_clear_operation(
        p_run_id            NUMBER,
        p_table_name        VARCHAR2,
        p_records_deleted   NUMBER,
        p_duration_ms       NUMBER DEFAULT NULL
    ) IS
    BEGIN
        INSERT INTO ETL_STATISTICS (
            run_id, stat_type, operation_name,
            start_time, end_time, status,
            records_deleted
        ) VALUES (
            p_run_id, 'CLEAR', 'Clear ' || p_table_name,
            SYSTIMESTAMP - NUMTODSINTERVAL(NVL(p_duration_ms, 100)/1000, 'SECOND'),
            SYSTIMESTAMP, 'SUCCESS',
            p_records_deleted
        );

        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            NULL; -- Don't let logging errors break the main process
    END log_clear_operation;

    -- Summary statistics - PROPERLY IMPLEMENTED
    PROCEDURE log_run_summary(
        p_run_id            NUMBER
    ) IS
        v_total_operations NUMBER;
        v_successful_ops NUMBER;
        v_failed_ops NUMBER;
        v_total_records NUMBER;
        v_total_api_calls NUMBER;
        v_run_duration_seconds NUMBER;
    BEGIN
        -- Calculate summary statistics
        SELECT
            COUNT(*),
            SUM(CASE WHEN status = 'SUCCESS' THEN 1 ELSE 0 END),
            SUM(CASE WHEN status = 'FAILED' THEN 1 ELSE 0 END),
            SUM(NVL(records_processed, 0) + NVL(records_inserted, 0) +
                NVL(records_updated, 0) + NVL(records_deleted, 0)),
            SUM(CASE WHEN stat_type = 'API_CALL' THEN 1 ELSE 0 END)
        INTO
            v_total_operations,
            v_successful_ops,
            v_failed_ops,
            v_total_records,
            v_total_api_calls
        FROM ETL_STATISTICS
        WHERE run_id = p_run_id;

        -- Calculate run duration
        SELECT EXTRACT(SECOND FROM (end_time - start_time)) +
               EXTRACT(MINUTE FROM (end_time - start_time)) * 60 +
               EXTRACT(HOUR FROM (end_time - start_time)) * 3600
        INTO v_run_duration_seconds
        FROM ETL_RUN_LOG
        WHERE run_id = p_run_id;

        -- Insert summary as a SUMMARY type statistic
        INSERT INTO ETL_STATISTICS (
            run_id, stat_type, operation_name,
            start_time, end_time, status,
            records_processed,
            api_status_code,  -- Using this for total operations count
            api_response_size -- Using this for API call count
        ) VALUES (
            p_run_id, 'SUMMARY', 'ETL Run Summary',
            SYSTIMESTAMP - NUMTODSINTERVAL(v_run_duration_seconds, 'SECOND'),
            SYSTIMESTAMP,
            CASE WHEN v_failed_ops = 0 THEN 'SUCCESS' ELSE 'WARNING' END,
            v_total_records,
            v_total_operations,
            v_total_api_calls
        );

        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            NULL; -- Don't let summary errors break the main process
    END log_run_summary;

    -- Utility to get current run_id (for nested procedures)
    FUNCTION get_current_run_id RETURN NUMBER IS
    BEGIN
        RETURN g_current_run_id;
    END get_current_run_id;

    PROCEDURE set_current_run_id(p_run_id NUMBER) IS
    BEGIN
        g_current_run_id := p_run_id;
    END set_current_run_id;

END PKG_ETL_LOGGING;
/


  CREATE OR REPLACE EDITIONABLE PACKAGE "TR2000_STAGING"."PKG_ETL_PROCESSOR" AS
    -- Parse individual reference types
    PROCEDURE parse_and_load_pcs_references(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2,
        p_issue_revision IN VARCHAR2
    );

    PROCEDURE parse_and_load_vds_references(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2,
        p_issue_revision IN VARCHAR2
    );

    PROCEDURE parse_and_load_mds_references(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2,
        p_issue_revision IN VARCHAR2
    );

    PROCEDURE parse_and_load_eds_references(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2,
        p_issue_revision IN VARCHAR2
    );

    PROCEDURE parse_and_load_vsk_references(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2,
        p_issue_revision IN VARCHAR2
    );

    PROCEDURE parse_and_load_esk_references(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2,
        p_issue_revision IN VARCHAR2
    );

    PROCEDURE parse_and_load_pipe_element_references(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2,
        p_issue_revision IN VARCHAR2
    );

    PROCEDURE parse_and_load_sc_references(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2,
        p_issue_revision IN VARCHAR2
    );

    PROCEDURE parse_and_load_vsm_references(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2,
        p_issue_revision IN VARCHAR2
    );

    -- Parse PCS list
    PROCEDURE parse_and_load_pcs_list(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2
    );

    -- Parse PCS details
    PROCEDURE parse_and_load_pcs_details(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2,
        p_pcs_name IN VARCHAR2,
        p_revision IN VARCHAR2,
        p_detail_type IN VARCHAR2
    );

    -- Parse VDS catalog
    PROCEDURE parse_and_load_vds_catalog(
        p_raw_json_id IN NUMBER
    );
END PKG_ETL_PROCESSOR;
CREATE OR REPLACE EDITIONABLE PACKAGE BODY "TR2000_STAGING"."PKG_ETL_PROCESSOR" AS

    -- =====================================================
    -- PARSE AND LOAD PCS REFERENCES
    -- =====================================================
    PROCEDURE parse_and_load_pcs_references(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2,
        p_issue_revision IN VARCHAR2
    ) IS
        v_json CLOB;
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Step 1: Get JSON from RAW_JSON
        SELECT payload INTO v_json
        FROM RAW_JSON
        WHERE raw_json_id = p_raw_json_id;

        -- Step 2: Clear staging table
        DELETE FROM STG_PCS_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        -- Step 3: Parse JSON to staging table
        INSERT INTO STG_PCS_REFERENCES (
            plant_id, issue_revision,
            "PCS", "Revision", "RevDate", "Status",
            "OfficialRevision", "RevisionSuffix", "RatingClass",
            "MaterialGroup", "HistoricalPCS", "Delta"
        )
        SELECT
            p_plant_id, p_issue_revision,
            jt.PCS, jt.Revision, jt.RevDate, jt.Status,
            jt.OfficialRevision, jt.RevisionSuffix, jt.RatingClass,
            jt.MaterialGroup, jt.HistoricalPCS, jt.Delta
        FROM JSON_TABLE(v_json, '$.getIssuePCSList[*]'
            COLUMNS (
                PCS VARCHAR2(100) PATH '$.PCS',
                Revision VARCHAR2(50) PATH '$.Revision',
                RevDate VARCHAR2(50) PATH '$.RevDate',
                Status VARCHAR2(50) PATH '$.Status',
                OfficialRevision VARCHAR2(50) PATH '$.OfficialRevision',
                RevisionSuffix VARCHAR2(50) PATH '$.RevisionSuffix',
                RatingClass VARCHAR2(100) PATH '$.RatingClass',
                MaterialGroup VARCHAR2(100) PATH '$.MaterialGroup',
                HistoricalPCS VARCHAR2(100) PATH '$.HistoricalPCS',
                Delta VARCHAR2(50) PATH '$.Delta'
            )
        ) jt;

        -- Step 4: Move from staging to core table with type conversion
        DELETE FROM PCS_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        INSERT INTO PCS_REFERENCES (
            pcs_references_guid, plant_id, issue_revision, pcs_name,
            revision, rev_date, status, official_revision,
            revision_suffix, rating_class, material_group,
            historical_pcs, delta, created_date, last_modified_date
        )
        SELECT
            SYS_GUID(), plant_id, issue_revision, "PCS",
            "Revision", PKG_DATE_UTILS.safe_parse_date("RevDate"),
            "Status", "OfficialRevision", "RevisionSuffix",
            "RatingClass", "MaterialGroup", "HistoricalPCS",
            "Delta", SYSDATE, SYSDATE
        FROM STG_PCS_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

    EXCEPTION
        WHEN OTHERS THEN
            v_error_msg := 'Error in parse_and_load_pcs_references: ' || SQLERRM;
            PKG_ETL_LOGGING.log_error(
                p_endpoint_key => 'PCS_REFERENCES',
                p_plant_id => p_plant_id,
                p_issue_revision => p_issue_revision,
                p_error_type => 'PROCESSING_ERROR',
                p_error_code => 'PCS_PARSE_ERROR',
                p_error_message => v_error_msg,
                p_raw_data => v_json
            );
            RAISE;
    END parse_and_load_pcs_references;

    -- =====================================================
    -- PARSE AND LOAD VDS REFERENCES
    -- =====================================================
    PROCEDURE parse_and_load_vds_references(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2,
        p_issue_revision IN VARCHAR2
    ) IS
        v_json CLOB;
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Step 1: Get JSON from RAW_JSON
        SELECT payload INTO v_json
        FROM RAW_JSON
        WHERE raw_json_id = p_raw_json_id;

        -- Step 2: Clear staging table
        DELETE FROM STG_VDS_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        -- Step 3: Parse JSON to staging table
        INSERT INTO STG_VDS_REFERENCES (
            plant_id, issue_revision,
            "VDS", "Revision", "RevDate", "Status",
            "OfficialRevision", "Delta"
        )
        SELECT
            p_plant_id, p_issue_revision,
            jt.VDS, jt.Revision, jt.RevDate, jt.Status,
            jt.OfficialRevision, jt.Delta
        FROM JSON_TABLE(v_json, '$.getIssueVDSList[*]'
            COLUMNS (
                VDS VARCHAR2(100) PATH '$.VDS',
                Revision VARCHAR2(50) PATH '$.Revision',
                RevDate VARCHAR2(50) PATH '$.RevDate',
                Status VARCHAR2(50) PATH '$.Status',
                OfficialRevision VARCHAR2(50) PATH '$.OfficialRevision',
                Delta VARCHAR2(50) PATH '$.Delta'
            )
        ) jt;

        -- Step 4: Move from staging to core table with type conversion
        DELETE FROM VDS_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        INSERT INTO VDS_REFERENCES (
            vds_references_guid, plant_id, issue_revision, vds_name,
            revision, rev_date, status, official_revision,
            delta, created_date, last_modified_date
        )
        SELECT
            SYS_GUID(), plant_id, issue_revision, "VDS",
            "Revision", PKG_DATE_UTILS.safe_parse_date("RevDate"),
            "Status", "OfficialRevision", "Delta",
            SYSDATE, SYSDATE
        FROM STG_VDS_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

    EXCEPTION
        WHEN OTHERS THEN
            v_error_msg := 'Error in parse_and_load_vds_references: ' || SQLERRM;
            PKG_ETL_LOGGING.log_error(
                p_endpoint_key => 'VDS_REFERENCES',
                p_plant_id => p_plant_id,
                p_issue_revision => p_issue_revision,
                p_error_type => 'PROCESSING_ERROR',
                p_error_code => 'VDS_PARSE_ERROR',
                p_error_message => v_error_msg,
                p_raw_data => v_json
            );
            RAISE;
    END parse_and_load_vds_references;

    -- =====================================================
    -- PARSE AND LOAD MDS REFERENCES
    -- =====================================================
    PROCEDURE parse_and_load_mds_references(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2,
        p_issue_revision IN VARCHAR2
    ) IS
        v_json CLOB;
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Step 1: Get JSON from RAW_JSON
        SELECT payload INTO v_json
        FROM RAW_JSON
        WHERE raw_json_id = p_raw_json_id;

        -- Step 2: Clear staging table
        DELETE FROM STG_MDS_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        -- Step 3: Parse JSON to staging table
        INSERT INTO STG_MDS_REFERENCES (
            plant_id, issue_revision,
            "MDS", "Revision", "Area", "RevDate",
            "Status", "OfficialRevision", "Delta"
        )
        SELECT
            p_plant_id, p_issue_revision,
            jt.MDS, jt.Revision, jt.Area, jt.RevDate,
            jt.Status, jt.OfficialRevision, jt.Delta
        FROM JSON_TABLE(v_json, '$.getIssueMDSList[*]'
            COLUMNS (
                MDS VARCHAR2(100) PATH '$.MDS',
                Revision VARCHAR2(50) PATH '$.Revision',
                Area VARCHAR2(100) PATH '$.Area',
                RevDate VARCHAR2(50) PATH '$.RevDate',
                Status VARCHAR2(50) PATH '$.Status',
                OfficialRevision VARCHAR2(50) PATH '$.OfficialRevision',
                Delta VARCHAR2(50) PATH '$.Delta'
            )
        ) jt;

        -- Step 4: Move from staging to core table with type conversion
        DELETE FROM MDS_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        INSERT INTO MDS_REFERENCES (
            mds_references_guid, plant_id, issue_revision, mds_name,
            revision, area, rev_date, status, official_revision,
            delta, created_date, last_modified_date
        )
        SELECT
            SYS_GUID(), plant_id, issue_revision, "MDS",
            "Revision", "Area", PKG_DATE_UTILS.safe_parse_date("RevDate"),
            "Status", "OfficialRevision", "Delta",
            SYSDATE, SYSDATE
        FROM STG_MDS_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

    EXCEPTION
        WHEN OTHERS THEN
            v_error_msg := 'Error in parse_and_load_mds_references: ' || SQLERRM;
            PKG_ETL_LOGGING.log_error(
                p_endpoint_key => 'MDS_REFERENCES',
                p_plant_id => p_plant_id,
                p_issue_revision => p_issue_revision,
                p_error_type => 'PROCESSING_ERROR',
                p_error_code => 'MDS_PARSE_ERROR',
                p_error_message => v_error_msg,
                p_raw_data => v_json
            );
            RAISE;
    END parse_and_load_mds_references;

    -- =====================================================
    -- PARSE AND LOAD EDS REFERENCES
    -- =====================================================
    PROCEDURE parse_and_load_eds_references(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2,
        p_issue_revision IN VARCHAR2
    ) IS
        v_json CLOB;
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Step 1: Get JSON from RAW_JSON
        SELECT payload INTO v_json
        FROM RAW_JSON
        WHERE raw_json_id = p_raw_json_id;

        -- Step 2: Clear staging table
        DELETE FROM STG_EDS_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        -- Step 3: Parse JSON to staging table
        INSERT INTO STG_EDS_REFERENCES (
            plant_id, issue_revision,
            "EDS", "Revision", "RevDate", "Status",
            "OfficialRevision", "Delta"
        )
        SELECT
            p_plant_id, p_issue_revision,
            jt.EDS, jt.Revision, jt.RevDate, jt.Status,
            jt.OfficialRevision, jt.Delta
        FROM JSON_TABLE(v_json, '$.getIssueEDSList[*]'
            COLUMNS (
                EDS VARCHAR2(100) PATH '$.EDS',
                Revision VARCHAR2(50) PATH '$.Revision',
                RevDate VARCHAR2(50) PATH '$.RevDate',
                Status VARCHAR2(50) PATH '$.Status',
                OfficialRevision VARCHAR2(50) PATH '$.OfficialRevision',
                Delta VARCHAR2(50) PATH '$.Delta'
            )
        ) jt;

        -- Step 4: Move from staging to core table with type conversion
        DELETE FROM EDS_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        INSERT INTO EDS_REFERENCES (
            eds_references_guid, plant_id, issue_revision, eds_name,
            revision, rev_date, status, official_revision,
            delta, created_date, last_modified_date
        )
        SELECT
            SYS_GUID(), plant_id, issue_revision, "EDS",
            "Revision", PKG_DATE_UTILS.safe_parse_date("RevDate"),
            "Status", "OfficialRevision", "Delta",
            SYSDATE, SYSDATE
        FROM STG_EDS_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

    EXCEPTION
        WHEN OTHERS THEN
            v_error_msg := 'Error in parse_and_load_eds_references: ' || SQLERRM;
            PKG_ETL_LOGGING.log_error(
                p_endpoint_key => 'EDS_REFERENCES',
                p_plant_id => p_plant_id,
                p_issue_revision => p_issue_revision,
                p_error_type => 'PROCESSING_ERROR',
                p_error_code => 'EDS_PARSE_ERROR',
                p_error_message => v_error_msg,
                p_raw_data => v_json
            );
            RAISE;
    END parse_and_load_eds_references;

    -- =====================================================
    -- PARSE AND LOAD VSK REFERENCES
    -- =====================================================
    PROCEDURE parse_and_load_vsk_references(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2,
        p_issue_revision IN VARCHAR2
    ) IS
        v_json CLOB;
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Step 1: Get JSON from RAW_JSON
        SELECT payload INTO v_json
        FROM RAW_JSON
        WHERE raw_json_id = p_raw_json_id;

        -- Step 2: Clear staging table
        DELETE FROM STG_VSK_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        -- Step 3: Parse JSON to staging table
        INSERT INTO STG_VSK_REFERENCES (
            plant_id, issue_revision,
            "VSK", "Revision", "RevDate", "Status",
            "OfficialRevision", "Delta"
        )
        SELECT
            p_plant_id, p_issue_revision,
            jt.VSK, jt.Revision, jt.RevDate, jt.Status,
            jt.OfficialRevision, jt.Delta
        FROM JSON_TABLE(v_json, '$.getIssueVSKList[*]'
            COLUMNS (
                VSK VARCHAR2(100) PATH '$.VSK',
                Revision VARCHAR2(50) PATH '$.Revision',
                RevDate VARCHAR2(50) PATH '$.RevDate',
                Status VARCHAR2(50) PATH '$.Status',
                OfficialRevision VARCHAR2(50) PATH '$.OfficialRevision',
                Delta VARCHAR2(50) PATH '$.Delta'
            )
        ) jt;

        -- Step 4: Move from staging to core table with type conversion
        DELETE FROM VSK_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        INSERT INTO VSK_REFERENCES (
            vsk_references_guid, plant_id, issue_revision, vsk_name,
            revision, rev_date, status, official_revision,
            delta, created_date, last_modified_date
        )
        SELECT
            SYS_GUID(), plant_id, issue_revision, "VSK",
            "Revision", PKG_DATE_UTILS.safe_parse_date("RevDate"),
            "Status", "OfficialRevision", "Delta",
            SYSDATE, SYSDATE
        FROM STG_VSK_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

    EXCEPTION
        WHEN OTHERS THEN
            v_error_msg := 'Error in parse_and_load_vsk_references: ' || SQLERRM;
            PKG_ETL_LOGGING.log_error(
                p_endpoint_key => 'VSK_REFERENCES',
                p_plant_id => p_plant_id,
                p_issue_revision => p_issue_revision,
                p_error_type => 'PROCESSING_ERROR',
                p_error_code => 'VSK_PARSE_ERROR',
                p_error_message => v_error_msg,
                p_raw_data => v_json
            );
            RAISE;
    END parse_and_load_vsk_references;

    -- =====================================================
    -- PARSE AND LOAD ESK REFERENCES
    -- =====================================================
    PROCEDURE parse_and_load_esk_references(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2,
        p_issue_revision IN VARCHAR2
    ) IS
        v_json CLOB;
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Step 1: Get JSON from RAW_JSON
        SELECT payload INTO v_json
        FROM RAW_JSON
        WHERE raw_json_id = p_raw_json_id;

        -- Step 2: Clear staging table
        DELETE FROM STG_ESK_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        -- Step 3: Parse JSON to staging table
        INSERT INTO STG_ESK_REFERENCES (
            plant_id, issue_revision,
            "ESK", "Revision", "RevDate", "Status",
            "OfficialRevision", "Delta"
        )
        SELECT
            p_plant_id, p_issue_revision,
            jt.ESK, jt.Revision, jt.RevDate, jt.Status,
            jt.OfficialRevision, jt.Delta
        FROM JSON_TABLE(v_json, '$.getIssueESKList[*]'
            COLUMNS (
                ESK VARCHAR2(100) PATH '$.ESK',
                Revision VARCHAR2(50) PATH '$.Revision',
                RevDate VARCHAR2(50) PATH '$.RevDate',
                Status VARCHAR2(50) PATH '$.Status',
                OfficialRevision VARCHAR2(50) PATH '$.OfficialRevision',
                Delta VARCHAR2(50) PATH '$.Delta'
            )
        ) jt;

        -- Step 4: Move from staging to core table with type conversion
        DELETE FROM ESK_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        INSERT INTO ESK_REFERENCES (
            esk_references_guid, plant_id, issue_revision, esk_name,
            revision, rev_date, status, official_revision,
            delta, created_date, last_modified_date
        )
        SELECT
            SYS_GUID(), plant_id, issue_revision, "ESK",
            "Revision", PKG_DATE_UTILS.safe_parse_date("RevDate"),
            "Status", "OfficialRevision", "Delta",
            SYSDATE, SYSDATE
        FROM STG_ESK_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

    EXCEPTION
        WHEN OTHERS THEN
            v_error_msg := 'Error in parse_and_load_esk_references: ' || SQLERRM;
            PKG_ETL_LOGGING.log_error(
                p_endpoint_key => 'ESK_REFERENCES',
                p_plant_id => p_plant_id,
                p_issue_revision => p_issue_revision,
                p_error_type => 'PROCESSING_ERROR',
                p_error_code => 'ESK_PARSE_ERROR',
                p_error_message => v_error_msg,
                p_raw_data => v_json
            );
            RAISE;
    END parse_and_load_esk_references;

    -- =====================================================
    -- PARSE AND LOAD PIPE ELEMENT REFERENCES
    -- =====================================================
    PROCEDURE parse_and_load_pipe_element_references(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2,
        p_issue_revision IN VARCHAR2
    ) IS
        v_json CLOB;
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Step 1: Get JSON from RAW_JSON
        SELECT payload INTO v_json
        FROM RAW_JSON
        WHERE raw_json_id = p_raw_json_id;

        -- Step 2: Clear staging table
        DELETE FROM STG_PIPE_ELEMENT_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        -- Step 3: Parse JSON to staging table
        INSERT INTO STG_PIPE_ELEMENT_REFERENCES (
            plant_id, issue_revision,
            "ElementID", "ElementGroup", "DimensionStandard",
            "ProductForm", "MaterialGrade", "MDS", "MDSRevision",
            "Area", "Revision", "RevDate", "Status", "Delta"
        )
        SELECT
            p_plant_id, p_issue_revision,
            jt.ElementID, jt.ElementGroup, jt.DimensionStandard,
            jt.ProductForm, jt.MaterialGrade, jt.MDS, jt.MDSRevision,
            jt.Area, jt.Revision, jt.RevDate, jt.Status, jt.Delta
        FROM JSON_TABLE(v_json, '$.getIssuePipeElementList[*]'
            COLUMNS (
                ElementID VARCHAR2(50) PATH '$.ElementID',
                ElementGroup VARCHAR2(100) PATH '$.ElementGroup',
                DimensionStandard VARCHAR2(100) PATH '$.DimensionStandard',
                ProductForm VARCHAR2(100) PATH '$.ProductForm',
                MaterialGrade VARCHAR2(200) PATH '$.MaterialGrade',
                MDS VARCHAR2(100) PATH '$.MDS',
                MDSRevision VARCHAR2(50) PATH '$.MDSRevision',
                Area VARCHAR2(100) PATH '$.Area',
                Revision VARCHAR2(50) PATH '$.Revision',
                RevDate VARCHAR2(50) PATH '$.RevDate',
                Status VARCHAR2(50) PATH '$.Status',
                Delta VARCHAR2(50) PATH '$.Delta'
            )
        ) jt;

        -- Step 4: Move from staging to core table with type conversion
        DELETE FROM PIPE_ELEMENT_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        INSERT INTO PIPE_ELEMENT_REFERENCES (
            pipe_element_references_guid, plant_id, issue_revision,
            element_id, element_group, dimension_standard,
            product_form, material_grade, mds, mds_revision,
            area, revision, rev_date, status, delta,
            created_date, last_modified_date
        )
        SELECT
            SYS_GUID(), plant_id, issue_revision,
            TO_NUMBER("ElementID"), "ElementGroup", "DimensionStandard",
            "ProductForm", "MaterialGrade", "MDS", "MDSRevision",
            "Area", "Revision", PKG_DATE_UTILS.safe_parse_date("RevDate"),
            "Status", "Delta", SYSDATE, SYSDATE
        FROM STG_PIPE_ELEMENT_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

    EXCEPTION
        WHEN OTHERS THEN
            v_error_msg := 'Error in parse_and_load_pipe_element_references: ' || SQLERRM;
            PKG_ETL_LOGGING.log_error(
                p_endpoint_key => 'PIPE_ELEMENT_REFERENCES',
                p_plant_id => p_plant_id,
                p_issue_revision => p_issue_revision,
                p_error_type => 'PROCESSING_ERROR',
                p_error_code => 'PIPE_ELEMENT_PARSE_ERROR',
                p_error_message => v_error_msg,
                p_raw_data => v_json
            );
            RAISE;
    END parse_and_load_pipe_element_references;

    -- =====================================================
    -- PARSE AND LOAD SC REFERENCES
    -- =====================================================
    PROCEDURE parse_and_load_sc_references(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2,
        p_issue_revision IN VARCHAR2
    ) IS
        v_json CLOB;
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Step 1: Get JSON from RAW_JSON
        SELECT payload INTO v_json
        FROM RAW_JSON
        WHERE raw_json_id = p_raw_json_id;

        -- Step 2: Clear staging table
        DELETE FROM STG_SC_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        -- Step 3: Parse JSON to staging table
        INSERT INTO STG_SC_REFERENCES (
            plant_id, issue_revision,
            "SC", "Revision", "RevDate", "Status",
            "OfficialRevision", "Delta"
        )
        SELECT
            p_plant_id, p_issue_revision,
            jt.SC, jt.Revision, jt.RevDate, jt.Status,
            jt.OfficialRevision, jt.Delta
        FROM JSON_TABLE(v_json, '$.getIssueSCList[*]'
            COLUMNS (
                SC VARCHAR2(100) PATH '$.SC',
                Revision VARCHAR2(50) PATH '$.Revision',
                RevDate VARCHAR2(50) PATH '$.RevDate',
                Status VARCHAR2(50) PATH '$.Status',
                OfficialRevision VARCHAR2(50) PATH '$.OfficialRevision',
                Delta VARCHAR2(50) PATH '$.Delta'
            )
        ) jt;

        -- Step 4: Move from staging to core table with type conversion
        DELETE FROM SC_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        INSERT INTO SC_REFERENCES (
            sc_references_guid, plant_id, issue_revision, sc_name,
            revision, rev_date, status, official_revision,
            delta, created_date, last_modified_date
        )
        SELECT
            SYS_GUID(), plant_id, issue_revision, "SC",
            "Revision", PKG_DATE_UTILS.safe_parse_date("RevDate"),
            "Status", "OfficialRevision", "Delta",
            SYSDATE, SYSDATE
        FROM STG_SC_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

    EXCEPTION
        WHEN OTHERS THEN
            v_error_msg := 'Error in parse_and_load_sc_references: ' || SQLERRM;
            PKG_ETL_LOGGING.log_error(
                p_endpoint_key => 'SC_REFERENCES',
                p_plant_id => p_plant_id,
                p_issue_revision => p_issue_revision,
                p_error_type => 'PROCESSING_ERROR',
                p_error_code => 'SC_PARSE_ERROR',
                p_error_message => v_error_msg,
                p_raw_data => v_json
            );
            RAISE;
    END parse_and_load_sc_references;

    -- =====================================================
    -- PARSE AND LOAD VSM REFERENCES
    -- =====================================================
    PROCEDURE parse_and_load_vsm_references(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2,
        p_issue_revision IN VARCHAR2
    ) IS
        v_json CLOB;
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Step 1: Get JSON from RAW_JSON
        SELECT payload INTO v_json
        FROM RAW_JSON
        WHERE raw_json_id = p_raw_json_id;

        -- Step 2: Clear staging table
        DELETE FROM STG_VSM_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        -- Step 3: Parse JSON to staging table
        INSERT INTO STG_VSM_REFERENCES (
            plant_id, issue_revision,
            "VSM", "Revision", "RevDate", "Status",
            "OfficialRevision", "Delta"
        )
        SELECT
            p_plant_id, p_issue_revision,
            jt.VSM, jt.Revision, jt.RevDate, jt.Status,
            jt.OfficialRevision, jt.Delta
        FROM JSON_TABLE(v_json, '$.getIssueVSMList[*]'
            COLUMNS (
                VSM VARCHAR2(100) PATH '$.VSM',
                Revision VARCHAR2(50) PATH '$.Revision',
                RevDate VARCHAR2(50) PATH '$.RevDate',
                Status VARCHAR2(50) PATH '$.Status',
                OfficialRevision VARCHAR2(50) PATH '$.OfficialRevision',
                Delta VARCHAR2(50) PATH '$.Delta'
            )
        ) jt;

        -- Step 4: Move from staging to core table with type conversion
        DELETE FROM VSM_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        INSERT INTO VSM_REFERENCES (
            vsm_references_guid, plant_id, issue_revision, vsm_name,
            revision, rev_date, status, official_revision,
            delta, created_date, last_modified_date
        )
        SELECT
            SYS_GUID(), plant_id, issue_revision, "VSM",
            "Revision", PKG_DATE_UTILS.safe_parse_date("RevDate"),
            "Status", "OfficialRevision", "Delta",
            SYSDATE, SYSDATE
        FROM STG_VSM_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

    EXCEPTION
        WHEN OTHERS THEN
            v_error_msg := 'Error in parse_and_load_vsm_references: ' || SQLERRM;
            PKG_ETL_LOGGING.log_error(
                p_endpoint_key => 'VSM_REFERENCES',
                p_plant_id => p_plant_id,
                p_issue_revision => p_issue_revision,
                p_error_type => 'PROCESSING_ERROR',
                p_error_code => 'VSM_PARSE_ERROR',
                p_error_message => v_error_msg,
                p_raw_data => v_json
            );
            RAISE;
    END parse_and_load_vsm_references;

    -- =====================================================
    -- PARSE AND LOAD PCS LIST
    -- =====================================================
    PROCEDURE parse_and_load_pcs_list(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2
    ) IS
        v_json CLOB;
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Step 1: Get JSON from RAW_JSON
        SELECT payload INTO v_json
        FROM RAW_JSON
        WHERE raw_json_id = p_raw_json_id;

        -- Step 2: Clear staging table
        DELETE FROM STG_PCS_LIST
        WHERE plant_id = p_plant_id;

        -- Step 3: Parse JSON to staging table - FIXED: $.getPCS[*]
        INSERT INTO STG_PCS_LIST (
            plant_id, "PCS", "Revision", "Status", "RevDate",
            "RatingClass", "TestPressure", "MaterialGroup", "DesignCode",
            "LastUpdate", "LastUpdateBy", "Approver", "Notepad",
            "SpecialReqID", "TubePCS", "NewVDSSection"
        )
        SELECT
            p_plant_id,
            jt.PCS, jt.Revision, jt.Status, jt.RevDate,
            jt.RatingClass, jt.TestPressure, jt.MaterialGroup, jt.DesignCode,
            jt.LastUpdate, jt.LastUpdateBy, jt.Approver, jt.Notepad,
            jt.SpecialReqID, jt.TubePCS, jt.NewVDSSection
        FROM JSON_TABLE(v_json, '$.getPCS[*]'
                COLUMNS (
                    PCS VARCHAR2(100) PATH '$.PCS',
                    Revision VARCHAR2(50) PATH '$.Revision',
                    Status VARCHAR2(50) PATH '$.Status',
                    RevDate VARCHAR2(50) PATH '$.RevDate',
                    RatingClass VARCHAR2(100) PATH '$.RatingClass',
                    TestPressure VARCHAR2(50) PATH '$.TestPressure',
                    MaterialGroup VARCHAR2(100) PATH '$.MaterialGroup',
                    DesignCode VARCHAR2(100) PATH '$.DesignCode',
                    LastUpdate VARCHAR2(50) PATH '$.LastUpdate',
                    LastUpdateBy VARCHAR2(100) PATH '$.LastUpdateBy',
                    Approver VARCHAR2(100) PATH '$.Approver',
                    Notepad VARCHAR2(4000) PATH '$.Notepad',
                    SpecialReqID VARCHAR2(50) PATH '$.SpecialReqID',
                    TubePCS VARCHAR2(100) PATH '$.TubePCS',
                    NewVDSSection VARCHAR2(100) PATH '$.NewVDSSection'
                )
            ) jt;

        -- Step 4: Move from staging to core table with type conversion
        DELETE FROM PCS_LIST
        WHERE plant_id = p_plant_id;

        INSERT INTO PCS_LIST (
            pcs_list_guid, plant_id, pcs_name, revision, status, rev_date,
            rating_class, test_pressure, material_group, design_code,
            last_update, last_update_by, approver, notepad,
            special_req_id, tube_pcs, new_vds_section,
            created_date, last_modified_date
        )
        SELECT
            SYS_GUID(), plant_id, "PCS", "Revision", "Status",
            PKG_DATE_UTILS.safe_parse_date("RevDate"), "RatingClass",
            TO_NUMBER("TestPressure"), "MaterialGroup", "DesignCode",
            PKG_DATE_UTILS.safe_parse_date("LastUpdate"), "LastUpdateBy",
            "Approver", "Notepad", TO_NUMBER("SpecialReqID"),
            "TubePCS", "NewVDSSection", SYSDATE, SYSDATE
        FROM STG_PCS_LIST
        WHERE plant_id = p_plant_id
        AND "PCS" IS NOT NULL;

    EXCEPTION
        WHEN OTHERS THEN
            v_error_msg := 'Error in parse_and_load_pcs_list: ' || SQLERRM;
            PKG_ETL_LOGGING.log_error(
                p_endpoint_key => 'PCS_LIST',
                p_plant_id => p_plant_id,
                p_issue_revision => NULL,
                p_error_type => 'PROCESSING_ERROR',
                p_error_code => 'PCS_LIST_PARSE_ERROR',
                p_error_message => v_error_msg,
                p_raw_data => v_json
            );
            RAISE;
    END parse_and_load_pcs_list;

    -- =====================================================
    -- PARSE AND LOAD PCS DETAILS
    -- =====================================================
    PROCEDURE parse_and_load_pcs_details(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2,
        p_pcs_name IN VARCHAR2,
        p_revision IN VARCHAR2,
        p_detail_type IN VARCHAR2
    ) IS
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Delegate to PKG_PCS_DETAIL_PROCESSOR which already has implementations
        PKG_PCS_DETAIL_PROCESSOR.process_pcs_detail(
            p_raw_json_id => p_raw_json_id,
            p_plant_id => p_plant_id,
            p_pcs_name => p_pcs_name,
            p_revision => p_revision,
            p_detail_type => p_detail_type
        );
    EXCEPTION
        WHEN OTHERS THEN
            v_error_msg := 'Error in parse_and_load_pcs_details: ' || SQLERRM;
            PKG_ETL_LOGGING.log_error(
                p_endpoint_key => 'PCS_DETAIL_' || UPPER(p_detail_type),
                p_plant_id => p_plant_id,
                p_issue_revision => NULL,
                p_error_type => 'PROCESSING_ERROR',
                p_error_code => 'PCS_DETAILS_PARSE_ERROR',
                p_error_message => v_error_msg
            );
            RAISE;
    END parse_and_load_pcs_details;

    -- =====================================================
    -- PARSE AND LOAD VDS CATALOG
    -- =====================================================
    PROCEDURE parse_and_load_vds_catalog(
        p_raw_json_id IN NUMBER
    ) IS
        v_json CLOB;
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Step 1: Get JSON from RAW_JSON
        SELECT payload INTO v_json
        FROM RAW_JSON
        WHERE raw_json_id = p_raw_json_id;

        -- Step 2: Clear staging table
        DELETE FROM STG_VDS_LIST;

        -- Step 3: Parse JSON to staging table - FIXED PATH: $.getVDS[*]
        INSERT INTO STG_VDS_LIST (
            "VDS", "Revision", "Status", "RevDate", "LastUpdate",
            "LastUpdateBy", "Description", "Notepad", "SpecialReqID",
            "ValveTypeID", "RatingClassID", "MaterialGroupID",
            "EndConnectionID", "BoreID", "VDSSizeID",
            "SizeRange", "CustomName", "SubsegmentList"
        )
        SELECT
            jt.VDS, jt.Revision, jt.Status, jt.RevDate, jt.LastUpdate,
            jt.LastUpdateBy, jt.Description, jt.Notepad, jt.SpecialReqID,
            jt.ValveTypeID, jt.RatingClassID, jt.MaterialGroupID,
            jt.EndConnectionID, jt.BoreID, jt.VDSSizeID,
            jt.SizeRange, jt.CustomName, jt.SubsegmentList
        FROM JSON_TABLE(v_json, '$.getVDS[*]'
                COLUMNS (
                    VDS VARCHAR2(100) PATH '$.VDS',
                    Revision VARCHAR2(50) PATH '$.Revision',
                    Status VARCHAR2(50) PATH '$.Status',
                    RevDate VARCHAR2(50) PATH '$.RevDate',
                    LastUpdate VARCHAR2(50) PATH '$.LastUpdate',
                    LastUpdateBy VARCHAR2(100) PATH '$.LastUpdateBy',
                    Description VARCHAR2(500) PATH '$.Description',
                    Notepad VARCHAR2(4000) PATH '$.Notepad',
                    SpecialReqID VARCHAR2(50) PATH '$.SpecialReqID',
                    ValveTypeID VARCHAR2(50) PATH '$.ValveTypeID',
                    RatingClassID VARCHAR2(50) PATH '$.RatingClassID',
                    MaterialGroupID VARCHAR2(50) PATH '$.MaterialGroupID',
                    EndConnectionID VARCHAR2(50) PATH '$.EndConnectionID',
                    BoreID VARCHAR2(50) PATH '$.BoreID',
                    VDSSizeID VARCHAR2(50) PATH '$.VDSSizeID',
                    SizeRange VARCHAR2(100) PATH '$.SizeRange',
                    CustomName VARCHAR2(200) PATH '$.CustomName',
                    SubsegmentList VARCHAR2(500) PATH '$.SubsegmentList'
                )
            ) jt;

        -- Step 4: Move from staging to core table with type conversion
        DELETE FROM VDS_LIST;

        INSERT INTO VDS_LIST (
            vds_list_guid, vds_name, revision, status, rev_date,
            last_update, last_update_by, description, notepad,
            special_req_id, valve_type_id, rating_class_id,
            material_group_id, end_connection_id, bore_id,
            vds_size_id, size_range, custom_name, subsegment_list,
            created_date, last_modified_date
        )
        SELECT
            SYS_GUID(), "VDS", "Revision", "Status",
            PKG_DATE_UTILS.safe_parse_date("RevDate"),
            PKG_DATE_UTILS.safe_parse_date("LastUpdate"),
            "LastUpdateBy", "Description", "Notepad",
            TO_NUMBER("SpecialReqID"), TO_NUMBER("ValveTypeID"),
            TO_NUMBER("RatingClassID"), TO_NUMBER("MaterialGroupID"),
            TO_NUMBER("EndConnectionID"), TO_NUMBER("BoreID"),
            TO_NUMBER("VDSSizeID"), "SizeRange", "CustomName",
            "SubsegmentList", SYSDATE, SYSDATE
        FROM STG_VDS_LIST
        WHERE "VDS" IS NOT NULL;

    EXCEPTION
        WHEN OTHERS THEN
            v_error_msg := 'Error in parse_and_load_vds_catalog: ' || SQLERRM;
            PKG_ETL_LOGGING.log_error(
                p_endpoint_key => 'VDS_CATALOG',
                p_plant_id => NULL,
                p_issue_revision => NULL,
                p_error_type => 'PROCESSING_ERROR',
                p_error_code => 'VDS_CATALOG_PARSE_ERROR',
                p_error_message => v_error_msg,
                p_raw_data => v_json
            );
            RAISE;
    END parse_and_load_vds_catalog;

END PKG_ETL_PROCESSOR;
/


  CREATE OR REPLACE EDITIONABLE PACKAGE "TR2000_STAGING"."PKG_ETL_TEST_UTILS" AS
    -- Testing and development utilities package
    -- This package provides utilities for testing and development
    -- NOT for production use

    -- Clear all log tables (for testing)
    PROCEDURE clear_all_logs;

    -- Clear all data tables (for testing)
    PROCEDURE clear_all_data;

    -- Clear RAW_JSON table (for testing)
    PROCEDURE clear_raw_json;

    -- Complete reset for testing
    PROCEDURE reset_for_testing;

    -- Generate test data in ETL_FILTER
    PROCEDURE generate_test_filter;

    -- Show current ETL status
    PROCEDURE show_etl_status;

    -- Validate data integrity
    PROCEDURE validate_data_integrity;

    -- Quick test run (single plant/issue)
    PROCEDURE quick_test_run(
        p_plant_id VARCHAR2 DEFAULT '34',
        p_issue_revision VARCHAR2 DEFAULT '4.2'
    );

END PKG_ETL_TEST_UTILS;
CREATE OR REPLACE EDITIONABLE PACKAGE BODY "TR2000_STAGING"."PKG_ETL_TEST_UTILS" AS

    PROCEDURE clear_all_logs IS
    BEGIN
        DELETE FROM ETL_ERROR_LOG;
        DELETE FROM ETL_RUN_LOG;
        DELETE FROM ETL_STATISTICS;
        COMMIT;
    END;

    PROCEDURE clear_all_data IS
    BEGIN
        -- Clear core tables
        DELETE FROM PCS_REFERENCES;
        DELETE FROM VDS_REFERENCES;
        DELETE FROM MDS_REFERENCES;
        DELETE FROM EDS_REFERENCES;
        DELETE FROM VSK_REFERENCES;
        DELETE FROM ESK_REFERENCES;
        DELETE FROM PIPE_ELEMENT_REFERENCES;
        DELETE FROM SC_REFERENCES;
        DELETE FROM VSM_REFERENCES;
        DELETE FROM PCS_LIST;
        DELETE FROM PCS_HEADER_PROPERTIES;
        DELETE FROM PCS_TEMP_PRESSURES;
        DELETE FROM PCS_PIPE_SIZES;
        DELETE FROM PCS_PIPE_ELEMENTS;
        DELETE FROM PCS_VALVE_ELEMENTS;
        DELETE FROM PCS_EMBEDDED_NOTES;
        DELETE FROM VDS_LIST;

        -- Clear staging tables
        DELETE FROM STG_PCS_REFERENCES;
        DELETE FROM STG_VDS_REFERENCES;
        DELETE FROM STG_MDS_REFERENCES;
        DELETE FROM STG_EDS_REFERENCES;
        DELETE FROM STG_VSK_REFERENCES;
        DELETE FROM STG_ESK_REFERENCES;
        DELETE FROM STG_PIPE_ELEMENT_REFERENCES;
        DELETE FROM STG_SC_REFERENCES;
        DELETE FROM STG_VSM_REFERENCES;
        DELETE FROM STG_PCS_LIST;
        DELETE FROM STG_VDS_LIST;
        DELETE FROM STG_PCS_HEADER_PROPERTIES;
        DELETE FROM STG_PCS_TEMP_PRESSURES;
        DELETE FROM STG_PCS_PIPE_SIZES;
        DELETE FROM STG_PCS_PIPE_ELEMENTS;
        DELETE FROM STG_PCS_VALVE_ELEMENTS;
        DELETE FROM STG_PCS_EMBEDDED_NOTES;

        COMMIT;
    END;

    PROCEDURE clear_raw_json IS
    BEGIN
        DELETE FROM RAW_JSON;
        COMMIT;
    END;

    PROCEDURE reset_for_testing IS
    BEGIN
        clear_all_data;
        clear_all_logs;
        clear_raw_json;
    END;

    PROCEDURE generate_test_filter IS
    BEGIN
        DELETE FROM ETL_FILTER;
        INSERT INTO ETL_FILTER (plant_id, plant_name, issue_revision, added_by_user_id)
        VALUES ('34', 'GRANE', '4.2', 'TEST_USER');
        COMMIT;
    END;

    PROCEDURE show_etl_status IS
        v_count NUMBER;
    BEGIN
        DBMS_OUTPUT.PUT_LINE('=== ETL STATUS REPORT ===');

        SELECT COUNT(*) INTO v_count FROM ETL_FILTER;
        DBMS_OUTPUT.PUT_LINE('ETL_FILTER: ' || v_count);

        SELECT COUNT(*) INTO v_count FROM RAW_JSON;
        DBMS_OUTPUT.PUT_LINE('RAW_JSON: ' || v_count);

        SELECT COUNT(*) INTO v_count FROM PCS_REFERENCES;
        DBMS_OUTPUT.PUT_LINE('PCS_REFERENCES: ' || v_count);

        SELECT COUNT(*) INTO v_count FROM VDS_REFERENCES;
        DBMS_OUTPUT.PUT_LINE('VDS_REFERENCES: ' || v_count);

        -- Check if any staging tables have data
        SELECT COUNT(*) INTO v_count FROM STG_PCS_REFERENCES;
        IF v_count > 0 THEN
            DBMS_OUTPUT.PUT_LINE('WARNING: STG_PCS_REFERENCES has ' || v_count || ' records');
        END IF;

        DBMS_OUTPUT.PUT_LINE('========================');
    END;

    PROCEDURE validate_data_integrity IS
    BEGIN
        DBMS_OUTPUT.PUT_LINE('Data integrity check complete');
    END;

    PROCEDURE quick_test_run(
        p_plant_id VARCHAR2 DEFAULT '34',
        p_issue_revision VARCHAR2 DEFAULT '4.2'
    ) IS
    BEGIN
        reset_for_testing;
        DELETE FROM ETL_FILTER;
        INSERT INTO ETL_FILTER (plant_id, plant_name, issue_revision, added_by_user_id)
        VALUES (p_plant_id, 'TEST_PLANT', p_issue_revision, 'TEST_USER');
        COMMIT;
        show_etl_status;
    END;

END PKG_ETL_TEST_UTILS;
/


  CREATE OR REPLACE EDITIONABLE PACKAGE "TR2000_STAGING"."PKG_INDEPENDENT_ETL_CONTROL" AS

    -- Run VDS catalog ETL (completely independent process)
    PROCEDURE run_vds_catalog_etl;

    -- Clear VDS catalog data
    PROCEDURE clear_vds_catalog;

    -- Get VDS catalog statistics
    FUNCTION get_vds_catalog_stats RETURN VARCHAR2;

END PKG_INDEPENDENT_ETL_CONTROL;
CREATE OR REPLACE EDITIONABLE PACKAGE BODY "TR2000_STAGING"."PKG_INDEPENDENT_ETL_CONTROL" AS

    -- Clear VDS catalog data
    PROCEDURE clear_vds_catalog IS
        v_run_id NUMBER;
        v_count NUMBER;
    BEGIN
        v_run_id := PKG_ETL_LOGGING.get_current_run_id;

        DELETE FROM VDS_LIST;
        v_count := SQL%ROWCOUNT;

        PKG_ETL_LOGGING.log_clear_operation(
            p_run_id => NVL(v_run_id, 0),
            p_table_name => 'VDS_LIST',
            p_records_deleted => v_count
        );

        EXECUTE IMMEDIATE 'TRUNCATE TABLE STG_VDS_LIST';

        COMMIT;
    END clear_vds_catalog;

    -- Get VDS catalog statistics
    FUNCTION get_vds_catalog_stats RETURN VARCHAR2 IS
        v_count NUMBER;
        v_last_update DATE;
    BEGIN
        SELECT COUNT(*), MAX(last_modified_date)
        INTO v_count, v_last_update
        FROM VDS_LIST;

        RETURN 'VDS Catalog: ' || v_count || ' items, Last Update: ' ||
               NVL(TO_CHAR(v_last_update, 'YYYY-MM-DD HH24:MI:SS'), 'Never');
    END get_vds_catalog_stats;

    -- Run VDS catalog ETL
    PROCEDURE run_vds_catalog_etl IS
        v_run_id NUMBER;
        v_stat_id NUMBER;
        v_api_stat_id NUMBER;
        v_raw_json_id NUMBER;
        v_start_time TIMESTAMP;
        v_response_size NUMBER;
        v_records_count NUMBER;
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Start ETL run
        v_run_id := PKG_ETL_LOGGING.start_etl_run(
            p_run_type => 'VDS_CATALOG_ETL'
        );

        v_stat_id := PKG_ETL_LOGGING.log_operation_start(
            p_run_id => v_run_id,
            p_stat_type => 'PROCESSING',
            p_operation_name => 'VDS_CATALOG_FULL_LOAD'
        );

        BEGIN
            -- Clear existing VDS data
            clear_vds_catalog;

            -- Log API call start
            v_start_time := SYSTIMESTAMP;
            v_api_stat_id := PKG_ETL_LOGGING.log_operation_start(
                p_run_id => v_run_id,
                p_stat_type => 'API_CALL',
                p_endpoint_key => 'VDS_CATALOG',
                p_operation_name => 'fetch_vds_catalog'
            );

            -- Fetch VDS catalog from API
            v_raw_json_id := PKG_API_CLIENT.fetch_vds_catalog(
                p_batch_id => 'VDS_RUN_' || v_run_id
            );

            -- Get response size
            SELECT LENGTH(payload) INTO v_response_size
            FROM RAW_JSON WHERE raw_json_id = v_raw_json_id;

            -- Log API call success
            PKG_ETL_LOGGING.log_operation_end(
                p_stat_id => v_api_stat_id,
                p_status => 'SUCCESS',
                p_api_response_size => v_response_size,
                p_api_status_code => 200
            );

            -- Also log as quick API call for statistics
            PKG_ETL_LOGGING.log_api_call(
                p_run_id => v_run_id,
                p_endpoint_key => 'VDS_CATALOG',
                p_duration_ms => EXTRACT(SECOND FROM (SYSTIMESTAMP - v_start_time)) * 1000,
                p_response_size => v_response_size,
                p_status_code => 200,
                p_status => 'SUCCESS'
            );

            -- Parse and load VDS data
            v_start_time := SYSTIMESTAMP;
            v_api_stat_id := PKG_ETL_LOGGING.log_operation_start(
                p_run_id => v_run_id,
                p_stat_type => 'PROCESSING',
                p_endpoint_key => 'VDS_CATALOG',
                p_operation_name => 'parse_and_load_vds_catalog'
            );

            PKG_ETL_PROCESSOR.parse_and_load_vds_catalog(v_raw_json_id);

            -- Get record count
            SELECT COUNT(*) INTO v_records_count FROM VDS_LIST;

            PKG_ETL_LOGGING.log_operation_end(
                p_stat_id => v_api_stat_id,
                p_status => 'SUCCESS',
                p_records_processed => v_records_count,
                p_records_inserted => v_records_count
            );

            -- Log overall success
            PKG_ETL_LOGGING.log_operation_end(
                p_stat_id => v_stat_id,
                p_status => 'SUCCESS',
                p_records_processed => v_records_count,
                p_error_message => 'Successfully loaded ' || v_records_count || ' VDS items'
            );

            -- End run successfully
            PKG_ETL_LOGGING.end_etl_run(v_run_id, 'SUCCESS');

            -- Output summary
            DBMS_OUTPUT.PUT_LINE('VDS Catalog ETL completed successfully');
            DBMS_OUTPUT.PUT_LINE('Records loaded: ' || v_records_count);
            DBMS_OUTPUT.PUT_LINE('Response size: ' || ROUND(v_response_size/1024/1024, 2) || ' MB');

        EXCEPTION
            WHEN OTHERS THEN
                v_error_msg := SQLERRM;

                -- Log operation failures
                IF v_api_stat_id IS NOT NULL THEN
                    PKG_ETL_LOGGING.log_operation_end(
                        p_stat_id => v_api_stat_id,
                        p_status => 'FAILED',
                        p_error_message => v_error_msg
                    );
                END IF;

                PKG_ETL_LOGGING.log_operation_end(
                    p_stat_id => v_stat_id,
                    p_status => 'FAILED',
                    p_error_message => v_error_msg
                );

                -- Log error
                PKG_ETL_LOGGING.log_error(
                    p_endpoint_key => 'VDS_CATALOG',
                    p_error_type => 'VDS_ETL_ERROR',
                    p_error_message => v_error_msg,
                    p_error_stack => DBMS_UTILITY.FORMAT_ERROR_STACK
                );

                -- End run as failed
                PKG_ETL_LOGGING.end_etl_run(v_run_id, 'FAILED');

                DBMS_OUTPUT.PUT_LINE('VDS Catalog ETL failed: ' || v_error_msg);
                RAISE;
        END;
    END run_vds_catalog_etl;

END PKG_INDEPENDENT_ETL_CONTROL;
/


  CREATE OR REPLACE EDITIONABLE PACKAGE "TR2000_STAGING"."PKG_MAIN_ETL_CONTROL" AS

    -- Main ETL entry point (renamed from run_full_etl)
    PROCEDURE run_main_etl;

    -- Process all reference types for an issue
    PROCEDURE process_references_for_issue(
        p_plant_id VARCHAR2,
        p_issue_revision VARCHAR2
    );

    -- Process PCS list for a plant
    PROCEDURE process_pcs_list(
        p_plant_id VARCHAR2
    );

    -- Process PCS details
    PROCEDURE process_pcs_details;

END PKG_MAIN_ETL_CONTROL;
CREATE OR REPLACE EDITIONABLE PACKAGE BODY "TR2000_STAGING"."PKG_MAIN_ETL_CONTROL" AS

    PROCEDURE run_main_etl IS
        v_batch_id VARCHAR2(50);
        v_run_id NUMBER;
        v_error_msg VARCHAR2(4000);
    BEGIN
        v_batch_id := 'FULL_ETL_' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS');

        v_run_id := PKG_ETL_LOGGING.start_etl_run(
            p_run_type => 'FULL_ETL',
            p_initiated_by => USER
        );
        PKG_ETL_LOGGING.set_current_run_id(v_run_id);

        DBMS_OUTPUT.PUT_LINE('Starting full ETL run');
        DBMS_OUTPUT.PUT_LINE('Batch ID: ' || v_batch_id);
        DBMS_OUTPUT.PUT_LINE('Run ID: ' || v_run_id);

        -- CRITICAL FIX: Clear all data tables at start
        DBMS_OUTPUT.PUT_LINE('Clearing all data tables...');
        PKG_ETL_TEST_UTILS.clear_all_data();
        DBMS_OUTPUT.PUT_LINE('Data tables cleared');

        FOR rec IN (SELECT DISTINCT plant_id, issue_revision FROM ETL_FILTER) LOOP
            DBMS_OUTPUT.PUT_LINE('Processing references for Plant: ' || rec.plant_id || ', Issue: ' || rec.issue_revision);
            process_references_for_issue(rec.plant_id, rec.issue_revision);
        END LOOP;

        FOR rec IN (SELECT DISTINCT plant_id FROM ETL_FILTER) LOOP
            DBMS_OUTPUT.PUT_LINE('Processing PCS list for Plant: ' || rec.plant_id);
            process_pcs_list(rec.plant_id);
        END LOOP;

        DBMS_OUTPUT.PUT_LINE('Processing PCS details...');
        process_pcs_details;

        PKG_ETL_LOGGING.end_etl_run(
            p_run_id => v_run_id,
            p_status => 'SUCCESS'
        );

        DBMS_OUTPUT.PUT_LINE('Full ETL completed');

    EXCEPTION
        WHEN OTHERS THEN
            v_error_msg := SQLERRM;

            PKG_ETL_LOGGING.end_etl_run(
                p_run_id => v_run_id,
                p_status => 'FAILED'
            );

            PKG_ETL_LOGGING.log_error(
                p_endpoint_key => 'FULL_ETL',
                p_plant_id => NULL,
                p_issue_revision => NULL,
                p_error_type => 'ETL_ERROR',
                p_error_code => 'FULL_ETL_FAILED',
                p_error_message => v_error_msg
            );

            DBMS_OUTPUT.PUT_LINE('Full ETL failed: ' || v_error_msg);
            RAISE;
    END run_main_etl;

    PROCEDURE process_references_for_issue(
        p_plant_id VARCHAR2,
        p_issue_revision VARCHAR2
    ) IS
        v_batch_id VARCHAR2(50);
        v_count NUMBER := 0;
        v_raw_json_id NUMBER;
        v_records_processed NUMBER;
        v_run_id NUMBER;
        v_stat_id NUMBER;
    BEGIN
        v_batch_id := 'REF_' || p_plant_id || '_' || p_issue_revision || '_' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS');
        v_run_id := PKG_ETL_LOGGING.get_current_run_id;

        -- No need to DELETE - tables already cleared in run_main_etl

        FOR ref_type IN (
            SELECT 'PCS' as ref_type FROM dual UNION ALL
            SELECT 'VDS' FROM dual UNION ALL
            SELECT 'MDS' FROM dual UNION ALL
            SELECT 'EDS' FROM dual UNION ALL
            SELECT 'VSK' FROM dual UNION ALL
            SELECT 'ESK' FROM dual UNION ALL
            SELECT 'PIPE_ELEMENT' FROM dual UNION ALL
            SELECT 'SC' FROM dual UNION ALL
            SELECT 'VSM' FROM dual
        ) LOOP
            v_raw_json_id := PKG_API_CLIENT.fetch_reference_data(
                p_plant_id => p_plant_id,
                p_issue_revision => p_issue_revision,
                p_ref_type => ref_type.ref_type,
                p_batch_id => v_batch_id
            );

            v_count := v_count + 1;

            IF ref_type.ref_type = 'PCS' THEN
                PKG_ETL_PROCESSOR.parse_and_load_pcs_references(
                    p_raw_json_id => v_raw_json_id,
                    p_plant_id => p_plant_id,
                    p_issue_revision => p_issue_revision
                );
                SELECT COUNT(*) INTO v_records_processed FROM PCS_REFERENCES
                WHERE plant_id = p_plant_id AND issue_revision = p_issue_revision;

            ELSIF ref_type.ref_type = 'VDS' THEN
                PKG_ETL_PROCESSOR.parse_and_load_vds_references(
                    p_raw_json_id => v_raw_json_id,
                    p_plant_id => p_plant_id,
                    p_issue_revision => p_issue_revision
                );
                SELECT COUNT(*) INTO v_records_processed FROM VDS_REFERENCES
                WHERE plant_id = p_plant_id AND issue_revision = p_issue_revision;

            ELSIF ref_type.ref_type = 'MDS' THEN
                PKG_ETL_PROCESSOR.parse_and_load_mds_references(
                    p_raw_json_id => v_raw_json_id,
                    p_plant_id => p_plant_id,
                    p_issue_revision => p_issue_revision
                );
                SELECT COUNT(*) INTO v_records_processed FROM MDS_REFERENCES
                WHERE plant_id = p_plant_id AND issue_revision = p_issue_revision;

            ELSIF ref_type.ref_type = 'EDS' THEN
                PKG_ETL_PROCESSOR.parse_and_load_eds_references(
                    p_raw_json_id => v_raw_json_id,
                    p_plant_id => p_plant_id,
                    p_issue_revision => p_issue_revision
                );
                SELECT COUNT(*) INTO v_records_processed FROM EDS_REFERENCES
                WHERE plant_id = p_plant_id AND issue_revision = p_issue_revision;

            ELSIF ref_type.ref_type = 'VSK' THEN
                PKG_ETL_PROCESSOR.parse_and_load_vsk_references(
                    p_raw_json_id => v_raw_json_id,
                    p_plant_id => p_plant_id,
                    p_issue_revision => p_issue_revision
                );
                SELECT COUNT(*) INTO v_records_processed FROM VSK_REFERENCES
                WHERE plant_id = p_plant_id AND issue_revision = p_issue_revision;

            ELSIF ref_type.ref_type = 'ESK' THEN
                PKG_ETL_PROCESSOR.parse_and_load_esk_references(
                    p_raw_json_id => v_raw_json_id,
                    p_plant_id => p_plant_id,
                    p_issue_revision => p_issue_revision
                );
                SELECT COUNT(*) INTO v_records_processed FROM ESK_REFERENCES
                WHERE plant_id = p_plant_id AND issue_revision = p_issue_revision;

            ELSIF ref_type.ref_type = 'PIPE_ELEMENT' THEN
                PKG_ETL_PROCESSOR.parse_and_load_pipe_element_references(
                    p_raw_json_id => v_raw_json_id,
                    p_plant_id => p_plant_id,
                    p_issue_revision => p_issue_revision
                );
                SELECT COUNT(*) INTO v_records_processed FROM PIPE_ELEMENT_REFERENCES
                WHERE plant_id = p_plant_id AND issue_revision = p_issue_revision;

            ELSIF ref_type.ref_type = 'SC' THEN
                PKG_ETL_PROCESSOR.parse_and_load_sc_references(
                    p_raw_json_id => v_raw_json_id,
                    p_plant_id => p_plant_id,
                    p_issue_revision => p_issue_revision
                );
                SELECT COUNT(*) INTO v_records_processed FROM SC_REFERENCES
                WHERE plant_id = p_plant_id AND issue_revision = p_issue_revision;

            ELSIF ref_type.ref_type = 'VSM' THEN
                PKG_ETL_PROCESSOR.parse_and_load_vsm_references(
                    p_raw_json_id => v_raw_json_id,
                    p_plant_id => p_plant_id,
                    p_issue_revision => p_issue_revision
                );
                SELECT COUNT(*) INTO v_records_processed FROM VSM_REFERENCES
                WHERE plant_id = p_plant_id AND issue_revision = p_issue_revision;
            END IF;
        END LOOP;

        DBMS_OUTPUT.PUT_LINE('Processed ' || v_count || ' reference types');
        COMMIT;
    END process_references_for_issue;

    PROCEDURE process_pcs_list(
        p_plant_id VARCHAR2
    ) IS
        v_batch_id VARCHAR2(50);
        v_raw_json_id NUMBER;
        v_run_id NUMBER;
        v_stat_id NUMBER;
        v_records_count NUMBER;
    BEGIN
        v_batch_id := 'PCS_LIST_' || p_plant_id || '_' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS');
        v_run_id := PKG_ETL_LOGGING.get_current_run_id;

        v_raw_json_id := PKG_API_CLIENT.fetch_pcs_list(
            p_plant_id => p_plant_id,
            p_batch_id => v_batch_id
        );

        PKG_ETL_PROCESSOR.parse_and_load_pcs_list(
            p_raw_json_id => v_raw_json_id,
            p_plant_id => p_plant_id
        );

        DBMS_OUTPUT.PUT_LINE('PCS list processed');
        COMMIT;
    END process_pcs_list;

    PROCEDURE process_pcs_details IS
        v_batch_id VARCHAR2(50);
        v_count NUMBER := 0;
        v_max_pcs_details NUMBER;
        v_raw_json_id NUMBER;
        v_run_id NUMBER;
        v_stat_id NUMBER;
        v_base_url VARCHAR2(500);
    BEGIN
        SELECT setting_value INTO v_max_pcs_details
        FROM CONTROL_SETTINGS
        WHERE setting_key = 'MAX_PCS_DETAILS_PER_RUN';

        SELECT setting_value INTO v_base_url
        FROM CONTROL_SETTINGS
        WHERE setting_key = 'API_BASE_URL';

        DBMS_OUTPUT.PUT_LINE('Processing PCS details for OFFICIAL revisions only...');
        DBMS_OUTPUT.PUT_LINE('Max PCS details per run: ' || v_max_pcs_details);

        v_batch_id := 'PCS_DETAILS_' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS');
        v_run_id := PKG_ETL_LOGGING.get_current_run_id;

        -- CRITICAL FIX: Only process official revisions from PCS_REFERENCES
        FOR rec IN (
            SELECT DISTINCT
                r.plant_id,
                r.pcs_name,
                r.official_revision as revision  -- Use OFFICIAL_REVISION
            FROM PCS_REFERENCES r
            WHERE r.official_revision IS NOT NULL
            -- Ensure the official revision exists in PCS_LIST
            AND EXISTS (
                SELECT 1 FROM PCS_LIST l
                WHERE l.plant_id = r.plant_id
                  AND l.pcs_name = r.pcs_name
                  AND l.revision = r.official_revision
            )
            AND ROWNUM <= CASE
                WHEN v_max_pcs_details = 0 THEN 999999
                ELSE v_max_pcs_details
            END
        ) LOOP
            DBMS_OUTPUT.PUT_LINE('Processing PCS: ' || rec.pcs_name || ' Official Rev: ' || rec.revision);

            FOR detail_type IN (
                SELECT 'header-properties' as dtype FROM dual UNION ALL
                SELECT 'temp-pressures' FROM dual UNION ALL
                SELECT 'pipe-sizes' FROM dual UNION ALL
                SELECT 'pipe-elements' FROM dual UNION ALL
                SELECT 'valve-elements' FROM dual UNION ALL
                SELECT 'embedded-notes' FROM dual
            ) LOOP
                v_raw_json_id := PKG_API_CLIENT.fetch_pcs_detail(
                    p_plant_id => rec.plant_id,
                    p_pcs_name => rec.pcs_name,
                    p_revision => rec.revision,  -- Official revision
                    p_detail_type => detail_type.dtype,
                    p_batch_id => v_batch_id
                );

                PKG_PCS_DETAIL_PROCESSOR.process_pcs_detail(
                    p_raw_json_id => v_raw_json_id,
                    p_plant_id => rec.plant_id,
                    p_pcs_name => rec.pcs_name,
                    p_revision => rec.revision,  -- Official revision
                    p_detail_type => detail_type.dtype
                );
            END LOOP;

            v_count := v_count + 1;
        END LOOP;

        DBMS_OUTPUT.PUT_LINE('PCS details completed. Processed: ' || v_count || ' official PCS revisions');
        DBMS_OUTPUT.PUT_LINE('Total API calls: ' || (v_count * 6));
        COMMIT;
    END process_pcs_details;

END PKG_MAIN_ETL_CONTROL;
/


  CREATE OR REPLACE EDITIONABLE PACKAGE "TR2000_STAGING"."PKG_PCS_DETAIL_PROCESSOR" AS
    PROCEDURE process_pcs_detail(
        p_raw_json_id   IN NUMBER,
        p_plant_id      IN VARCHAR2,
        p_pcs_name      IN VARCHAR2,
        p_revision      IN VARCHAR2,
        p_detail_type   IN VARCHAR2
    );
END PKG_PCS_DETAIL_PROCESSOR;
CREATE OR REPLACE EDITIONABLE PACKAGE BODY "TR2000_STAGING"."PKG_PCS_DETAIL_PROCESSOR" AS

    PROCEDURE process_pcs_detail(
        p_raw_json_id   IN NUMBER,
        p_plant_id      IN VARCHAR2,
        p_pcs_name      IN VARCHAR2,
        p_revision      IN VARCHAR2,
        p_detail_type   IN VARCHAR2
    ) IS
        v_json CLOB;
        v_upper_type VARCHAR2(50);
        v_error_msg VARCHAR2(4000);
        v_error_code VARCHAR2(50);
    BEGIN
        -- API → RAW_JSON (get the JSON payload)
        SELECT payload INTO v_json
        FROM RAW_JSON
        WHERE raw_json_id = p_raw_json_id;

        v_upper_type := UPPER(REPLACE(p_detail_type, '-', '_'));

        -- Process based on detail type
        IF v_upper_type IN ('HEADER_PROPERTIES', 'PCS_HEADER_PROPERTIES', 'PCS_HEADER', 'HEADER') THEN
            -- ===== HEADER_PROPERTIES Handler =====
            -- RAW_JSON → STG_PCS_HEADER_PROPERTIES
            -- No DELETE needed - tables cleared at ETL start

            INSERT INTO STG_PCS_HEADER_PROPERTIES (
                plant_id, pcs_name, pcs_revision,
                "PCS", "Revision", "Status", "RevDate",
                "RatingClass", "TestPressure", "MaterialGroup", "DesignCode",
                "LastUpdate", "LastUpdateBy", "Approver", "Notepad",
                "SC", "VSM", "DesignCodeRevMark",
                "CorrAllowance", "CorrAllowanceRevMark",
                "LongWeldEff", "LongWeldEffRevMark",
                "WallThkTol", "WallThkTolRevMark",
                "ServiceRemark", "ServiceRemarkRevMark",
                "DesignPress01", "DesignPress02", "DesignPress03", "DesignPress04",
                "DesignPress05", "DesignPress06", "DesignPress07", "DesignPress08",
                "DesignPress09", "DesignPress10", "DesignPress11", "DesignPress12",
                "DesignPressRevMark",
                "DesignTemp01", "DesignTemp02", "DesignTemp03", "DesignTemp04",
                "DesignTemp05", "DesignTemp06", "DesignTemp07", "DesignTemp08",
                "DesignTemp09", "DesignTemp10", "DesignTemp11", "DesignTemp12",
                "DesignTempRevMark",
                "NoteIDCorrAllowance", "NoteIDServiceCode", "NoteIDWallThkTol",
                "NoteIDLongWeldEff", "NoteIDGeneralPCS", "NoteIDDesignCode",
                "NoteIDPressTempTable", "NoteIDPipeSizeWthTable",
                "PressElementChange", "TempElementChange",
                "MaterialGroupID", "SpecialReqID", "SpecialReq",
                "NewVDSSection", "TubePCS", "EDSMJMatrix", "MJReductionFactor"
            )
            SELECT
                p_plant_id, p_pcs_name, p_revision,
                jt.PCS, jt.Revision, jt.Status, jt.RevDate,
                jt.RatingClass, jt.TestPressure, jt.MaterialGroup, jt.DesignCode,
                jt.LastUpdate, jt.LastUpdateBy, jt.Approver, jt.Notepad,
                jt.SC, jt.VSM, jt.DesignCodeRevMark,
                jt.CorrAllowance, jt.CorrAllowanceRevMark,
                jt.LongWeldEff, jt.LongWeldEffRevMark,
                jt.WallThkTol, jt.WallThkTolRevMark,
                jt.ServiceRemark, jt.ServiceRemarkRevMark,
                jt.DesignPress01, jt.DesignPress02, jt.DesignPress03, jt.DesignPress04,
                jt.DesignPress05, jt.DesignPress06, jt.DesignPress07, jt.DesignPress08,
                jt.DesignPress09, jt.DesignPress10, jt.DesignPress11, jt.DesignPress12,
                jt.DesignPressRevMark,
                jt.DesignTemp01, jt.DesignTemp02, jt.DesignTemp03, jt.DesignTemp04,
                jt.DesignTemp05, jt.DesignTemp06, jt.DesignTemp07, jt.DesignTemp08,
                jt.DesignTemp09, jt.DesignTemp10, jt.DesignTemp11, jt.DesignTemp12,
                jt.DesignTempRevMark,
                jt.NoteIDCorrAllowance, jt.NoteIDServiceCode, jt.NoteIDWallThkTol,
                jt.NoteIDLongWeldEff, jt.NoteIDGeneralPCS, jt.NoteIDDesignCode,
                jt.NoteIDPressTempTable, jt.NoteIDPipeSizeWthTable,
                jt.PressElementChange, jt.TempElementChange,
                jt.MaterialGroupID, jt.SpecialReqID, jt.SpecialReq,
                jt.NewVDSSection, jt.TubePCS, jt.EDSMJMatrix, jt.MJReductionFactor
            FROM JSON_TABLE(v_json, '$.getPCS[*]'
                COLUMNS (
                    PCS VARCHAR2(100) PATH '$.PCS',
                    Revision VARCHAR2(50) PATH '$.Revision',
                    Status VARCHAR2(50) PATH '$.Status',
                    RevDate VARCHAR2(50) PATH '$.RevDate',
                    RatingClass VARCHAR2(100) PATH '$.RatingClass',
                    TestPressure VARCHAR2(50) PATH '$.TestPressure',
                    MaterialGroup VARCHAR2(100) PATH '$.MaterialGroup',
                    DesignCode VARCHAR2(100) PATH '$.DesignCode',
                    LastUpdate VARCHAR2(50) PATH '$.LastUpdate',
                    LastUpdateBy VARCHAR2(100) PATH '$.LastUpdateBy',
                    Approver VARCHAR2(100) PATH '$.Approver',
                    Notepad VARCHAR2(4000) PATH '$.Notepad',
                    SC VARCHAR2(100) PATH '$.SC',
                    VSM VARCHAR2(100) PATH '$.VSM',
                    DesignCodeRevMark VARCHAR2(50) PATH '$.DesignCodeRevMark',
                    CorrAllowance VARCHAR2(50) PATH '$.CorrAllowance',
                    CorrAllowanceRevMark VARCHAR2(50) PATH '$.CorrAllowanceRevMark',
                    LongWeldEff VARCHAR2(50) PATH '$.LongWeldEff',
                    LongWeldEffRevMark VARCHAR2(50) PATH '$.LongWeldEffRevMark',
                    WallThkTol VARCHAR2(50) PATH '$.WallThkTol',
                    WallThkTolRevMark VARCHAR2(50) PATH '$.WallThkTolRevMark',
                    ServiceRemark VARCHAR2(500) PATH '$.ServiceRemark',
                    ServiceRemarkRevMark VARCHAR2(50) PATH '$.ServiceRemarkRevMark',
                    DesignPress01 VARCHAR2(50) PATH '$.DesignPress01',
                    DesignPress02 VARCHAR2(50) PATH '$.DesignPress02',
                    DesignPress03 VARCHAR2(50) PATH '$.DesignPress03',
                    DesignPress04 VARCHAR2(50) PATH '$.DesignPress04',
                    DesignPress05 VARCHAR2(50) PATH '$.DesignPress05',
                    DesignPress06 VARCHAR2(50) PATH '$.DesignPress06',
                    DesignPress07 VARCHAR2(50) PATH '$.DesignPress07',
                    DesignPress08 VARCHAR2(50) PATH '$.DesignPress08',
                    DesignPress09 VARCHAR2(50) PATH '$.DesignPress09',
                    DesignPress10 VARCHAR2(50) PATH '$.DesignPress10',
                    DesignPress11 VARCHAR2(50) PATH '$.DesignPress11',
                    DesignPress12 VARCHAR2(50) PATH '$.DesignPress12',
                    DesignPressRevMark VARCHAR2(50) PATH '$.DesignPressRevMark',
                    DesignTemp01 VARCHAR2(50) PATH '$.DesignTemp01',
                    DesignTemp02 VARCHAR2(50) PATH '$.DesignTemp02',
                    DesignTemp03 VARCHAR2(50) PATH '$.DesignTemp03',
                    DesignTemp04 VARCHAR2(50) PATH '$.DesignTemp04',
                    DesignTemp05 VARCHAR2(50) PATH '$.DesignTemp05',
                    DesignTemp06 VARCHAR2(50) PATH '$.DesignTemp06',
                    DesignTemp07 VARCHAR2(50) PATH '$.DesignTemp07',
                    DesignTemp08 VARCHAR2(50) PATH '$.DesignTemp08',
                    DesignTemp09 VARCHAR2(50) PATH '$.DesignTemp09',
                    DesignTemp10 VARCHAR2(50) PATH '$.DesignTemp10',
                    DesignTemp11 VARCHAR2(50) PATH '$.DesignTemp11',
                    DesignTemp12 VARCHAR2(50) PATH '$.DesignTemp12',
                    DesignTempRevMark VARCHAR2(50) PATH '$.DesignTempRevMark',
                    NoteIDCorrAllowance VARCHAR2(50) PATH '$.NoteIDCorrAllowance',
                    NoteIDServiceCode VARCHAR2(50) PATH '$.NoteIDServiceCode',
                    NoteIDWallThkTol VARCHAR2(50) PATH '$.NoteIDWallThkTol',
                    NoteIDLongWeldEff VARCHAR2(50) PATH '$.NoteIDLongWeldEff',
                    NoteIDGeneralPCS VARCHAR2(50) PATH '$.NoteIDGeneralPCS',
                    NoteIDDesignCode VARCHAR2(50) PATH '$.NoteIDDesignCode',
                    NoteIDPressTempTable VARCHAR2(50) PATH '$.NoteIDPressTempTable',
                    NoteIDPipeSizeWthTable VARCHAR2(50) PATH '$.NoteIDPipeSizeWthTable',
                    PressElementChange VARCHAR2(50) PATH '$.PressElementChange',
                    TempElementChange VARCHAR2(50) PATH '$.TempElementChange',
                    MaterialGroupID VARCHAR2(50) PATH '$.MaterialGroupID',
                    SpecialReqID VARCHAR2(50) PATH '$.SpecialReqID',
                    SpecialReq VARCHAR2(500) PATH '$.SpecialReq',
                    NewVDSSection VARCHAR2(100) PATH '$.NewVDSSection',
                    TubePCS VARCHAR2(100) PATH '$.TubePCS',
                    EDSMJMatrix VARCHAR2(100) PATH '$.EDSMJMatrix',
                    MJReductionFactor VARCHAR2(50) PATH '$.MJReductionFactor'
                )) jt;

            -- STG_* → Core Table PCS_HEADER_PROPERTIES
            -- No DELETE needed - tables cleared at ETL start

            INSERT INTO PCS_HEADER_PROPERTIES (
                pcs_header_properties_guid, plant_id, pcs_name, pcs_revision,
                pcs, revision, status, rev_date,
                rating_class, test_pressure, material_group, design_code,
                last_update, last_update_by, approver, notepad,
                sc, vsm, design_code_rev_mark,
                corr_allowance, corr_allowance_rev_mark,
                long_weld_eff, long_weld_eff_rev_mark,
                wall_thk_tol, wall_thk_tol_rev_mark,
                service_remark, service_remark_rev_mark,
                design_press01, design_press02, design_press03, design_press04,
                design_press05, design_press06, design_press07, design_press08,
                design_press09, design_press10, design_press11, design_press12,
                design_press_rev_mark,
                design_temp01, design_temp02, design_temp03, design_temp04,
                design_temp05, design_temp06, design_temp07, design_temp08,
                design_temp09, design_temp10, design_temp11, design_temp12,
                design_temp_rev_mark,
                note_id_corr_allowance, note_id_service_code, note_id_wall_thk_tol,
                note_id_long_weld_eff, note_id_general_pcs, note_id_design_code,
                note_id_press_temp_table, note_id_pipe_size_wth_table,
                press_element_change, temp_element_change,
                material_group_id, special_req_id, special_req,
                new_vds_section, tube_pcs, eds_mj_matrix, mj_reduction_factor,
                created_date, last_modified_date
            )
            SELECT
                SYS_GUID(), plant_id, pcs_name, pcs_revision,
                "PCS", "Revision", "Status", PKG_DATE_UTILS.safe_parse_date("RevDate"),
                "RatingClass", safe_to_number("TestPressure"), "MaterialGroup", "DesignCode",
                PKG_DATE_UTILS.safe_parse_date("LastUpdate"), "LastUpdateBy", "Approver", "Notepad",
                "SC", "VSM", "DesignCodeRevMark",
                safe_to_number("CorrAllowance"), "CorrAllowanceRevMark",
                safe_to_number("LongWeldEff"), "LongWeldEffRevMark",
                "WallThkTol", "WallThkTolRevMark",
                "ServiceRemark", "ServiceRemarkRevMark",
                safe_to_number("DesignPress01"), safe_to_number("DesignPress02"),
                safe_to_number("DesignPress03"), safe_to_number("DesignPress04"),
                safe_to_number("DesignPress05"), safe_to_number("DesignPress06"),
                safe_to_number("DesignPress07"), safe_to_number("DesignPress08"),
                safe_to_number("DesignPress09"), safe_to_number("DesignPress10"),
                safe_to_number("DesignPress11"), safe_to_number("DesignPress12"),
                "DesignPressRevMark",
                safe_to_number("DesignTemp01"), safe_to_number("DesignTemp02"),
                safe_to_number("DesignTemp03"), safe_to_number("DesignTemp04"),
                safe_to_number("DesignTemp05"), safe_to_number("DesignTemp06"),
                safe_to_number("DesignTemp07"), safe_to_number("DesignTemp08"),
                safe_to_number("DesignTemp09"), safe_to_number("DesignTemp10"),
                safe_to_number("DesignTemp11"), safe_to_number("DesignTemp12"),
                "DesignTempRevMark",
                "NoteIDCorrAllowance", "NoteIDServiceCode", "NoteIDWallThkTol",
                "NoteIDLongWeldEff", "NoteIDGeneralPCS", "NoteIDDesignCode",
                "NoteIDPressTempTable", "NoteIDPipeSizeWthTable",
                "PressElementChange", "TempElementChange",
                safe_to_number("MaterialGroupID"), safe_to_number("SpecialReqID"), "SpecialReq",
                "NewVDSSection", "TubePCS", "EDSMJMatrix", safe_to_number("MJReductionFactor"),
                SYSDATE, SYSDATE
            FROM STG_PCS_HEADER_PROPERTIES
            WHERE plant_id = p_plant_id
              AND pcs_name = p_pcs_name
              AND pcs_revision = p_revision;  -- Include revision in WHERE

        ELSIF v_upper_type IN ('TEMP_PRESSURES', 'PCS_TEMP_PRESSURES', 'TEMP-PRESSURES') THEN
            -- ===== TEMP_PRESSURES Handler =====
            -- No DELETE needed - tables cleared at ETL start

            INSERT INTO STG_PCS_TEMP_PRESSURES (
                plant_id, pcs_name, pcs_revision,
                "Temperature", "Pressure"
            )
            SELECT
                p_plant_id, p_pcs_name, p_revision,
                jt.Temperature, jt.Pressure
            FROM JSON_TABLE(v_json, '$.getTempPressure[*]'
                COLUMNS (
                    Temperature VARCHAR2(50) PATH '$.Temperature',
                    Pressure VARCHAR2(50) PATH '$.Pressure'
                )) jt;

            -- STG_* → Core Table
            INSERT INTO PCS_TEMP_PRESSURES (
                pcs_temp_pressures_guid, plant_id, pcs_name, pcs_revision,
                temperature, pressure,
                created_date, last_modified_date
            )
            SELECT
                SYS_GUID(), plant_id, pcs_name, pcs_revision,
                TO_NUMBER("Temperature"), TO_NUMBER("Pressure"),
                SYSDATE, SYSDATE
            FROM STG_PCS_TEMP_PRESSURES
            WHERE plant_id = p_plant_id
              AND pcs_name = p_pcs_name
              AND pcs_revision = p_revision;

        ELSIF v_upper_type IN ('PIPE_SIZES', 'PCS_PIPE_SIZES', 'PIPE-SIZES') THEN
            -- ===== PIPE_SIZES Handler =====
            -- No DELETE needed - tables cleared at ETL start

            INSERT INTO STG_PCS_PIPE_SIZES (
                plant_id, pcs_name, pcs_revision,
                "PCS", "Revision",
                "NomSize", "OuterDiam", "WallThickness", "Schedule",
                "UnderTolerance", "CorrosionAllowance", "WeldingFactor",
                "DimElementChange", "ScheduleInMatrix"
            )
            SELECT
                p_plant_id, p_pcs_name, p_revision,
                json_pcs, json_revision,
                nom_size, outer_diam, wall_thickness, schedule,
                under_tolerance, corrosion_allowance, welding_factor,
                dim_element_change, schedule_in_matrix
            FROM JSON_TABLE(v_json, '$'
                COLUMNS (
                    json_pcs VARCHAR2(100) PATH '$.PCS',
                    json_revision VARCHAR2(50) PATH '$.Revision',
                    NESTED PATH '$.getPipeSize[*]'
                    COLUMNS (
                        nom_size VARCHAR2(50) PATH '$.NomSize',
                        outer_diam VARCHAR2(50) PATH '$.OuterDiam',
                        wall_thickness VARCHAR2(50) PATH '$.WallThickness',
                        schedule VARCHAR2(50) PATH '$.Schedule',
                        under_tolerance VARCHAR2(50) PATH '$.UnderTolerance',
                        corrosion_allowance VARCHAR2(50) PATH '$.CorrosionAllowance',
                        welding_factor VARCHAR2(50) PATH '$.WeldingFactor',
                        dim_element_change VARCHAR2(50) PATH '$.DimElementChange',
                        schedule_in_matrix VARCHAR2(50) PATH '$.ScheduleInMatrix'
                    )
                )) jt;

            -- STG_* → Core Table
            INSERT INTO PCS_PIPE_SIZES (
                pcs_pipe_sizes_guid, plant_id, pcs_name, pcs_revision,
                pcs, revision, nom_size, outer_diam, wall_thickness, schedule,
                under_tolerance, corrosion_allowance, welding_factor,
                dim_element_change, schedule_in_matrix,
                created_date, last_modified_date
            )
            SELECT
                SYS_GUID(), plant_id, pcs_name, pcs_revision,
                "PCS", "Revision", "NomSize",
                TO_NUMBER("OuterDiam"), TO_NUMBER("WallThickness"), "Schedule",
                TO_NUMBER("UnderTolerance"), TO_NUMBER("CorrosionAllowance"), TO_NUMBER("WeldingFactor"),
                "DimElementChange", "ScheduleInMatrix",
                SYSDATE, SYSDATE
            FROM STG_PCS_PIPE_SIZES
            WHERE plant_id = p_plant_id
              AND pcs_name = p_pcs_name
              AND pcs_revision = p_revision;

        ELSIF v_upper_type IN ('PIPE_ELEMENTS', 'PCS_PIPE_ELEMENTS', 'PIPE-ELEMENTS') THEN
            -- ===== PIPE_ELEMENTS Handler =====
            -- No DELETE needed - tables cleared at ETL start

            INSERT INTO STG_PCS_PIPE_ELEMENTS (
                plant_id, pcs_name, pcs_revision,
                "PCS", "Revision", "MaterialGroupID",
                "ElementGroupNo", "LineNo", "Element",
                "DimStandard", "FromSize", "ToSize",
                "ProductForm", "Material", "MDS",
                "EDS", "EDSRevision", "ESK",
                "Revmark", "Remark", "PageBreak",
                "ElementID", "FreeText", "NoteID",
                "NewDeletedLine", "InitialInfo", "InitialRevmark",
                "MDSVariant", "MDSRevision", "Area"
            )
            SELECT
                p_plant_id, p_pcs_name, p_revision,
                json_pcs, json_revision, material_group_id,
                element_group_no, line_no, element,
                dim_standard, from_size, to_size,
                product_form, material, mds,
                eds, eds_revision, esk,
                revmark, remark, page_break,
                element_id, free_text, note_id,
                new_deleted_line, initial_info, initial_revmark,
                mds_variant, mds_revision, area
            FROM JSON_TABLE(v_json, '$'
                COLUMNS (
                    json_pcs VARCHAR2(100) PATH '$.PCS',
                    json_revision VARCHAR2(50) PATH '$.Revision',
                    material_group_id VARCHAR2(50) PATH '$.MaterialGroupID',
                    NESTED PATH '$.getPipeElement[*]'
                    COLUMNS (
                        element_group_no VARCHAR2(50) PATH '$.ElementGroupNo',
                        line_no VARCHAR2(50) PATH '$.LineNo',
                        element VARCHAR2(200) PATH '$.Element',
                        dim_standard VARCHAR2(100) PATH '$.DimStandard',
                        from_size VARCHAR2(50) PATH '$.FromSize',
                        to_size VARCHAR2(50) PATH '$.ToSize',
                        product_form VARCHAR2(100) PATH '$.ProductForm',
                        material VARCHAR2(200) PATH '$.Material',
                        mds VARCHAR2(100) PATH '$.MDS',
                        eds VARCHAR2(100) PATH '$.EDS',
                        eds_revision VARCHAR2(50) PATH '$.EDSRevision',
                        esk VARCHAR2(100) PATH '$.ESK',
                        revmark VARCHAR2(50) PATH '$.Revmark',
                        remark VARCHAR2(4000) PATH '$.Remark',
                        page_break VARCHAR2(50) PATH '$.PageBreak',
                        element_id VARCHAR2(50) PATH '$.ElementID',
                        free_text VARCHAR2(500) PATH '$.FreeText',
                        note_id VARCHAR2(50) PATH '$.NoteID',
                        new_deleted_line VARCHAR2(50) PATH '$.NewDeletedLine',
                        initial_info VARCHAR2(4000) PATH '$.InitialInfo',
                        initial_revmark VARCHAR2(50) PATH '$.InitialRevmark',
                        mds_variant VARCHAR2(100) PATH '$.MDSVariant',
                        mds_revision VARCHAR2(50) PATH '$.MDSRevision',
                        area VARCHAR2(100) PATH '$.Area'
                    )
                )) jt;

            -- STG_* → Core Table
            INSERT INTO PCS_PIPE_ELEMENTS (
                pcs_pipe_elements_guid, plant_id, pcs_name, pcs_revision,
                pcs, revision, material_group_id,
                element_group_no, line_no, element,
                dim_standard, from_size, to_size,
                product_form, material, mds,
                eds, eds_revision, esk,
                revmark, remark, page_break,
                element_id, free_text, note_id,
                new_deleted_line, initial_info, initial_revmark,
                mds_variant, mds_revision, area,
                created_date, last_modified_date
            )
            SELECT
                SYS_GUID(), plant_id, pcs_name, pcs_revision,
                "PCS", "Revision", TO_NUMBER("MaterialGroupID"),
                TO_NUMBER("ElementGroupNo"), TO_NUMBER("LineNo"), "Element",
                "DimStandard", "FromSize", "ToSize",
                "ProductForm", "Material", "MDS",
                "EDS", "EDSRevision", "ESK",
                "Revmark", SUBSTR("Remark", 1, 500), "PageBreak",
                TO_NUMBER("ElementID"), "FreeText", "NoteID",  -- NOTE_ID stays VARCHAR2
                "NewDeletedLine", SUBSTR("InitialInfo", 1, 200), "InitialRevmark",
                "MDSVariant", "MDSRevision", "Area",
                SYSDATE, SYSDATE
            FROM STG_PCS_PIPE_ELEMENTS
            WHERE plant_id = p_plant_id
              AND pcs_name = p_pcs_name
              AND pcs_revision = p_revision;

        ELSIF v_upper_type IN ('VALVE_ELEMENTS', 'PCS_VALVE_ELEMENTS', 'VALVE-ELEMENTS') THEN
            -- ===== VALVE_ELEMENTS Handler =====
            -- No DELETE needed - tables cleared at ETL start

            INSERT INTO STG_PCS_VALVE_ELEMENTS (
                plant_id, pcs_name, pcs_revision,
                "ValveGroupNo", "LineNo", "ValveType",
                "VDS", "ValveDescription", "FromSize",
                "ToSize", "Revmark", "Remark",
                "PageBreak", "NoteID", "PreviousVDS",
                "NewDeletedLine", "InitialInfo", "InitialRevmark",
                "SizeRange", "Status", "Revision"
            )
            SELECT
                p_plant_id, p_pcs_name, p_revision,
                valve_group_no, line_no, valve_type,
                vds, valve_description, from_size,
                to_size, revmark, remark,
                page_break, note_id, previous_vds,
                new_deleted_line, initial_info, initial_revmark,
                size_range, status, revision
            FROM JSON_TABLE(v_json, '$.getValveElement[*]'
                COLUMNS (
                    valve_group_no VARCHAR2(50) PATH '$.ValveGroupNo',
                    line_no VARCHAR2(50) PATH '$.LineNo',
                    valve_type VARCHAR2(100) PATH '$.ValveType',
                    vds VARCHAR2(100) PATH '$.VDS',
                    valve_description VARCHAR2(4000) PATH '$.ValveDescription',
                    from_size VARCHAR2(50) PATH '$.FromSize',
                    to_size VARCHAR2(50) PATH '$.ToSize',
                    revmark VARCHAR2(50) PATH '$.Revmark',
                    remark VARCHAR2(4000) PATH '$.Remark',
                    page_break VARCHAR2(50) PATH '$.PageBreak',
                    note_id VARCHAR2(50) PATH '$.NoteID',
                    previous_vds VARCHAR2(100) PATH '$.PreviousVDS',
                    new_deleted_line VARCHAR2(50) PATH '$.NewDeletedLine',
                    initial_info VARCHAR2(4000) PATH '$.InitialInfo',
                    initial_revmark VARCHAR2(50) PATH '$.InitialRevmark',
                    size_range VARCHAR2(100) PATH '$.SizeRange',
                    status VARCHAR2(50) PATH '$.Status',
                    revision VARCHAR2(50) PATH '$.Revision'
                )) jt;

            -- STG_* → Core Table
            INSERT INTO PCS_VALVE_ELEMENTS (
                pcs_valve_elements_guid, plant_id, pcs_name, pcs_revision,
                valve_group_no, line_no, valve_type,
                vds, valve_description, from_size,
                to_size, revmark, remark,
                page_break, note_id, previous_vds,
                new_deleted_line, initial_info, initial_revmark,
                size_range, status, revision,
                created_date, last_modified_date
            )
            SELECT
                SYS_GUID(), plant_id, pcs_name, pcs_revision,
                TO_NUMBER("ValveGroupNo"), TO_NUMBER("LineNo"), "ValveType",
                "VDS", SUBSTR("ValveDescription", 1, 500), "FromSize",
                "ToSize", "Revmark", SUBSTR("Remark", 1, 500),
                "PageBreak", "NoteID", "PreviousVDS",  -- NOTE_ID stays VARCHAR2
                "NewDeletedLine", SUBSTR("InitialInfo", 1, 200), "InitialRevmark",
                "SizeRange", "Status", "Revision",
                SYSDATE, SYSDATE
            FROM STG_PCS_VALVE_ELEMENTS
            WHERE plant_id = p_plant_id
              AND pcs_name = p_pcs_name
              AND pcs_revision = p_revision;

        ELSIF v_upper_type IN ('EMBEDDED_NOTES', 'PCS_EMBEDDED_NOTES', 'EMBEDDED-NOTES') THEN
            -- ===== EMBEDDED_NOTES Handler =====
            -- No DELETE needed - tables cleared at ETL start

            INSERT INTO STG_PCS_EMBEDDED_NOTES (
                plant_id, pcs_name, pcs_revision,
                "PCSName", "Revision", "TextSectionID",
                "TextSectionDescription", "PageBreak", "HTMLCLOB"
            )
            SELECT
                p_plant_id, p_pcs_name, p_revision,
                pcs_name_json, revision, text_section_id,
                text_section_description, page_break, html_clob
            FROM JSON_TABLE(v_json, '$.getEmbeddedNotes[*]'
                COLUMNS (
                    pcs_name_json VARCHAR2(100) PATH '$.PCSName',
                    revision VARCHAR2(50) PATH '$.Revision',
                    text_section_id VARCHAR2(50) PATH '$.TextSectionID',
                    text_section_description VARCHAR2(500) PATH '$.TextSectionDescription',
                    page_break VARCHAR2(50) PATH '$.PageBreak',
                    html_clob CLOB PATH '$.HTMLCLOB'
                )) jt;

            -- STG_* → Core Table
            INSERT INTO PCS_EMBEDDED_NOTES (
                pcs_embedded_notes_guid, plant_id, pcs_name, pcs_revision,
                pcsname, revision, text_section_id,
                text_section_description, page_break, html_clob,
                created_date, last_modified_date
            )
            SELECT
                SYS_GUID(), plant_id, pcs_name, pcs_revision,
                "PCSName", "Revision", "TextSectionID",  -- TEXT_SECTION_ID stays VARCHAR2
                "TextSectionDescription", "PageBreak", "HTMLCLOB",
                SYSDATE, SYSDATE
            FROM STG_PCS_EMBEDDED_NOTES
            WHERE plant_id = p_plant_id
              AND pcs_name = p_pcs_name
              AND pcs_revision = p_revision;

        ELSE
            -- Unknown detail type
            RAISE_APPLICATION_ERROR(-20001, 'Unknown PCS detail type: ' || p_detail_type);
        END IF;

        COMMIT;

    EXCEPTION
        WHEN OTHERS THEN
            v_error_code := SQLCODE;
            v_error_msg := SQLERRM;
            ROLLBACK;

            -- Log error
            INSERT INTO ETL_ERROR_LOG (
                error_id, endpoint_key, plant_id,
                error_timestamp, error_type, error_code,
                error_message, raw_data
            ) VALUES (
                ETL_ERROR_SEQ.NEXTVAL,
                'PCS_' || v_upper_type,
                p_plant_id,
                SYSTIMESTAMP,
                'PROCESSING_ERROR',
                v_error_code,
                v_error_msg,
                SUBSTR(v_json, 1, 4000)
            );
            COMMIT;

            -- Re-raise the error
            RAISE;
    END process_pcs_detail;

END PKG_PCS_DETAIL_PROCESSOR;
/

-- =====================================================
-- PACKAGE BODIES
-- =====================================================

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "TR2000_STAGING"."PKG_API_CLIENT" AS

    -- Build endpoint URL from template
    FUNCTION build_endpoint_url(
        p_endpoint_key VARCHAR2,
        p_plant_id VARCHAR2 DEFAULT NULL,
        p_issue_revision VARCHAR2 DEFAULT NULL,
        p_pcs_name VARCHAR2 DEFAULT NULL,
        p_pcs_revision VARCHAR2 DEFAULT NULL
    ) RETURN VARCHAR2 IS
        v_url VARCHAR2(500);
        v_template VARCHAR2(500);
    BEGIN
        -- Get template from CONTROL_ENDPOINTS
        BEGIN
            SELECT endpoint_template INTO v_template
            FROM CONTROL_ENDPOINTS
            WHERE endpoint_key = p_endpoint_key;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                -- If not found, build manually for PCS details
                IF p_endpoint_key LIKE 'PCS_%' THEN
                    v_template := '/plants/{plant_id}/pcs/{pcs_name}/rev/{pcs_revision}';
                    IF p_endpoint_key = 'PCS_HEADER_PROPERTIES' THEN
                        v_template := v_template;  -- Base endpoint
                    ELSIF p_endpoint_key = 'PCS_TEMP_PRESSURES' THEN
                        v_template := v_template || '/temp-pressures';
                    ELSIF p_endpoint_key = 'PCS_PIPE_SIZES' THEN
                        v_template := v_template || '/pipe-sizes';
                    ELSIF p_endpoint_key = 'PCS_PIPE_ELEMENTS' THEN
                        v_template := v_template || '/pipe-elements';
                    ELSIF p_endpoint_key = 'PCS_VALVE_ELEMENTS' THEN
                        v_template := v_template || '/valve-elements';
                    ELSIF p_endpoint_key = 'PCS_EMBEDDED_NOTES' THEN
                        v_template := v_template || '/embedded-notes';
                    END IF;
                ELSE
                    RAISE_APPLICATION_ERROR(-20001, 'Endpoint key not found: ' || p_endpoint_key);
                END IF;
        END;

        -- Replace placeholders
        v_url := v_template;
        v_url := REPLACE(v_url, '{plant_id}', p_plant_id);
        v_url := REPLACE(v_url, '{issue_revision}', p_issue_revision);
        v_url := REPLACE(v_url, '{pcs_name}', p_pcs_name);
        v_url := REPLACE(v_url, '{pcs_revision}', p_pcs_revision);

        RETURN v_url;
    END build_endpoint_url;

    -- Fetch reference data (PCS, VDS, MDS, etc.) - API → RAW_JSON only
    FUNCTION fetch_reference_data(
        p_plant_id VARCHAR2,
        p_issue_revision VARCHAR2,
        p_ref_type VARCHAR2,
        p_batch_id VARCHAR2
    ) RETURN NUMBER IS
        v_path VARCHAR2(500);
        v_response CLOB;
        v_raw_json_id NUMBER;
        v_base_url VARCHAR2(500);
        v_endpoint_key VARCHAR2(100);
        v_url VARCHAR2(4000);
        v_template VARCHAR2(500);
        v_http_status PLS_INTEGER;
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Get base URL from configuration
        SELECT setting_value INTO v_base_url
        FROM CONTROL_SETTINGS
        WHERE setting_key = 'API_BASE_URL';

        -- Map reference type to endpoint key
        v_endpoint_key := UPPER(p_ref_type) || '_REFERENCES';

        -- Build actual path using template
        v_path := build_endpoint_url(
            p_endpoint_key => v_endpoint_key,
            p_plant_id => p_plant_id,
            p_issue_revision => p_issue_revision
        );

        -- Get template for logging
        v_template := build_endpoint_url(v_endpoint_key, '{plant_id}', '{issue_revision}');

        -- Construct full URL
        v_url := v_base_url || v_path;

        -- Make API call through API_SERVICE proxy
        BEGIN
            v_response := API_SERVICE.API_GATEWAY.get_clob(
                p_url => v_url,
                p_method => 'GET',
                p_body => NULL,
                p_headers => NULL,
                p_credential_static_id => NULL,
                p_status_code => v_http_status
            );
        EXCEPTION
            WHEN OTHERS THEN
                v_http_status := -1;
                v_error_msg := SUBSTR(SQLERRM, 1, 4000);
        END;

        -- Store in RAW_JSON only - no direct loading to core tables
        INSERT INTO RAW_JSON (
            raw_json_id,
            endpoint_key,
            endpoint_template,
            endpoint_value,
            payload,
            batch_id,
            api_call_timestamp,
            created_date,
            key_fingerprint
        ) VALUES (
            RAW_JSON_SEQ.NEXTVAL,
            v_endpoint_key,
            v_template,
            v_path,
            v_response,
            p_batch_id,
            SYSTIMESTAMP,
            SYSDATE,
            STANDARD_HASH(v_path || '|' || p_batch_id, 'SHA256')
        ) RETURNING raw_json_id INTO v_raw_json_id;

        -- Log error if HTTP status is not success
        IF v_http_status IS NULL OR v_http_status NOT BETWEEN 200 AND 299 THEN
            INSERT INTO ETL_ERROR_LOG (
                error_id,
                endpoint_key,
                plant_id,
                issue_revision,
                error_timestamp,
                error_type,
                error_code,
                error_message
            ) VALUES (
                ETL_ERROR_SEQ.NEXTVAL,
                v_endpoint_key,
                p_plant_id,
                p_issue_revision,
                SYSTIMESTAMP,
                'API_CALL_ERROR',
                TO_CHAR(v_http_status),
                'HTTP ' || NVL(TO_CHAR(v_http_status), 'NULL') || ' for ' || v_url ||
                CASE WHEN v_error_msg IS NOT NULL THEN CHR(10) || v_error_msg ELSE '' END
            );
            COMMIT;
        END IF;

        RETURN v_raw_json_id;

    EXCEPTION
        WHEN OTHERS THEN
            DECLARE
                v_error_code VARCHAR2(50) := TO_CHAR(SQLCODE);
                v_error_msg VARCHAR2(4000) := SUBSTR(SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE, 1, 4000);
            BEGIN
                INSERT INTO ETL_ERROR_LOG (
                    error_id,
                    endpoint_key,
                    plant_id,
                    issue_revision,
                    error_timestamp,
                    error_type,
                    error_code,
                    error_message
                ) VALUES (
                    ETL_ERROR_SEQ.NEXTVAL,
                    v_endpoint_key,
                    p_plant_id,
                    p_issue_revision,
                    SYSTIMESTAMP,
                    'UNEXPECTED_ERROR',
                    v_error_code,
                    v_error_msg
                );
                COMMIT;
            END;
            RETURN NULL;
    END fetch_reference_data;

    -- Fetch PCS list for a plant - API → RAW_JSON only
    FUNCTION fetch_pcs_list(
        p_plant_id VARCHAR2,
        p_batch_id VARCHAR2
    ) RETURN NUMBER IS
        v_path VARCHAR2(500);
        v_response CLOB;
        v_raw_json_id NUMBER;
        v_base_url VARCHAR2(500);
        v_url VARCHAR2(4000);
        v_http_status PLS_INTEGER;
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Get base URL from configuration
        SELECT setting_value INTO v_base_url
        FROM CONTROL_SETTINGS
        WHERE setting_key = 'API_BASE_URL';

        -- Build path
        v_path := build_endpoint_url(
            p_endpoint_key => 'PCS_LIST',
            p_plant_id => p_plant_id
        );

        -- Construct full URL
        v_url := v_base_url || v_path;

        -- Make API call through API_SERVICE proxy
        BEGIN
            v_response := API_SERVICE.API_GATEWAY.get_clob(
                p_url => v_url,
                p_method => 'GET',
                p_body => NULL,
                p_headers => NULL,
                p_credential_static_id => NULL,
                p_status_code => v_http_status
            );
        EXCEPTION
            WHEN OTHERS THEN
                v_http_status := -1;
                v_error_msg := SUBSTR(SQLERRM, 1, 4000);
        END;

        -- Store in RAW_JSON only - no direct loading to core tables
        INSERT INTO RAW_JSON (
            raw_json_id,
            endpoint_key,
            endpoint_template,
            endpoint_value,
            payload,
            batch_id,
            api_call_timestamp,
            created_date,
            key_fingerprint
        ) VALUES (
            RAW_JSON_SEQ.NEXTVAL,
            'PCS_LIST',
            '/plants/{plant_id}/pcs',
            v_path,
            v_response,
            p_batch_id,
            SYSTIMESTAMP,
            SYSDATE,
            STANDARD_HASH(v_path || '|' || p_batch_id, 'SHA256')
        ) RETURNING raw_json_id INTO v_raw_json_id;

        -- Log error if HTTP status is not success
        IF v_http_status IS NULL OR v_http_status NOT BETWEEN 200 AND 299 THEN
            INSERT INTO ETL_ERROR_LOG (
                error_id,
                endpoint_key,
                plant_id,
                error_timestamp,
                error_type,
                error_code,
                error_message
            ) VALUES (
                ETL_ERROR_SEQ.NEXTVAL,
                'PCS_LIST',
                p_plant_id,
                SYSTIMESTAMP,
                'API_CALL_ERROR',
                TO_CHAR(v_http_status),
                'HTTP ' || NVL(TO_CHAR(v_http_status), 'NULL') || ' for ' || v_url ||
                CASE WHEN v_error_msg IS NOT NULL THEN CHR(10) || v_error_msg ELSE '' END
            );
            COMMIT;
        END IF;

        RETURN v_raw_json_id;

    EXCEPTION
        WHEN OTHERS THEN
            DECLARE
                v_error_code VARCHAR2(50) := TO_CHAR(SQLCODE);
                v_error_msg VARCHAR2(4000) := SUBSTR(SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE, 1, 4000);
            BEGIN
                INSERT INTO ETL_ERROR_LOG (
                    error_id,
                    endpoint_key,
                    plant_id,
                    error_timestamp,
                    error_type,
                    error_code,
                    error_message
                ) VALUES (
                    ETL_ERROR_SEQ.NEXTVAL,
                    'PCS_LIST',
                    p_plant_id,
                    SYSTIMESTAMP,
                    'UNEXPECTED_ERROR',
                    v_error_code,
                    v_error_msg
                );
                COMMIT;
            END;
            RETURN NULL;
    END fetch_pcs_list;

    -- Fetch PCS detail - API → RAW_JSON only (called by PKG_MAIN_ETL_CONTROL)
    FUNCTION fetch_pcs_detail(
        p_plant_id VARCHAR2,
        p_pcs_name VARCHAR2,
        p_revision VARCHAR2,
        p_detail_type VARCHAR2,
        p_batch_id VARCHAR2
    ) RETURN NUMBER IS
        v_path VARCHAR2(500);
        v_response CLOB;
        v_raw_json_id NUMBER;
        v_base_url VARCHAR2(500);
        v_endpoint_key VARCHAR2(100);
        v_url VARCHAR2(4000);
        v_template VARCHAR2(500);
        v_http_status PLS_INTEGER;
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Get base URL from configuration
        SELECT setting_value INTO v_base_url
        FROM CONTROL_SETTINGS
        WHERE setting_key = 'API_BASE_URL';

        -- Map detail type to endpoint key
        v_endpoint_key := 'PCS_' || UPPER(REPLACE(p_detail_type, '-', '_'));

        -- Build actual path using template
        v_path := build_endpoint_url(
            p_endpoint_key => v_endpoint_key,
            p_plant_id => p_plant_id,
            p_pcs_name => p_pcs_name,
            p_pcs_revision => p_revision
        );

        -- Get template for logging
        v_template := build_endpoint_url(v_endpoint_key, '{plant_id}', NULL, '{pcs_name}', '{pcs_revision}');

        -- Construct full URL
        v_url := v_base_url || v_path;

        -- Make API call through API_SERVICE proxy
        BEGIN
            v_response := API_SERVICE.API_GATEWAY.get_clob(
                p_url => v_url,
                p_method => 'GET',
                p_body => NULL,
                p_headers => NULL,
                p_credential_static_id => NULL,
                p_status_code => v_http_status
            );
        EXCEPTION
            WHEN OTHERS THEN
                v_http_status := -1;
                v_error_msg := SUBSTR(SQLERRM, 1, 4000);
        END;

        -- Store in RAW_JSON only - PKG_PCS_DETAIL_PROCESSOR will handle STG_* → Core
        INSERT INTO RAW_JSON (
            raw_json_id,
            endpoint_key,
            endpoint_template,
            endpoint_value,
            payload,
            batch_id,
            api_call_timestamp,
            created_date,
            key_fingerprint
        ) VALUES (
            RAW_JSON_SEQ.NEXTVAL,
            v_endpoint_key,
            v_template,
            v_path,
            v_response,
            p_batch_id,
            SYSTIMESTAMP,
            SYSDATE,
            STANDARD_HASH(v_path || '|' || p_batch_id, 'SHA256')
        ) RETURNING raw_json_id INTO v_raw_json_id;

        -- Log error if HTTP status is not success
        IF v_http_status IS NULL OR v_http_status NOT BETWEEN 200 AND 299 THEN
            INSERT INTO ETL_ERROR_LOG (
                error_id,
                endpoint_key,
                plant_id,
                issue_revision,  -- Using issue_revision column for PCS name
                error_timestamp,
                error_type,
                error_code,
                error_message
            ) VALUES (
                ETL_ERROR_SEQ.NEXTVAL,
                v_endpoint_key,
                p_plant_id,
                p_pcs_name,  -- Store PCS name in issue_revision column
                SYSTIMESTAMP,
                'API_CALL_ERROR',
                TO_CHAR(v_http_status),
                'HTTP ' || NVL(TO_CHAR(v_http_status), 'NULL') || ' for ' || v_url ||
                CASE WHEN v_error_msg IS NOT NULL THEN CHR(10) || v_error_msg ELSE '' END
            );
            COMMIT;
        END IF;

        RETURN v_raw_json_id;

    EXCEPTION
        WHEN OTHERS THEN
            DECLARE
                v_error_code VARCHAR2(50) := TO_CHAR(SQLCODE);
                v_error_msg VARCHAR2(4000) := SUBSTR(SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE, 1, 4000);
            BEGIN
                INSERT INTO ETL_ERROR_LOG (
                    error_id,
                    endpoint_key,
                    plant_id,
                    issue_revision,  -- Using issue_revision column for PCS name
                    error_timestamp,
                    error_type,
                    error_code,
                    error_message
                ) VALUES (
                    ETL_ERROR_SEQ.NEXTVAL,
                    v_endpoint_key,
                    p_plant_id,
                    p_pcs_name,  -- Store PCS name in issue_revision column
                    SYSTIMESTAMP,
                    'UNEXPECTED_ERROR',
                    v_error_code,
                    v_error_msg
                );
                COMMIT;
            END;
            RETURN NULL;
    END fetch_pcs_detail;

    -- Fetch VDS catalog - API → RAW_JSON only
    FUNCTION fetch_vds_catalog(
        p_batch_id VARCHAR2
    ) RETURN NUMBER IS
        v_response CLOB;
        v_raw_json_id NUMBER;
        v_base_url VARCHAR2(500);
        v_url VARCHAR2(4000);
        v_http_status PLS_INTEGER;
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Get base URL from configuration
        SELECT setting_value INTO v_base_url
        FROM CONTROL_SETTINGS
        WHERE setting_key = 'API_BASE_URL';

        -- VDS catalog endpoint is simple
        v_url := v_base_url || '/vds';

        -- Make API call through API_SERVICE proxy
        BEGIN
            v_response := API_SERVICE.API_GATEWAY.get_clob(
                p_url => v_url,
                p_method => 'GET',
                p_body => NULL,
                p_headers => NULL,
                p_credential_static_id => NULL,
                p_status_code => v_http_status
            );
        EXCEPTION
            WHEN OTHERS THEN
                v_http_status := -1;
                v_error_msg := SUBSTR(SQLERRM, 1, 4000);
        END;

        -- Store in RAW_JSON only - no direct loading to core tables
        INSERT INTO RAW_JSON (
            raw_json_id,
            endpoint_key,
            endpoint_template,
            endpoint_value,
            payload,
            batch_id,
            api_call_timestamp,
            created_date,
            key_fingerprint
        ) VALUES (
            RAW_JSON_SEQ.NEXTVAL,
            'VDS_LIST',
            '/vds',
            '/vds',
            v_response,
            p_batch_id,
            SYSTIMESTAMP,
            SYSDATE,
            STANDARD_HASH('/vds|' || p_batch_id, 'SHA256')
        ) RETURNING raw_json_id INTO v_raw_json_id;

        -- Log error if HTTP status is not success
        IF v_http_status IS NULL OR v_http_status NOT BETWEEN 200 AND 299 THEN
            INSERT INTO ETL_ERROR_LOG (
                error_id,
                endpoint_key,
                error_timestamp,
                error_type,
                error_code,
                error_message
            ) VALUES (
                ETL_ERROR_SEQ.NEXTVAL,
                'VDS_LIST',
                SYSTIMESTAMP,
                'API_CALL_ERROR',
                TO_CHAR(v_http_status),
                'HTTP ' || NVL(TO_CHAR(v_http_status), 'NULL') || ' for ' || v_url ||
                CASE WHEN v_error_msg IS NOT NULL THEN CHR(10) || v_error_msg ELSE '' END
            );
            COMMIT;
        END IF;

        RETURN v_raw_json_id;

    EXCEPTION
        WHEN OTHERS THEN
            DECLARE
                v_error_code VARCHAR2(50) := TO_CHAR(SQLCODE);
                v_error_msg VARCHAR2(4000) := SUBSTR(SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE, 1, 4000);
            BEGIN
                INSERT INTO ETL_ERROR_LOG (
                    error_id,
                    endpoint_key,
                    error_timestamp,
                    error_type,
                    error_code,
                    error_message
                ) VALUES (
                    ETL_ERROR_SEQ.NEXTVAL,
                    'VDS_LIST',
                    SYSTIMESTAMP,
                    'UNEXPECTED_ERROR',
                    v_error_code,
                    v_error_msg
                );
                COMMIT;
            END;
            RETURN NULL;
    END fetch_vds_catalog;

END PKG_API_CLIENT;
/


  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "TR2000_STAGING"."PKG_DATE_UTILS" AS

    -- Parse date string with multiple format attempts
    FUNCTION parse_date(p_date_string IN VARCHAR2) RETURN DATE IS
        v_date DATE;
        v_clean_string VARCHAR2(100);
    BEGIN
        -- Return NULL for empty strings
        IF p_date_string IS NULL OR TRIM(p_date_string) IS NULL THEN
            RETURN NULL;
        END IF;

        -- Clean the string (remove extra spaces, normalize)
        v_clean_string := TRIM(p_date_string);

        -- Try various date formats in order of likelihood
        BEGIN
            -- Format 1: DD.MM.YYYY (European with dots - most common in TR2000)
            v_date := TO_DATE(v_clean_string, 'DD.MM.YYYY');
            RETURN v_date;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 2: DD/MM/YYYY (European with slashes)
            v_date := TO_DATE(v_clean_string, 'DD/MM/YYYY');
            RETURN v_date;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 3: DD-MM-YYYY (European with dashes)
            v_date := TO_DATE(v_clean_string, 'DD-MM-YYYY');
            RETURN v_date;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 4: YYYY-MM-DD (ISO format)
            v_date := TO_DATE(v_clean_string, 'YYYY-MM-DD');
            RETURN v_date;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 5: YYYY/MM/DD (ISO with slashes)
            v_date := TO_DATE(v_clean_string, 'YYYY/MM/DD');
            RETURN v_date;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 6: MM/DD/YYYY (US format)
            v_date := TO_DATE(v_clean_string, 'MM/DD/YYYY');
            RETURN v_date;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 7: MM-DD-YYYY (US with dashes)
            v_date := TO_DATE(v_clean_string, 'MM-DD-YYYY');
            RETURN v_date;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 8: DD.MM.YYYY HH24:MI:SS (European with time)
            v_date := TO_DATE(v_clean_string, 'DD.MM.YYYY HH24:MI:SS');
            RETURN v_date;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 9: YYYY-MM-DD HH24:MI:SS (ISO with time)
            v_date := TO_DATE(v_clean_string, 'YYYY-MM-DD HH24:MI:SS');
            RETURN v_date;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 10: DD/MM/YYYY HH24:MI:SS (European with time and slashes)
            v_date := TO_DATE(v_clean_string, 'DD/MM/YYYY HH24:MI:SS');
            RETURN v_date;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 11: YYYY-MM-DD"T"HH24:MI:SS (ISO 8601 with T separator)
            v_date := TO_DATE(v_clean_string, 'YYYY-MM-DD"T"HH24:MI:SS');
            RETURN v_date;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 12: DD-MON-YYYY (Oracle default)
            v_date := TO_DATE(v_clean_string, 'DD-MON-YYYY');
            RETURN v_date;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 13: DD-MON-YY (Oracle short year)
            v_date := TO_DATE(v_clean_string, 'DD-MON-YY');
            RETURN v_date;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 14: YYYYMMDD (Compact format)
            IF LENGTH(v_clean_string) = 8 AND REGEXP_LIKE(v_clean_string, '^\d{8}$') THEN
                v_date := TO_DATE(v_clean_string, 'YYYYMMDD');
                RETURN v_date;
            END IF;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 15: DD.MM.YY (European short year)
            v_date := TO_DATE(v_clean_string, 'DD.MM.YY');
            RETURN v_date;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        -- If we get here, none of the formats worked
        RAISE_APPLICATION_ERROR(-20901,
            'Unable to parse date string: ' || p_date_string ||
            '. Tried DD.MM.YYYY, DD/MM/YYYY, YYYY-MM-DD, MM/DD/YYYY and other formats.');

    END parse_date;

    -- Safe version that returns NULL instead of raising error
    FUNCTION safe_parse_date(p_date_string IN VARCHAR2) RETURN DATE IS
    BEGIN
        RETURN parse_date(p_date_string);
    EXCEPTION
        WHEN OTHERS THEN
            -- Log the parsing error but return NULL
            DBMS_OUTPUT.PUT_LINE('Warning: Could not parse date "' || p_date_string || '": ' || SQLERRM);
            RETURN NULL;
    END safe_parse_date;

    -- Parse timestamp string with multiple format attempts
    FUNCTION parse_timestamp(p_timestamp_string IN VARCHAR2) RETURN TIMESTAMP IS
        v_timestamp TIMESTAMP;
        v_clean_string VARCHAR2(100);
    BEGIN
        -- Return NULL for empty strings
        IF p_timestamp_string IS NULL OR TRIM(p_timestamp_string) IS NULL THEN
            RETURN NULL;
        END IF;

        -- Clean the string
        v_clean_string := TRIM(p_timestamp_string);

        -- Try various timestamp formats
        BEGIN
            -- Format 1: YYYY-MM-DD HH24:MI:SS.FF (ISO with fractional seconds)
            v_timestamp := TO_TIMESTAMP(v_clean_string, 'YYYY-MM-DD HH24:MI:SS.FF');
            RETURN v_timestamp;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 2: YYYY-MM-DD HH24:MI:SS (ISO without fractional seconds)
            v_timestamp := TO_TIMESTAMP(v_clean_string, 'YYYY-MM-DD HH24:MI:SS');
            RETURN v_timestamp;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 3: DD.MM.YYYY HH24:MI:SS.FF (European with fractional seconds)
            v_timestamp := TO_TIMESTAMP(v_clean_string, 'DD.MM.YYYY HH24:MI:SS.FF');
            RETURN v_timestamp;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 4: DD.MM.YYYY HH24:MI:SS (European without fractional seconds)
            v_timestamp := TO_TIMESTAMP(v_clean_string, 'DD.MM.YYYY HH24:MI:SS');
            RETURN v_timestamp;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 5: YYYY-MM-DD"T"HH24:MI:SS.FF"Z" (ISO 8601 with timezone)
            v_timestamp := TO_TIMESTAMP(REPLACE(REPLACE(v_clean_string, 'T', ' '), 'Z', ''),
                                        'YYYY-MM-DD HH24:MI:SS.FF');
            RETURN v_timestamp;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 6: YYYY-MM-DD"T"HH24:MI:SS (ISO 8601 without fractional seconds)
            v_timestamp := TO_TIMESTAMP(v_clean_string, 'YYYY-MM-DD"T"HH24:MI:SS');
            RETURN v_timestamp;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 7: MM/DD/YYYY HH24:MI:SS (US format)
            v_timestamp := TO_TIMESTAMP(v_clean_string, 'MM/DD/YYYY HH24:MI:SS');
            RETURN v_timestamp;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        BEGIN
            -- Format 8: Just try as a date if no time component detected
            IF NOT REGEXP_LIKE(v_clean_string, '\d{1,2}:\d{2}') THEN
                v_timestamp := CAST(parse_date(v_clean_string) AS TIMESTAMP);
                RETURN v_timestamp;
            END IF;
        EXCEPTION
            WHEN OTHERS THEN NULL;
        END;

        -- If we get here, none of the formats worked
        RAISE_APPLICATION_ERROR(-20902,
            'Unable to parse timestamp string: ' || p_timestamp_string);

    END parse_timestamp;

    -- Safe version for timestamps
    FUNCTION safe_parse_timestamp(p_timestamp_string IN VARCHAR2) RETURN TIMESTAMP IS
    BEGIN
        RETURN parse_timestamp(p_timestamp_string);
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('Warning: Could not parse timestamp "' || p_timestamp_string || '": ' || SQLERRM);
            RETURN NULL;
    END safe_parse_timestamp;

END PKG_DATE_UTILS;
/


  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "TR2000_STAGING"."PKG_DDL_BACKUP" AS

    -- Main backup procedure with fixed LOB handling
    PROCEDURE backup_schema(
        p_schema_name VARCHAR2 DEFAULT USER,
        p_notes VARCHAR2 DEFAULT NULL,
        p_include_control_data BOOLEAN DEFAULT TRUE
    ) IS
        v_ddl_content CLOB;
        v_object_count NUMBER := 0;
        v_view_count NUMBER := 0;
        v_package_count NUMBER := 0;
        v_table_count NUMBER := 0;
        v_sequence_count NUMBER := 0;
        v_trigger_count NUMBER := 0;
        v_ddl_backup_id NUMBER;
        v_start_time TIMESTAMP := SYSTIMESTAMP;
        v_end_time TIMESTAMP;
        v_duration_seconds NUMBER;
        v_hash VARCHAR2(64);
        v_temp_ddl CLOB;
        v_ddl_size NUMBER := 0;  -- Store size before freeing LOB

        CURSOR c_objects IS
            SELECT object_type, object_name
            FROM user_objects
            WHERE object_type IN ('TABLE', 'VIEW', 'PACKAGE', 'PACKAGE BODY',
                                  'PROCEDURE', 'FUNCTION', 'SEQUENCE', 'TRIGGER',
                                  'SYNONYM', 'TYPE', 'TYPE BODY', 'INDEX')
            AND object_name NOT LIKE 'BIN$%'
            AND object_name NOT IN ('DDL_BACKUP', 'CONTROL_DATA_BACKUP')
            AND object_name NOT LIKE 'SYS_%'
            AND object_name NOT LIKE 'ISEQ$$%'
            ORDER BY
                DECODE(object_type,
                       'TABLE', 1,
                       'SEQUENCE', 2,
                       'TYPE', 3,
                       'TYPE BODY', 4,
                       'FUNCTION', 5,
                       'PROCEDURE', 6,
                       'PACKAGE', 7,
                       'PACKAGE BODY', 8,
                       'VIEW', 9,
                       'TRIGGER', 10,
                       'INDEX', 11,
                       'SYNONYM', 12,
                       99),
                object_name;
    BEGIN
        DBMS_OUTPUT.PUT_LINE('Starting full DDL backup for schema: ' || p_schema_name);
        DBMS_OUTPUT.PUT_LINE('This will extract actual DDL for all objects...');

        -- Initialize DDL content
        DBMS_LOB.CREATETEMPORARY(v_ddl_content, TRUE);
        DBMS_LOB.APPEND(v_ddl_content,
            '-- Full DDL Backup for schema: ' || p_schema_name || CHR(10) ||
            '-- Generated: ' || TO_CHAR(SYSTIMESTAMP, 'YYYY-MM-DD HH24:MI:SS.FF TZH:TZM') || CHR(10) ||
            '-- Notes: ' || NVL(p_notes, 'No notes provided') || CHR(10) ||
            '-- WARNING: Execute this script carefully!' || CHR(10) || CHR(10)
        );

        -- Set DBMS_METADATA parameters
        DBMS_METADATA.SET_TRANSFORM_PARAM(DBMS_METADATA.SESSION_TRANSFORM, 'SQLTERMINATOR', TRUE);
        DBMS_METADATA.SET_TRANSFORM_PARAM(DBMS_METADATA.SESSION_TRANSFORM, 'PRETTY', TRUE);
        DBMS_METADATA.SET_TRANSFORM_PARAM(DBMS_METADATA.SESSION_TRANSFORM, 'SEGMENT_ATTRIBUTES', TRUE);
        DBMS_METADATA.SET_TRANSFORM_PARAM(DBMS_METADATA.SESSION_TRANSFORM, 'STORAGE', FALSE);

        -- Extract DDL for each object
        FOR obj IN c_objects LOOP
            BEGIN
                -- Skip backup tables and certain object types
                IF obj.object_name IN ('DDL_BACKUP', 'CONTROL_DATA_BACKUP') THEN
                    CONTINUE;
                END IF;

                IF obj.object_type = 'PACKAGE BODY' THEN
                    CONTINUE;  -- Will be included with PACKAGE
                END IF;

                IF obj.object_type = 'INDEX' THEN
                    -- Skip constraint-based indexes
                    DECLARE
                        v_constraint_type VARCHAR2(1);
                    BEGIN
                        SELECT constraint_type INTO v_constraint_type
                        FROM user_constraints
                        WHERE constraint_name = obj.object_name
                        AND constraint_type IN ('P', 'U');
                        CONTINUE;
                    EXCEPTION
                        WHEN NO_DATA_FOUND THEN
                            NULL; -- Not a constraint index
                    END;
                END IF;

                -- Extract DDL (simplified to avoid errors)
                BEGIN
                    DBMS_LOB.APPEND(v_ddl_content,
                        CHR(10) || '-- ' || obj.object_type || ': ' || obj.object_name || CHR(10));

                    -- Count object types
                    IF obj.object_type = 'TABLE' THEN
                        v_table_count := v_table_count + 1;
                    ELSIF obj.object_type = 'VIEW' THEN
                        v_view_count := v_view_count + 1;
                    ELSIF obj.object_type = 'PACKAGE' THEN
                        v_package_count := v_package_count + 1;
                    ELSIF obj.object_type = 'SEQUENCE' THEN
                        v_sequence_count := v_sequence_count + 1;
                    ELSIF obj.object_type = 'TRIGGER' THEN
                        v_trigger_count := v_trigger_count + 1;
                    END IF;

                    -- Try to extract DDL
                    BEGIN
                        DBMS_LOB.CREATETEMPORARY(v_temp_ddl, TRUE);

                        IF obj.object_type IN ('TABLE', 'VIEW', 'SEQUENCE', 'PROCEDURE', 'FUNCTION', 'TRIGGER', 'SYNONYM') THEN
                            v_temp_ddl := DBMS_METADATA.GET_DDL(obj.object_type, obj.object_name, p_schema_name);
                        ELSIF obj.object_type = 'PACKAGE' THEN
                            v_temp_ddl := DBMS_METADATA.GET_DDL('PACKAGE', obj.object_name, p_schema_name);
                            -- Try to get body
                            BEGIN
                                DBMS_LOB.APPEND(v_temp_ddl, CHR(10) || '/' || CHR(10));
                                DBMS_LOB.APPEND(v_temp_ddl,
                                    DBMS_METADATA.GET_DDL('PACKAGE_BODY', obj.object_name, p_schema_name));
                            EXCEPTION
                                WHEN OTHERS THEN
                                    NULL;
                            END;
                        ELSIF obj.object_type = 'TYPE' THEN
                            v_temp_ddl := DBMS_METADATA.GET_DDL('TYPE', obj.object_name, p_schema_name);
                            -- Try to get body
                            BEGIN
                                DBMS_LOB.APPEND(v_temp_ddl, CHR(10) || '/' || CHR(10));
                                DBMS_LOB.APPEND(v_temp_ddl,
                                    DBMS_METADATA.GET_DDL('TYPE_BODY', obj.object_name, p_schema_name));
                            EXCEPTION
                                WHEN OTHERS THEN
                                    NULL;
                            END;
                        END IF;

                        -- Append to main DDL
                        IF DBMS_LOB.GETLENGTH(v_temp_ddl) > 0 THEN
                            DBMS_LOB.APPEND(v_ddl_content, v_temp_ddl);
                            DBMS_LOB.APPEND(v_ddl_content, CHR(10) || '/' || CHR(10));
                        END IF;

                        DBMS_LOB.FREETEMPORARY(v_temp_ddl);

                    EXCEPTION
                        WHEN OTHERS THEN
                            -- Log but continue
                            DBMS_LOB.APPEND(v_ddl_content,
                                '-- Error extracting DDL: ' || SUBSTR(SQLERRM, 1, 200) || CHR(10));
                            IF DBMS_LOB.ISTEMPORARY(v_temp_ddl) = 1 THEN
                                DBMS_LOB.FREETEMPORARY(v_temp_ddl);
                            END IF;
                    END;

                    v_object_count := v_object_count + 1;

                    IF MOD(v_object_count, 10) = 0 THEN
                        DBMS_OUTPUT.PUT_LINE('  Processed ' || v_object_count || ' objects...');
                    END IF;

                EXCEPTION
                    WHEN OTHERS THEN
                        DBMS_OUTPUT.PUT_LINE('  Warning: Error processing ' || obj.object_type ||
                                           ' ' || obj.object_name || ': ' || SUBSTR(SQLERRM, 1, 100));
                END;
            END;
        END LOOP;

        -- Add footer
        DBMS_LOB.APPEND(v_ddl_content, CHR(10) || CHR(10) ||
            '-- ============================================' || CHR(10) ||
            '-- End of DDL Backup' || CHR(10) ||
            '-- Total Objects: ' || v_object_count || CHR(10) ||
            '-- ============================================' || CHR(10));

        -- Calculate values BEFORE insert
        v_end_time := SYSTIMESTAMP;
        v_duration_seconds := EXTRACT(SECOND FROM (v_end_time - v_start_time)) +
                             EXTRACT(MINUTE FROM (v_end_time - v_start_time)) * 60 +
                             EXTRACT(HOUR FROM (v_end_time - v_start_time)) * 3600;

        v_ddl_size := DBMS_LOB.GETLENGTH(v_ddl_content);
        v_hash := 'SIZE:' || v_ddl_size || ':COUNT:' || v_object_count;

        -- Get sequence value
        SELECT DDL_BACKUP_SEQ.NEXTVAL INTO v_ddl_backup_id FROM DUAL;

        -- Insert into backup table
        INSERT INTO DDL_BACKUP_OWNER.DDL_BACKUP (
            backup_id,
            backup_timestamp,
            schema_name,
            backup_type,
            object_count,
            view_count,
            package_count,
            table_count,
            sequence_count,
            trigger_count,
            ddl_content,
            ddl_size_bytes,
            ddl_hash,
            backup_notes,
            backup_user,
            os_user,
            ip_address,
            program,
            duration_seconds
        ) VALUES (
            v_ddl_backup_id,
            v_start_time,
            p_schema_name,
            'FULL_SCHEMA_DDL',
            v_object_count,
            v_view_count,
            v_package_count,
            v_table_count,
            v_sequence_count,
            v_trigger_count,
            v_ddl_content,
            v_ddl_size,
            v_hash,
            p_notes,
            USER,
            SYS_CONTEXT('USERENV', 'OS_USER'),
            SYS_CONTEXT('USERENV', 'IP_ADDRESS'),
            SYS_CONTEXT('USERENV', 'MODULE'),
            v_duration_seconds
        );

        -- Backup control data if requested
        IF p_include_control_data THEN
            backup_control_data(
                p_schema_name => p_schema_name,
                p_notes => p_notes,
                p_ddl_backup_id => v_ddl_backup_id
            );
        END IF;

        COMMIT;

        -- Cleanup AFTER commit
        DBMS_LOB.FREETEMPORARY(v_ddl_content);

        DBMS_OUTPUT.PUT_LINE('');
        DBMS_OUTPUT.PUT_LINE('===== Backup Completed Successfully! =====');
        DBMS_OUTPUT.PUT_LINE('Backup ID: ' || v_ddl_backup_id);
        DBMS_OUTPUT.PUT_LINE('Total objects backed up: ' || v_object_count);
        DBMS_OUTPUT.PUT_LINE('  Tables: ' || v_table_count);
        DBMS_OUTPUT.PUT_LINE('  Views: ' || v_view_count);
        DBMS_OUTPUT.PUT_LINE('  Packages: ' || v_package_count);
        DBMS_OUTPUT.PUT_LINE('  Sequences: ' || v_sequence_count);
        DBMS_OUTPUT.PUT_LINE('  Triggers: ' || v_trigger_count);
        DBMS_OUTPUT.PUT_LINE('DDL Size: ' || ROUND(v_ddl_size/1024) || ' KB');
        DBMS_OUTPUT.PUT_LINE('Duration: ' || ROUND(v_duration_seconds, 2) || ' seconds');
        DBMS_OUTPUT.PUT_LINE('==========================================');

    EXCEPTION
        WHEN OTHERS THEN
            IF DBMS_LOB.ISTEMPORARY(v_ddl_content) = 1 THEN
                DBMS_LOB.FREETEMPORARY(v_ddl_content);
            END IF;
            DBMS_OUTPUT.PUT_LINE('BACKUP FAILED: ' || SQLERRM);
            RAISE_APPLICATION_ERROR(-20001, 'Backup failed: ' || SQLERRM);
    END backup_schema;

    -- Keep all other procedures unchanged
    PROCEDURE backup_control_data(
        p_schema_name VARCHAR2 DEFAULT USER,
        p_notes VARCHAR2 DEFAULT NULL,
        p_ddl_backup_id NUMBER DEFAULT NULL
    ) IS
        v_control_settings_json CLOB;
        v_control_endpoints_json CLOB;
        v_etl_filter_json CLOB;
        v_settings_count NUMBER := 0;
        v_endpoints_count NUMBER := 0;
        v_filter_count NUMBER := 0;
        v_backup_id NUMBER;
    BEGIN
        -- Initialize CLOBs
        DBMS_LOB.CREATETEMPORARY(v_control_settings_json, TRUE);
        DBMS_LOB.CREATETEMPORARY(v_control_endpoints_json, TRUE);
        DBMS_LOB.CREATETEMPORARY(v_etl_filter_json, TRUE);

        -- Build JSON for CONTROL_SETTINGS
        DBMS_LOB.APPEND(v_control_settings_json, '[');
        FOR rec IN (SELECT setting_key, setting_value, description
                   FROM CONTROL_SETTINGS ORDER BY setting_key) LOOP
            IF v_settings_count > 0 THEN
                DBMS_LOB.APPEND(v_control_settings_json, ',');
            END IF;
            DBMS_LOB.APPEND(v_control_settings_json,
                '{"setting_key":"' || rec.setting_key ||
                '","setting_value":"' || REPLACE(rec.setting_value, '"', '\"') ||
                '","description":"' || REPLACE(NVL(rec.description, ''), '"', '\"') || '"}');
            v_settings_count := v_settings_count + 1;
        END LOOP;
        DBMS_LOB.APPEND(v_control_settings_json, ']');

        -- Build JSON for CONTROL_ENDPOINTS
        DBMS_LOB.APPEND(v_control_endpoints_json, '[');
        FOR rec IN (SELECT endpoint_id, endpoint_key, endpoint_template, comments
                   FROM CONTROL_ENDPOINTS ORDER BY endpoint_id) LOOP
            IF v_endpoints_count > 0 THEN
                DBMS_LOB.APPEND(v_control_endpoints_json, ',');
            END IF;
            DBMS_LOB.APPEND(v_control_endpoints_json,
                '{"endpoint_id":' || rec.endpoint_id ||
                ',"endpoint_key":"' || rec.endpoint_key ||
                '","endpoint_template":"' || REPLACE(rec.endpoint_template, '"', '\"') ||
                '","comments":"' || REPLACE(NVL(rec.comments, ''), '"', '\"') || '"}');
            v_endpoints_count := v_endpoints_count + 1;
        END LOOP;
        DBMS_LOB.APPEND(v_control_endpoints_json, ']');

        -- Build JSON for ETL_FILTER
        DBMS_LOB.APPEND(v_etl_filter_json, '[');
        FOR rec IN (SELECT filter_id, plant_id, plant_name, issue_revision,
                          added_date, added_by_user_id, notes
                   FROM ETL_FILTER ORDER BY filter_id) LOOP
            IF v_filter_count > 0 THEN
                DBMS_LOB.APPEND(v_etl_filter_json, ',');
            END IF;
            DBMS_LOB.APPEND(v_etl_filter_json,
                '{"filter_id":' || rec.filter_id ||
                ',"plant_id":"' || rec.plant_id ||
                '","plant_name":"' || REPLACE(rec.plant_name, '"', '\"') ||
                '","issue_revision":"' || rec.issue_revision ||
                '","added_date":"' || TO_CHAR(rec.added_date, 'YYYY-MM-DD HH24:MI:SS') ||
                '","added_by_user_id":"' || rec.added_by_user_id ||
                '","notes":"' || REPLACE(NVL(rec.notes, ''), '"', '\"') || '"}');
            v_filter_count := v_filter_count + 1;
        END LOOP;
        DBMS_LOB.APPEND(v_etl_filter_json, ']');

        -- Get sequence value
        SELECT CONTROL_DATA_BACKUP_SEQ.NEXTVAL INTO v_backup_id FROM DUAL;

        -- Insert into backup table
        INSERT INTO DDL_BACKUP_OWNER.CONTROL_DATA_BACKUP (
            backup_id,
            backup_timestamp,
            schema_name,
            control_settings_json,
            control_endpoints_json,
            etl_filter_json,
            settings_count,
            endpoints_count,
            filter_count,
            backup_notes,
            backup_user,
            ddl_backup_id
        ) VALUES (
            v_backup_id,
            SYSTIMESTAMP,
            p_schema_name,
            v_control_settings_json,
            v_control_endpoints_json,
            v_etl_filter_json,
            v_settings_count,
            v_endpoints_count,
            v_filter_count,
            p_notes,
            USER,
            p_ddl_backup_id
        );

        COMMIT;

        -- Cleanup
        DBMS_LOB.FREETEMPORARY(v_control_settings_json);
        DBMS_LOB.FREETEMPORARY(v_control_endpoints_json);
        DBMS_LOB.FREETEMPORARY(v_etl_filter_json);

        DBMS_OUTPUT.PUT_LINE('Control data backup completed. Backup ID: ' || v_backup_id);
        DBMS_OUTPUT.PUT_LINE('  Settings: ' || v_settings_count);
        DBMS_OUTPUT.PUT_LINE('  Endpoints: ' || v_endpoints_count);
        DBMS_OUTPUT.PUT_LINE('  Filters: ' || v_filter_count);

    EXCEPTION
        WHEN OTHERS THEN
            IF DBMS_LOB.ISTEMPORARY(v_control_settings_json) = 1 THEN
                DBMS_LOB.FREETEMPORARY(v_control_settings_json);
            END IF;
            IF DBMS_LOB.ISTEMPORARY(v_control_endpoints_json) = 1 THEN
                DBMS_LOB.FREETEMPORARY(v_control_endpoints_json);
            END IF;
            IF DBMS_LOB.ISTEMPORARY(v_etl_filter_json) = 1 THEN
                DBMS_LOB.FREETEMPORARY(v_etl_filter_json);
            END IF;
            RAISE_APPLICATION_ERROR(-20002, 'Control data backup failed: ' || SQLERRM);
    END backup_control_data;

    FUNCTION get_ddl_from_backup(p_backup_id NUMBER) RETURN CLOB IS
        v_ddl_content CLOB;
    BEGIN
        SELECT ddl_content INTO v_ddl_content
        FROM DDL_BACKUP_OWNER.DDL_BACKUP
        WHERE backup_id = p_backup_id;

        RETURN v_ddl_content;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20003, 'Backup ID ' || p_backup_id || ' not found');
    END get_ddl_from_backup;

    FUNCTION restore_control_data(
        p_backup_id NUMBER,
        p_dry_run BOOLEAN DEFAULT TRUE
    ) RETURN VARCHAR2 IS
        v_control_settings_json CLOB;
        v_control_endpoints_json CLOB;
        v_etl_filter_json CLOB;
        v_result VARCHAR2(4000);
        v_restored_count NUMBER := 0;
    BEGIN
        SELECT control_settings_json, control_endpoints_json, etl_filter_json
        INTO v_control_settings_json, v_control_endpoints_json, v_etl_filter_json
        FROM DDL_BACKUP_OWNER.CONTROL_DATA_BACKUP
        WHERE backup_id = p_backup_id;

        IF p_dry_run THEN
            v_result := 'DRY RUN - No changes made. Would restore:' || CHR(10);

            SELECT COUNT(*) INTO v_restored_count
            FROM JSON_TABLE(v_control_settings_json, '$[*]'
                COLUMNS (setting_key VARCHAR2(100) PATH '$.setting_key'));
            v_result := v_result || 'CONTROL_SETTINGS: ' || v_restored_count || ' records' || CHR(10);

            SELECT COUNT(*) INTO v_restored_count
            FROM JSON_TABLE(v_control_endpoints_json, '$[*]'
                COLUMNS (endpoint_id NUMBER PATH '$.endpoint_id'));
            v_result := v_result || 'CONTROL_ENDPOINTS: ' || v_restored_count || ' records' || CHR(10);

            SELECT COUNT(*) INTO v_restored_count
            FROM JSON_TABLE(v_etl_filter_json, '$[*]'
                COLUMNS (filter_id NUMBER PATH '$.filter_id'));
            v_result := v_result || 'ETL_FILTER: ' || v_restored_count || ' records';

        ELSE
            v_result := 'RESTORE COMPLETED:' || CHR(10);

            DELETE FROM CONTROL_SETTINGS;
            DELETE FROM CONTROL_ENDPOINTS;
            DELETE FROM ETL_FILTER;

            INSERT INTO CONTROL_SETTINGS (setting_key, setting_value, description)
            SELECT setting_key, setting_value, description
            FROM JSON_TABLE(v_control_settings_json, '$[*]'
                COLUMNS (
                    setting_key VARCHAR2(100) PATH '$.setting_key',
                    setting_value VARCHAR2(4000) PATH '$.setting_value',
                    description VARCHAR2(4000) PATH '$.description'
                ));
            v_result := v_result || 'CONTROL_SETTINGS: ' || SQL%ROWCOUNT || ' records' || CHR(10);

            INSERT INTO CONTROL_ENDPOINTS (endpoint_id, endpoint_key, endpoint_template, comments)
            SELECT endpoint_id, endpoint_key, endpoint_template, comments
            FROM JSON_TABLE(v_control_endpoints_json, '$[*]'
                COLUMNS (
                    endpoint_id NUMBER PATH '$.endpoint_id',
                    endpoint_key VARCHAR2(100) PATH '$.endpoint_key',
                    endpoint_template VARCHAR2(500) PATH '$.endpoint_template',
                    comments VARCHAR2(500) PATH '$.comments'
                ));
            v_result := v_result || 'CONTROL_ENDPOINTS: ' || SQL%ROWCOUNT || ' records' || CHR(10);

            INSERT INTO ETL_FILTER (filter_id, plant_id, plant_name, issue_revision,
                                   added_date, added_by_user_id, notes)
            SELECT filter_id, plant_id, plant_name, issue_revision,
                   TO_DATE(added_date, 'YYYY-MM-DD HH24:MI:SS'), added_by_user_id, notes
            FROM JSON_TABLE(v_etl_filter_json, '$[*]'
                COLUMNS (
                    filter_id NUMBER PATH '$.filter_id',
                    plant_id VARCHAR2(50) PATH '$.plant_id',
                    plant_name VARCHAR2(100) PATH '$.plant_name',
                    issue_revision VARCHAR2(50) PATH '$.issue_revision',
                    added_date VARCHAR2(30) PATH '$.added_date',
                    added_by_user_id VARCHAR2(50) PATH '$.added_by_user_id',
                    notes VARCHAR2(500) PATH '$.notes'
                ));
            v_result := v_result || 'ETL_FILTER: ' || SQL%ROWCOUNT || ' records';

            COMMIT;
        END IF;

        RETURN v_result;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20004, 'Control data backup ID ' || p_backup_id || ' not found');
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE_APPLICATION_ERROR(-20005, 'Restore failed: ' || SQLERRM);
    END restore_control_data;

    PROCEDURE list_backups(
        p_days_back NUMBER DEFAULT 7,
        p_schema_name VARCHAR2 DEFAULT USER
    ) IS
    BEGIN
        DBMS_OUTPUT.PUT_LINE('=== DDL Backups for ' || p_schema_name || ' (Last ' || p_days_back || ' days) ===');
        DBMS_OUTPUT.PUT_LINE(RPAD('ID', 5) || RPAD('Timestamp', 25) || RPAD('Type', 20) ||
                           RPAD('Objects', 10) || RPAD('Size(KB)', 10) || 'Notes');
        DBMS_OUTPUT.PUT_LINE(RPAD('-', 100, '-'));

        FOR rec IN (
            SELECT backup_id, backup_timestamp, backup_type, object_count,
                   ROUND(ddl_size_bytes/1024) as size_kb, backup_notes
            FROM DDL_BACKUP_OWNER.DDL_BACKUP
            WHERE schema_name = p_schema_name
            AND backup_timestamp >= SYSTIMESTAMP - p_days_back
            ORDER BY backup_timestamp DESC
        ) LOOP
            DBMS_OUTPUT.PUT_LINE(
                RPAD(rec.backup_id, 5) ||
                RPAD(TO_CHAR(rec.backup_timestamp, 'YYYY-MM-DD HH24:MI:SS'), 25) ||
                RPAD(NVL(rec.backup_type, 'UNKNOWN'), 20) ||
                RPAD(rec.object_count, 10) ||
                RPAD(rec.size_kb || 'KB', 10) ||
                NVL(SUBSTR(rec.backup_notes, 1, 30), 'No notes')
            );
        END LOOP;
    END list_backups;

    PROCEDURE compare_backups(
        p_backup_id_1 NUMBER,
        p_backup_id_2 NUMBER
    ) IS
        v_count1 NUMBER;
        v_count2 NUMBER;
        v_size1 NUMBER;
        v_size2 NUMBER;
        v_date1 TIMESTAMP;
        v_date2 TIMESTAMP;
    BEGIN
        SELECT object_count, ddl_size_bytes, backup_timestamp
        INTO v_count1, v_size1, v_date1
        FROM DDL_BACKUP_OWNER.DDL_BACKUP
        WHERE backup_id = p_backup_id_1;

        SELECT object_count, ddl_size_bytes, backup_timestamp
        INTO v_count2, v_size2, v_date2
        FROM DDL_BACKUP_OWNER.DDL_BACKUP
        WHERE backup_id = p_backup_id_2;

        DBMS_OUTPUT.PUT_LINE('=== Backup Comparison ===');
        DBMS_OUTPUT.PUT_LINE('Backup ' || p_backup_id_1 || ' (' || TO_CHAR(v_date1, 'YYYY-MM-DD HH24:MI') || ')');
        DBMS_OUTPUT.PUT_LINE('  Objects: ' || v_count1 || ', Size: ' || ROUND(v_size1/1024) || 'KB');
        DBMS_OUTPUT.PUT_LINE('Backup ' || p_backup_id_2 || ' (' || TO_CHAR(v_date2, 'YYYY-MM-DD HH24:MI') || ')');
        DBMS_OUTPUT.PUT_LINE('  Objects: ' || v_count2 || ', Size: ' || ROUND(v_size2/1024) || 'KB');
        DBMS_OUTPUT.PUT_LINE('Differences:');
        DBMS_OUTPUT.PUT_LINE('  Object count: ' || (v_count2 - v_count1));
        DBMS_OUTPUT.PUT_LINE('  Size change: ' || ROUND((v_size2 - v_size1)/1024) || 'KB');
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('Error: One or both backup IDs not found');
    END compare_backups;

    FUNCTION get_latest_backup_id(
        p_schema_name VARCHAR2 DEFAULT USER
    ) RETURN NUMBER IS
        v_backup_id NUMBER;
    BEGIN
        SELECT MAX(backup_id) INTO v_backup_id
        FROM DDL_BACKUP_OWNER.DDL_BACKUP
        WHERE schema_name = p_schema_name;

        RETURN v_backup_id;
    END get_latest_backup_id;

END PKG_DDL_BACKUP;
/


  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "TR2000_STAGING"."PKG_ETL_LOGGING" AS

    -- Package variable to store current run_id
    g_current_run_id NUMBER;

    -- Start ETL run
    FUNCTION start_etl_run(
        p_run_type      VARCHAR2,
        p_initiated_by  VARCHAR2 DEFAULT USER
    ) RETURN NUMBER IS
        v_run_id NUMBER;
    BEGIN
        -- Get next run_id
        SELECT ETL_RUN_SEQ.NEXTVAL INTO v_run_id FROM DUAL;

        -- Insert into ETL_RUN_LOG
        INSERT INTO ETL_RUN_LOG (
            run_id, run_type, start_time, status, initiated_by
        ) VALUES (
            v_run_id, p_run_type, SYSTIMESTAMP, 'RUNNING', p_initiated_by
        );

        -- Store run_id in package variable
        g_current_run_id := v_run_id;

        COMMIT;
        RETURN v_run_id;
    END start_etl_run;

    -- End ETL run
    PROCEDURE end_etl_run(
        p_run_id    NUMBER,
        p_status    VARCHAR2  -- SUCCESS, FAILED, WARNING
    ) IS
    BEGIN
        -- Update ETL_RUN_LOG
        UPDATE ETL_RUN_LOG
        SET end_time = SYSTIMESTAMP,
            status = p_status
        WHERE run_id = p_run_id;

        -- Log summary statistics
        log_run_summary(p_run_id);

        COMMIT;
    END end_etl_run;

    -- Statistics logging
    FUNCTION log_operation_start(
        p_run_id            NUMBER,
        p_stat_type         VARCHAR2,  -- API_CALL, PROCESSING, CLEAR, SUMMARY
        p_endpoint_key      VARCHAR2 DEFAULT NULL,
        p_operation_name    VARCHAR2 DEFAULT NULL,
        p_plant_id          VARCHAR2 DEFAULT NULL,
        p_issue_revision    VARCHAR2 DEFAULT NULL,
        p_pcs_name          VARCHAR2 DEFAULT NULL
    ) RETURN NUMBER IS
        v_stat_id NUMBER;
    BEGIN
        INSERT INTO ETL_STATISTICS (
            run_id, stat_type, endpoint_key, operation_name,
            plant_id, issue_revision, pcs_name,
            start_time, status
        ) VALUES (
            p_run_id, p_stat_type, p_endpoint_key, p_operation_name,
            p_plant_id, p_issue_revision, p_pcs_name,
            SYSTIMESTAMP, 'RUNNING'
        ) RETURNING stat_id INTO v_stat_id;

        COMMIT;
        RETURN v_stat_id;
    END log_operation_start;

    PROCEDURE log_operation_end(
        p_stat_id           NUMBER,
        p_status            VARCHAR2,  -- SUCCESS, FAILED, WARNING
        p_records_processed NUMBER DEFAULT 0,
        p_records_inserted  NUMBER DEFAULT 0,
        p_records_updated   NUMBER DEFAULT 0,
        p_records_deleted   NUMBER DEFAULT 0,
        p_records_failed    NUMBER DEFAULT 0,
        p_api_response_size NUMBER DEFAULT NULL,
        p_api_status_code   NUMBER DEFAULT NULL,
        p_error_message     VARCHAR2 DEFAULT NULL
    ) IS
    BEGIN
        UPDATE ETL_STATISTICS
        SET end_time = SYSTIMESTAMP,
            status = p_status,
            records_processed = p_records_processed,
            records_inserted = p_records_inserted,
            records_updated = p_records_updated,
            records_deleted = p_records_deleted,
            records_failed = p_records_failed,
            api_response_size = p_api_response_size,
            api_status_code = p_api_status_code,
            error_message = p_error_message
        WHERE stat_id = p_stat_id;

        COMMIT;
    END log_operation_end;

    -- Error logging
    PROCEDURE log_error(
        p_endpoint_key      VARCHAR2,
        p_plant_id          VARCHAR2 DEFAULT NULL,
        p_issue_revision    VARCHAR2 DEFAULT NULL,
        p_error_type        VARCHAR2 DEFAULT 'PROCESSING_ERROR',
        p_error_code        VARCHAR2 DEFAULT NULL,
        p_error_message     VARCHAR2,
        p_error_stack       CLOB DEFAULT NULL,
        p_raw_data          CLOB DEFAULT NULL
    ) IS
    BEGIN
        INSERT INTO ETL_ERROR_LOG (
            error_id, endpoint_key, plant_id, issue_revision,
            error_timestamp, error_type, error_code, error_message,
            error_stack, raw_data
        ) VALUES (
            ETL_ERROR_SEQ.NEXTVAL, p_endpoint_key, p_plant_id, p_issue_revision,
            SYSTIMESTAMP, p_error_type, p_error_code, p_error_message,
            p_error_stack, p_raw_data
        );

        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            NULL; -- Don't let logging errors break the main process
    END log_error;

    -- Quick logging procedures for common operations
    PROCEDURE log_api_call(
        p_run_id            NUMBER,
        p_endpoint_key      VARCHAR2,
        p_plant_id          VARCHAR2 DEFAULT NULL,
        p_issue_revision    VARCHAR2 DEFAULT NULL,
        p_duration_ms       NUMBER,
        p_response_size     NUMBER,
        p_status_code       NUMBER,
        p_status            VARCHAR2
    ) IS
        v_stat_id NUMBER;
    BEGIN
        INSERT INTO ETL_STATISTICS (
            run_id, stat_type, endpoint_key, plant_id, issue_revision,
            start_time, end_time, status,
            api_response_size, api_status_code
        ) VALUES (
            p_run_id, 'API_CALL', p_endpoint_key, p_plant_id, p_issue_revision,
            SYSTIMESTAMP - NUMTODSINTERVAL(p_duration_ms/1000, 'SECOND'),
            SYSTIMESTAMP, p_status,
            p_response_size, p_status_code
        );

        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            NULL; -- Don't let logging errors break the main process
    END log_api_call;

    PROCEDURE log_clear_operation(
        p_run_id            NUMBER,
        p_table_name        VARCHAR2,
        p_records_deleted   NUMBER,
        p_duration_ms       NUMBER DEFAULT NULL
    ) IS
    BEGIN
        INSERT INTO ETL_STATISTICS (
            run_id, stat_type, operation_name,
            start_time, end_time, status,
            records_deleted
        ) VALUES (
            p_run_id, 'CLEAR', 'Clear ' || p_table_name,
            SYSTIMESTAMP - NUMTODSINTERVAL(NVL(p_duration_ms, 100)/1000, 'SECOND'),
            SYSTIMESTAMP, 'SUCCESS',
            p_records_deleted
        );

        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            NULL; -- Don't let logging errors break the main process
    END log_clear_operation;

    -- Summary statistics - PROPERLY IMPLEMENTED
    PROCEDURE log_run_summary(
        p_run_id            NUMBER
    ) IS
        v_total_operations NUMBER;
        v_successful_ops NUMBER;
        v_failed_ops NUMBER;
        v_total_records NUMBER;
        v_total_api_calls NUMBER;
        v_run_duration_seconds NUMBER;
    BEGIN
        -- Calculate summary statistics
        SELECT
            COUNT(*),
            SUM(CASE WHEN status = 'SUCCESS' THEN 1 ELSE 0 END),
            SUM(CASE WHEN status = 'FAILED' THEN 1 ELSE 0 END),
            SUM(NVL(records_processed, 0) + NVL(records_inserted, 0) +
                NVL(records_updated, 0) + NVL(records_deleted, 0)),
            SUM(CASE WHEN stat_type = 'API_CALL' THEN 1 ELSE 0 END)
        INTO
            v_total_operations,
            v_successful_ops,
            v_failed_ops,
            v_total_records,
            v_total_api_calls
        FROM ETL_STATISTICS
        WHERE run_id = p_run_id;

        -- Calculate run duration
        SELECT EXTRACT(SECOND FROM (end_time - start_time)) +
               EXTRACT(MINUTE FROM (end_time - start_time)) * 60 +
               EXTRACT(HOUR FROM (end_time - start_time)) * 3600
        INTO v_run_duration_seconds
        FROM ETL_RUN_LOG
        WHERE run_id = p_run_id;

        -- Insert summary as a SUMMARY type statistic
        INSERT INTO ETL_STATISTICS (
            run_id, stat_type, operation_name,
            start_time, end_time, status,
            records_processed,
            api_status_code,  -- Using this for total operations count
            api_response_size -- Using this for API call count
        ) VALUES (
            p_run_id, 'SUMMARY', 'ETL Run Summary',
            SYSTIMESTAMP - NUMTODSINTERVAL(v_run_duration_seconds, 'SECOND'),
            SYSTIMESTAMP,
            CASE WHEN v_failed_ops = 0 THEN 'SUCCESS' ELSE 'WARNING' END,
            v_total_records,
            v_total_operations,
            v_total_api_calls
        );

        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            NULL; -- Don't let summary errors break the main process
    END log_run_summary;

    -- Utility to get current run_id (for nested procedures)
    FUNCTION get_current_run_id RETURN NUMBER IS
    BEGIN
        RETURN g_current_run_id;
    END get_current_run_id;

    PROCEDURE set_current_run_id(p_run_id NUMBER) IS
    BEGIN
        g_current_run_id := p_run_id;
    END set_current_run_id;

END PKG_ETL_LOGGING;
/


  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "TR2000_STAGING"."PKG_ETL_PROCESSOR" AS

    -- =====================================================
    -- PARSE AND LOAD PCS REFERENCES
    -- =====================================================
    PROCEDURE parse_and_load_pcs_references(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2,
        p_issue_revision IN VARCHAR2
    ) IS
        v_json CLOB;
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Step 1: Get JSON from RAW_JSON
        SELECT payload INTO v_json
        FROM RAW_JSON
        WHERE raw_json_id = p_raw_json_id;

        -- Step 2: Clear staging table
        DELETE FROM STG_PCS_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        -- Step 3: Parse JSON to staging table
        INSERT INTO STG_PCS_REFERENCES (
            plant_id, issue_revision,
            "PCS", "Revision", "RevDate", "Status",
            "OfficialRevision", "RevisionSuffix", "RatingClass",
            "MaterialGroup", "HistoricalPCS", "Delta"
        )
        SELECT
            p_plant_id, p_issue_revision,
            jt.PCS, jt.Revision, jt.RevDate, jt.Status,
            jt.OfficialRevision, jt.RevisionSuffix, jt.RatingClass,
            jt.MaterialGroup, jt.HistoricalPCS, jt.Delta
        FROM JSON_TABLE(v_json, '$.getIssuePCSList[*]'
            COLUMNS (
                PCS VARCHAR2(100) PATH '$.PCS',
                Revision VARCHAR2(50) PATH '$.Revision',
                RevDate VARCHAR2(50) PATH '$.RevDate',
                Status VARCHAR2(50) PATH '$.Status',
                OfficialRevision VARCHAR2(50) PATH '$.OfficialRevision',
                RevisionSuffix VARCHAR2(50) PATH '$.RevisionSuffix',
                RatingClass VARCHAR2(100) PATH '$.RatingClass',
                MaterialGroup VARCHAR2(100) PATH '$.MaterialGroup',
                HistoricalPCS VARCHAR2(100) PATH '$.HistoricalPCS',
                Delta VARCHAR2(50) PATH '$.Delta'
            )
        ) jt;

        -- Step 4: Move from staging to core table with type conversion
        DELETE FROM PCS_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        INSERT INTO PCS_REFERENCES (
            pcs_references_guid, plant_id, issue_revision, pcs_name,
            revision, rev_date, status, official_revision,
            revision_suffix, rating_class, material_group,
            historical_pcs, delta, created_date, last_modified_date
        )
        SELECT
            SYS_GUID(), plant_id, issue_revision, "PCS",
            "Revision", PKG_DATE_UTILS.safe_parse_date("RevDate"),
            "Status", "OfficialRevision", "RevisionSuffix",
            "RatingClass", "MaterialGroup", "HistoricalPCS",
            "Delta", SYSDATE, SYSDATE
        FROM STG_PCS_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

    EXCEPTION
        WHEN OTHERS THEN
            v_error_msg := 'Error in parse_and_load_pcs_references: ' || SQLERRM;
            PKG_ETL_LOGGING.log_error(
                p_endpoint_key => 'PCS_REFERENCES',
                p_plant_id => p_plant_id,
                p_issue_revision => p_issue_revision,
                p_error_type => 'PROCESSING_ERROR',
                p_error_code => 'PCS_PARSE_ERROR',
                p_error_message => v_error_msg,
                p_raw_data => v_json
            );
            RAISE;
    END parse_and_load_pcs_references;

    -- =====================================================
    -- PARSE AND LOAD VDS REFERENCES
    -- =====================================================
    PROCEDURE parse_and_load_vds_references(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2,
        p_issue_revision IN VARCHAR2
    ) IS
        v_json CLOB;
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Step 1: Get JSON from RAW_JSON
        SELECT payload INTO v_json
        FROM RAW_JSON
        WHERE raw_json_id = p_raw_json_id;

        -- Step 2: Clear staging table
        DELETE FROM STG_VDS_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        -- Step 3: Parse JSON to staging table
        INSERT INTO STG_VDS_REFERENCES (
            plant_id, issue_revision,
            "VDS", "Revision", "RevDate", "Status",
            "OfficialRevision", "Delta"
        )
        SELECT
            p_plant_id, p_issue_revision,
            jt.VDS, jt.Revision, jt.RevDate, jt.Status,
            jt.OfficialRevision, jt.Delta
        FROM JSON_TABLE(v_json, '$.getIssueVDSList[*]'
            COLUMNS (
                VDS VARCHAR2(100) PATH '$.VDS',
                Revision VARCHAR2(50) PATH '$.Revision',
                RevDate VARCHAR2(50) PATH '$.RevDate',
                Status VARCHAR2(50) PATH '$.Status',
                OfficialRevision VARCHAR2(50) PATH '$.OfficialRevision',
                Delta VARCHAR2(50) PATH '$.Delta'
            )
        ) jt;

        -- Step 4: Move from staging to core table with type conversion
        DELETE FROM VDS_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        INSERT INTO VDS_REFERENCES (
            vds_references_guid, plant_id, issue_revision, vds_name,
            revision, rev_date, status, official_revision,
            delta, created_date, last_modified_date
        )
        SELECT
            SYS_GUID(), plant_id, issue_revision, "VDS",
            "Revision", PKG_DATE_UTILS.safe_parse_date("RevDate"),
            "Status", "OfficialRevision", "Delta",
            SYSDATE, SYSDATE
        FROM STG_VDS_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

    EXCEPTION
        WHEN OTHERS THEN
            v_error_msg := 'Error in parse_and_load_vds_references: ' || SQLERRM;
            PKG_ETL_LOGGING.log_error(
                p_endpoint_key => 'VDS_REFERENCES',
                p_plant_id => p_plant_id,
                p_issue_revision => p_issue_revision,
                p_error_type => 'PROCESSING_ERROR',
                p_error_code => 'VDS_PARSE_ERROR',
                p_error_message => v_error_msg,
                p_raw_data => v_json
            );
            RAISE;
    END parse_and_load_vds_references;

    -- =====================================================
    -- PARSE AND LOAD MDS REFERENCES
    -- =====================================================
    PROCEDURE parse_and_load_mds_references(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2,
        p_issue_revision IN VARCHAR2
    ) IS
        v_json CLOB;
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Step 1: Get JSON from RAW_JSON
        SELECT payload INTO v_json
        FROM RAW_JSON
        WHERE raw_json_id = p_raw_json_id;

        -- Step 2: Clear staging table
        DELETE FROM STG_MDS_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        -- Step 3: Parse JSON to staging table
        INSERT INTO STG_MDS_REFERENCES (
            plant_id, issue_revision,
            "MDS", "Revision", "Area", "RevDate",
            "Status", "OfficialRevision", "Delta"
        )
        SELECT
            p_plant_id, p_issue_revision,
            jt.MDS, jt.Revision, jt.Area, jt.RevDate,
            jt.Status, jt.OfficialRevision, jt.Delta
        FROM JSON_TABLE(v_json, '$.getIssueMDSList[*]'
            COLUMNS (
                MDS VARCHAR2(100) PATH '$.MDS',
                Revision VARCHAR2(50) PATH '$.Revision',
                Area VARCHAR2(100) PATH '$.Area',
                RevDate VARCHAR2(50) PATH '$.RevDate',
                Status VARCHAR2(50) PATH '$.Status',
                OfficialRevision VARCHAR2(50) PATH '$.OfficialRevision',
                Delta VARCHAR2(50) PATH '$.Delta'
            )
        ) jt;

        -- Step 4: Move from staging to core table with type conversion
        DELETE FROM MDS_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        INSERT INTO MDS_REFERENCES (
            mds_references_guid, plant_id, issue_revision, mds_name,
            revision, area, rev_date, status, official_revision,
            delta, created_date, last_modified_date
        )
        SELECT
            SYS_GUID(), plant_id, issue_revision, "MDS",
            "Revision", "Area", PKG_DATE_UTILS.safe_parse_date("RevDate"),
            "Status", "OfficialRevision", "Delta",
            SYSDATE, SYSDATE
        FROM STG_MDS_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

    EXCEPTION
        WHEN OTHERS THEN
            v_error_msg := 'Error in parse_and_load_mds_references: ' || SQLERRM;
            PKG_ETL_LOGGING.log_error(
                p_endpoint_key => 'MDS_REFERENCES',
                p_plant_id => p_plant_id,
                p_issue_revision => p_issue_revision,
                p_error_type => 'PROCESSING_ERROR',
                p_error_code => 'MDS_PARSE_ERROR',
                p_error_message => v_error_msg,
                p_raw_data => v_json
            );
            RAISE;
    END parse_and_load_mds_references;

    -- =====================================================
    -- PARSE AND LOAD EDS REFERENCES
    -- =====================================================
    PROCEDURE parse_and_load_eds_references(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2,
        p_issue_revision IN VARCHAR2
    ) IS
        v_json CLOB;
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Step 1: Get JSON from RAW_JSON
        SELECT payload INTO v_json
        FROM RAW_JSON
        WHERE raw_json_id = p_raw_json_id;

        -- Step 2: Clear staging table
        DELETE FROM STG_EDS_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        -- Step 3: Parse JSON to staging table
        INSERT INTO STG_EDS_REFERENCES (
            plant_id, issue_revision,
            "EDS", "Revision", "RevDate", "Status",
            "OfficialRevision", "Delta"
        )
        SELECT
            p_plant_id, p_issue_revision,
            jt.EDS, jt.Revision, jt.RevDate, jt.Status,
            jt.OfficialRevision, jt.Delta
        FROM JSON_TABLE(v_json, '$.getIssueEDSList[*]'
            COLUMNS (
                EDS VARCHAR2(100) PATH '$.EDS',
                Revision VARCHAR2(50) PATH '$.Revision',
                RevDate VARCHAR2(50) PATH '$.RevDate',
                Status VARCHAR2(50) PATH '$.Status',
                OfficialRevision VARCHAR2(50) PATH '$.OfficialRevision',
                Delta VARCHAR2(50) PATH '$.Delta'
            )
        ) jt;

        -- Step 4: Move from staging to core table with type conversion
        DELETE FROM EDS_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        INSERT INTO EDS_REFERENCES (
            eds_references_guid, plant_id, issue_revision, eds_name,
            revision, rev_date, status, official_revision,
            delta, created_date, last_modified_date
        )
        SELECT
            SYS_GUID(), plant_id, issue_revision, "EDS",
            "Revision", PKG_DATE_UTILS.safe_parse_date("RevDate"),
            "Status", "OfficialRevision", "Delta",
            SYSDATE, SYSDATE
        FROM STG_EDS_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

    EXCEPTION
        WHEN OTHERS THEN
            v_error_msg := 'Error in parse_and_load_eds_references: ' || SQLERRM;
            PKG_ETL_LOGGING.log_error(
                p_endpoint_key => 'EDS_REFERENCES',
                p_plant_id => p_plant_id,
                p_issue_revision => p_issue_revision,
                p_error_type => 'PROCESSING_ERROR',
                p_error_code => 'EDS_PARSE_ERROR',
                p_error_message => v_error_msg,
                p_raw_data => v_json
            );
            RAISE;
    END parse_and_load_eds_references;

    -- =====================================================
    -- PARSE AND LOAD VSK REFERENCES
    -- =====================================================
    PROCEDURE parse_and_load_vsk_references(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2,
        p_issue_revision IN VARCHAR2
    ) IS
        v_json CLOB;
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Step 1: Get JSON from RAW_JSON
        SELECT payload INTO v_json
        FROM RAW_JSON
        WHERE raw_json_id = p_raw_json_id;

        -- Step 2: Clear staging table
        DELETE FROM STG_VSK_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        -- Step 3: Parse JSON to staging table
        INSERT INTO STG_VSK_REFERENCES (
            plant_id, issue_revision,
            "VSK", "Revision", "RevDate", "Status",
            "OfficialRevision", "Delta"
        )
        SELECT
            p_plant_id, p_issue_revision,
            jt.VSK, jt.Revision, jt.RevDate, jt.Status,
            jt.OfficialRevision, jt.Delta
        FROM JSON_TABLE(v_json, '$.getIssueVSKList[*]'
            COLUMNS (
                VSK VARCHAR2(100) PATH '$.VSK',
                Revision VARCHAR2(50) PATH '$.Revision',
                RevDate VARCHAR2(50) PATH '$.RevDate',
                Status VARCHAR2(50) PATH '$.Status',
                OfficialRevision VARCHAR2(50) PATH '$.OfficialRevision',
                Delta VARCHAR2(50) PATH '$.Delta'
            )
        ) jt;

        -- Step 4: Move from staging to core table with type conversion
        DELETE FROM VSK_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        INSERT INTO VSK_REFERENCES (
            vsk_references_guid, plant_id, issue_revision, vsk_name,
            revision, rev_date, status, official_revision,
            delta, created_date, last_modified_date
        )
        SELECT
            SYS_GUID(), plant_id, issue_revision, "VSK",
            "Revision", PKG_DATE_UTILS.safe_parse_date("RevDate"),
            "Status", "OfficialRevision", "Delta",
            SYSDATE, SYSDATE
        FROM STG_VSK_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

    EXCEPTION
        WHEN OTHERS THEN
            v_error_msg := 'Error in parse_and_load_vsk_references: ' || SQLERRM;
            PKG_ETL_LOGGING.log_error(
                p_endpoint_key => 'VSK_REFERENCES',
                p_plant_id => p_plant_id,
                p_issue_revision => p_issue_revision,
                p_error_type => 'PROCESSING_ERROR',
                p_error_code => 'VSK_PARSE_ERROR',
                p_error_message => v_error_msg,
                p_raw_data => v_json
            );
            RAISE;
    END parse_and_load_vsk_references;

    -- =====================================================
    -- PARSE AND LOAD ESK REFERENCES
    -- =====================================================
    PROCEDURE parse_and_load_esk_references(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2,
        p_issue_revision IN VARCHAR2
    ) IS
        v_json CLOB;
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Step 1: Get JSON from RAW_JSON
        SELECT payload INTO v_json
        FROM RAW_JSON
        WHERE raw_json_id = p_raw_json_id;

        -- Step 2: Clear staging table
        DELETE FROM STG_ESK_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        -- Step 3: Parse JSON to staging table
        INSERT INTO STG_ESK_REFERENCES (
            plant_id, issue_revision,
            "ESK", "Revision", "RevDate", "Status",
            "OfficialRevision", "Delta"
        )
        SELECT
            p_plant_id, p_issue_revision,
            jt.ESK, jt.Revision, jt.RevDate, jt.Status,
            jt.OfficialRevision, jt.Delta
        FROM JSON_TABLE(v_json, '$.getIssueESKList[*]'
            COLUMNS (
                ESK VARCHAR2(100) PATH '$.ESK',
                Revision VARCHAR2(50) PATH '$.Revision',
                RevDate VARCHAR2(50) PATH '$.RevDate',
                Status VARCHAR2(50) PATH '$.Status',
                OfficialRevision VARCHAR2(50) PATH '$.OfficialRevision',
                Delta VARCHAR2(50) PATH '$.Delta'
            )
        ) jt;

        -- Step 4: Move from staging to core table with type conversion
        DELETE FROM ESK_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        INSERT INTO ESK_REFERENCES (
            esk_references_guid, plant_id, issue_revision, esk_name,
            revision, rev_date, status, official_revision,
            delta, created_date, last_modified_date
        )
        SELECT
            SYS_GUID(), plant_id, issue_revision, "ESK",
            "Revision", PKG_DATE_UTILS.safe_parse_date("RevDate"),
            "Status", "OfficialRevision", "Delta",
            SYSDATE, SYSDATE
        FROM STG_ESK_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

    EXCEPTION
        WHEN OTHERS THEN
            v_error_msg := 'Error in parse_and_load_esk_references: ' || SQLERRM;
            PKG_ETL_LOGGING.log_error(
                p_endpoint_key => 'ESK_REFERENCES',
                p_plant_id => p_plant_id,
                p_issue_revision => p_issue_revision,
                p_error_type => 'PROCESSING_ERROR',
                p_error_code => 'ESK_PARSE_ERROR',
                p_error_message => v_error_msg,
                p_raw_data => v_json
            );
            RAISE;
    END parse_and_load_esk_references;

    -- =====================================================
    -- PARSE AND LOAD PIPE ELEMENT REFERENCES
    -- =====================================================
    PROCEDURE parse_and_load_pipe_element_references(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2,
        p_issue_revision IN VARCHAR2
    ) IS
        v_json CLOB;
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Step 1: Get JSON from RAW_JSON
        SELECT payload INTO v_json
        FROM RAW_JSON
        WHERE raw_json_id = p_raw_json_id;

        -- Step 2: Clear staging table
        DELETE FROM STG_PIPE_ELEMENT_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        -- Step 3: Parse JSON to staging table
        INSERT INTO STG_PIPE_ELEMENT_REFERENCES (
            plant_id, issue_revision,
            "ElementID", "ElementGroup", "DimensionStandard",
            "ProductForm", "MaterialGrade", "MDS", "MDSRevision",
            "Area", "Revision", "RevDate", "Status", "Delta"
        )
        SELECT
            p_plant_id, p_issue_revision,
            jt.ElementID, jt.ElementGroup, jt.DimensionStandard,
            jt.ProductForm, jt.MaterialGrade, jt.MDS, jt.MDSRevision,
            jt.Area, jt.Revision, jt.RevDate, jt.Status, jt.Delta
        FROM JSON_TABLE(v_json, '$.getIssuePipeElementList[*]'
            COLUMNS (
                ElementID VARCHAR2(50) PATH '$.ElementID',
                ElementGroup VARCHAR2(100) PATH '$.ElementGroup',
                DimensionStandard VARCHAR2(100) PATH '$.DimensionStandard',
                ProductForm VARCHAR2(100) PATH '$.ProductForm',
                MaterialGrade VARCHAR2(200) PATH '$.MaterialGrade',
                MDS VARCHAR2(100) PATH '$.MDS',
                MDSRevision VARCHAR2(50) PATH '$.MDSRevision',
                Area VARCHAR2(100) PATH '$.Area',
                Revision VARCHAR2(50) PATH '$.Revision',
                RevDate VARCHAR2(50) PATH '$.RevDate',
                Status VARCHAR2(50) PATH '$.Status',
                Delta VARCHAR2(50) PATH '$.Delta'
            )
        ) jt;

        -- Step 4: Move from staging to core table with type conversion
        DELETE FROM PIPE_ELEMENT_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        INSERT INTO PIPE_ELEMENT_REFERENCES (
            pipe_element_references_guid, plant_id, issue_revision,
            element_id, element_group, dimension_standard,
            product_form, material_grade, mds, mds_revision,
            area, revision, rev_date, status, delta,
            created_date, last_modified_date
        )
        SELECT
            SYS_GUID(), plant_id, issue_revision,
            TO_NUMBER("ElementID"), "ElementGroup", "DimensionStandard",
            "ProductForm", "MaterialGrade", "MDS", "MDSRevision",
            "Area", "Revision", PKG_DATE_UTILS.safe_parse_date("RevDate"),
            "Status", "Delta", SYSDATE, SYSDATE
        FROM STG_PIPE_ELEMENT_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

    EXCEPTION
        WHEN OTHERS THEN
            v_error_msg := 'Error in parse_and_load_pipe_element_references: ' || SQLERRM;
            PKG_ETL_LOGGING.log_error(
                p_endpoint_key => 'PIPE_ELEMENT_REFERENCES',
                p_plant_id => p_plant_id,
                p_issue_revision => p_issue_revision,
                p_error_type => 'PROCESSING_ERROR',
                p_error_code => 'PIPE_ELEMENT_PARSE_ERROR',
                p_error_message => v_error_msg,
                p_raw_data => v_json
            );
            RAISE;
    END parse_and_load_pipe_element_references;

    -- =====================================================
    -- PARSE AND LOAD SC REFERENCES
    -- =====================================================
    PROCEDURE parse_and_load_sc_references(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2,
        p_issue_revision IN VARCHAR2
    ) IS
        v_json CLOB;
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Step 1: Get JSON from RAW_JSON
        SELECT payload INTO v_json
        FROM RAW_JSON
        WHERE raw_json_id = p_raw_json_id;

        -- Step 2: Clear staging table
        DELETE FROM STG_SC_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        -- Step 3: Parse JSON to staging table
        INSERT INTO STG_SC_REFERENCES (
            plant_id, issue_revision,
            "SC", "Revision", "RevDate", "Status",
            "OfficialRevision", "Delta"
        )
        SELECT
            p_plant_id, p_issue_revision,
            jt.SC, jt.Revision, jt.RevDate, jt.Status,
            jt.OfficialRevision, jt.Delta
        FROM JSON_TABLE(v_json, '$.getIssueSCList[*]'
            COLUMNS (
                SC VARCHAR2(100) PATH '$.SC',
                Revision VARCHAR2(50) PATH '$.Revision',
                RevDate VARCHAR2(50) PATH '$.RevDate',
                Status VARCHAR2(50) PATH '$.Status',
                OfficialRevision VARCHAR2(50) PATH '$.OfficialRevision',
                Delta VARCHAR2(50) PATH '$.Delta'
            )
        ) jt;

        -- Step 4: Move from staging to core table with type conversion
        DELETE FROM SC_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        INSERT INTO SC_REFERENCES (
            sc_references_guid, plant_id, issue_revision, sc_name,
            revision, rev_date, status, official_revision,
            delta, created_date, last_modified_date
        )
        SELECT
            SYS_GUID(), plant_id, issue_revision, "SC",
            "Revision", PKG_DATE_UTILS.safe_parse_date("RevDate"),
            "Status", "OfficialRevision", "Delta",
            SYSDATE, SYSDATE
        FROM STG_SC_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

    EXCEPTION
        WHEN OTHERS THEN
            v_error_msg := 'Error in parse_and_load_sc_references: ' || SQLERRM;
            PKG_ETL_LOGGING.log_error(
                p_endpoint_key => 'SC_REFERENCES',
                p_plant_id => p_plant_id,
                p_issue_revision => p_issue_revision,
                p_error_type => 'PROCESSING_ERROR',
                p_error_code => 'SC_PARSE_ERROR',
                p_error_message => v_error_msg,
                p_raw_data => v_json
            );
            RAISE;
    END parse_and_load_sc_references;

    -- =====================================================
    -- PARSE AND LOAD VSM REFERENCES
    -- =====================================================
    PROCEDURE parse_and_load_vsm_references(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2,
        p_issue_revision IN VARCHAR2
    ) IS
        v_json CLOB;
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Step 1: Get JSON from RAW_JSON
        SELECT payload INTO v_json
        FROM RAW_JSON
        WHERE raw_json_id = p_raw_json_id;

        -- Step 2: Clear staging table
        DELETE FROM STG_VSM_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        -- Step 3: Parse JSON to staging table
        INSERT INTO STG_VSM_REFERENCES (
            plant_id, issue_revision,
            "VSM", "Revision", "RevDate", "Status",
            "OfficialRevision", "Delta"
        )
        SELECT
            p_plant_id, p_issue_revision,
            jt.VSM, jt.Revision, jt.RevDate, jt.Status,
            jt.OfficialRevision, jt.Delta
        FROM JSON_TABLE(v_json, '$.getIssueVSMList[*]'
            COLUMNS (
                VSM VARCHAR2(100) PATH '$.VSM',
                Revision VARCHAR2(50) PATH '$.Revision',
                RevDate VARCHAR2(50) PATH '$.RevDate',
                Status VARCHAR2(50) PATH '$.Status',
                OfficialRevision VARCHAR2(50) PATH '$.OfficialRevision',
                Delta VARCHAR2(50) PATH '$.Delta'
            )
        ) jt;

        -- Step 4: Move from staging to core table with type conversion
        DELETE FROM VSM_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

        INSERT INTO VSM_REFERENCES (
            vsm_references_guid, plant_id, issue_revision, vsm_name,
            revision, rev_date, status, official_revision,
            delta, created_date, last_modified_date
        )
        SELECT
            SYS_GUID(), plant_id, issue_revision, "VSM",
            "Revision", PKG_DATE_UTILS.safe_parse_date("RevDate"),
            "Status", "OfficialRevision", "Delta",
            SYSDATE, SYSDATE
        FROM STG_VSM_REFERENCES
        WHERE plant_id = p_plant_id
        AND issue_revision = p_issue_revision;

    EXCEPTION
        WHEN OTHERS THEN
            v_error_msg := 'Error in parse_and_load_vsm_references: ' || SQLERRM;
            PKG_ETL_LOGGING.log_error(
                p_endpoint_key => 'VSM_REFERENCES',
                p_plant_id => p_plant_id,
                p_issue_revision => p_issue_revision,
                p_error_type => 'PROCESSING_ERROR',
                p_error_code => 'VSM_PARSE_ERROR',
                p_error_message => v_error_msg,
                p_raw_data => v_json
            );
            RAISE;
    END parse_and_load_vsm_references;

    -- =====================================================
    -- PARSE AND LOAD PCS LIST
    -- =====================================================
    PROCEDURE parse_and_load_pcs_list(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2
    ) IS
        v_json CLOB;
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Step 1: Get JSON from RAW_JSON
        SELECT payload INTO v_json
        FROM RAW_JSON
        WHERE raw_json_id = p_raw_json_id;

        -- Step 2: Clear staging table
        DELETE FROM STG_PCS_LIST
        WHERE plant_id = p_plant_id;

        -- Step 3: Parse JSON to staging table - FIXED: $.getPCS[*]
        INSERT INTO STG_PCS_LIST (
            plant_id, "PCS", "Revision", "Status", "RevDate",
            "RatingClass", "TestPressure", "MaterialGroup", "DesignCode",
            "LastUpdate", "LastUpdateBy", "Approver", "Notepad",
            "SpecialReqID", "TubePCS", "NewVDSSection"
        )
        SELECT
            p_plant_id,
            jt.PCS, jt.Revision, jt.Status, jt.RevDate,
            jt.RatingClass, jt.TestPressure, jt.MaterialGroup, jt.DesignCode,
            jt.LastUpdate, jt.LastUpdateBy, jt.Approver, jt.Notepad,
            jt.SpecialReqID, jt.TubePCS, jt.NewVDSSection
        FROM JSON_TABLE(v_json, '$.getPCS[*]'
                COLUMNS (
                    PCS VARCHAR2(100) PATH '$.PCS',
                    Revision VARCHAR2(50) PATH '$.Revision',
                    Status VARCHAR2(50) PATH '$.Status',
                    RevDate VARCHAR2(50) PATH '$.RevDate',
                    RatingClass VARCHAR2(100) PATH '$.RatingClass',
                    TestPressure VARCHAR2(50) PATH '$.TestPressure',
                    MaterialGroup VARCHAR2(100) PATH '$.MaterialGroup',
                    DesignCode VARCHAR2(100) PATH '$.DesignCode',
                    LastUpdate VARCHAR2(50) PATH '$.LastUpdate',
                    LastUpdateBy VARCHAR2(100) PATH '$.LastUpdateBy',
                    Approver VARCHAR2(100) PATH '$.Approver',
                    Notepad VARCHAR2(4000) PATH '$.Notepad',
                    SpecialReqID VARCHAR2(50) PATH '$.SpecialReqID',
                    TubePCS VARCHAR2(100) PATH '$.TubePCS',
                    NewVDSSection VARCHAR2(100) PATH '$.NewVDSSection'
                )
            ) jt;

        -- Step 4: Move from staging to core table with type conversion
        DELETE FROM PCS_LIST
        WHERE plant_id = p_plant_id;

        INSERT INTO PCS_LIST (
            pcs_list_guid, plant_id, pcs_name, revision, status, rev_date,
            rating_class, test_pressure, material_group, design_code,
            last_update, last_update_by, approver, notepad,
            special_req_id, tube_pcs, new_vds_section,
            created_date, last_modified_date
        )
        SELECT
            SYS_GUID(), plant_id, "PCS", "Revision", "Status",
            PKG_DATE_UTILS.safe_parse_date("RevDate"), "RatingClass",
            TO_NUMBER("TestPressure"), "MaterialGroup", "DesignCode",
            PKG_DATE_UTILS.safe_parse_date("LastUpdate"), "LastUpdateBy",
            "Approver", "Notepad", TO_NUMBER("SpecialReqID"),
            "TubePCS", "NewVDSSection", SYSDATE, SYSDATE
        FROM STG_PCS_LIST
        WHERE plant_id = p_plant_id
        AND "PCS" IS NOT NULL;

    EXCEPTION
        WHEN OTHERS THEN
            v_error_msg := 'Error in parse_and_load_pcs_list: ' || SQLERRM;
            PKG_ETL_LOGGING.log_error(
                p_endpoint_key => 'PCS_LIST',
                p_plant_id => p_plant_id,
                p_issue_revision => NULL,
                p_error_type => 'PROCESSING_ERROR',
                p_error_code => 'PCS_LIST_PARSE_ERROR',
                p_error_message => v_error_msg,
                p_raw_data => v_json
            );
            RAISE;
    END parse_and_load_pcs_list;

    -- =====================================================
    -- PARSE AND LOAD PCS DETAILS
    -- =====================================================
    PROCEDURE parse_and_load_pcs_details(
        p_raw_json_id IN NUMBER,
        p_plant_id IN VARCHAR2,
        p_pcs_name IN VARCHAR2,
        p_revision IN VARCHAR2,
        p_detail_type IN VARCHAR2
    ) IS
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Delegate to PKG_PCS_DETAIL_PROCESSOR which already has implementations
        PKG_PCS_DETAIL_PROCESSOR.process_pcs_detail(
            p_raw_json_id => p_raw_json_id,
            p_plant_id => p_plant_id,
            p_pcs_name => p_pcs_name,
            p_revision => p_revision,
            p_detail_type => p_detail_type
        );
    EXCEPTION
        WHEN OTHERS THEN
            v_error_msg := 'Error in parse_and_load_pcs_details: ' || SQLERRM;
            PKG_ETL_LOGGING.log_error(
                p_endpoint_key => 'PCS_DETAIL_' || UPPER(p_detail_type),
                p_plant_id => p_plant_id,
                p_issue_revision => NULL,
                p_error_type => 'PROCESSING_ERROR',
                p_error_code => 'PCS_DETAILS_PARSE_ERROR',
                p_error_message => v_error_msg
            );
            RAISE;
    END parse_and_load_pcs_details;

    -- =====================================================
    -- PARSE AND LOAD VDS CATALOG
    -- =====================================================
    PROCEDURE parse_and_load_vds_catalog(
        p_raw_json_id IN NUMBER
    ) IS
        v_json CLOB;
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Step 1: Get JSON from RAW_JSON
        SELECT payload INTO v_json
        FROM RAW_JSON
        WHERE raw_json_id = p_raw_json_id;

        -- Step 2: Clear staging table
        DELETE FROM STG_VDS_LIST;

        -- Step 3: Parse JSON to staging table - FIXED PATH: $.getVDS[*]
        INSERT INTO STG_VDS_LIST (
            "VDS", "Revision", "Status", "RevDate", "LastUpdate",
            "LastUpdateBy", "Description", "Notepad", "SpecialReqID",
            "ValveTypeID", "RatingClassID", "MaterialGroupID",
            "EndConnectionID", "BoreID", "VDSSizeID",
            "SizeRange", "CustomName", "SubsegmentList"
        )
        SELECT
            jt.VDS, jt.Revision, jt.Status, jt.RevDate, jt.LastUpdate,
            jt.LastUpdateBy, jt.Description, jt.Notepad, jt.SpecialReqID,
            jt.ValveTypeID, jt.RatingClassID, jt.MaterialGroupID,
            jt.EndConnectionID, jt.BoreID, jt.VDSSizeID,
            jt.SizeRange, jt.CustomName, jt.SubsegmentList
        FROM JSON_TABLE(v_json, '$.getVDS[*]'
                COLUMNS (
                    VDS VARCHAR2(100) PATH '$.VDS',
                    Revision VARCHAR2(50) PATH '$.Revision',
                    Status VARCHAR2(50) PATH '$.Status',
                    RevDate VARCHAR2(50) PATH '$.RevDate',
                    LastUpdate VARCHAR2(50) PATH '$.LastUpdate',
                    LastUpdateBy VARCHAR2(100) PATH '$.LastUpdateBy',
                    Description VARCHAR2(500) PATH '$.Description',
                    Notepad VARCHAR2(4000) PATH '$.Notepad',
                    SpecialReqID VARCHAR2(50) PATH '$.SpecialReqID',
                    ValveTypeID VARCHAR2(50) PATH '$.ValveTypeID',
                    RatingClassID VARCHAR2(50) PATH '$.RatingClassID',
                    MaterialGroupID VARCHAR2(50) PATH '$.MaterialGroupID',
                    EndConnectionID VARCHAR2(50) PATH '$.EndConnectionID',
                    BoreID VARCHAR2(50) PATH '$.BoreID',
                    VDSSizeID VARCHAR2(50) PATH '$.VDSSizeID',
                    SizeRange VARCHAR2(100) PATH '$.SizeRange',
                    CustomName VARCHAR2(200) PATH '$.CustomName',
                    SubsegmentList VARCHAR2(500) PATH '$.SubsegmentList'
                )
            ) jt;

        -- Step 4: Move from staging to core table with type conversion
        DELETE FROM VDS_LIST;

        INSERT INTO VDS_LIST (
            vds_list_guid, vds_name, revision, status, rev_date,
            last_update, last_update_by, description, notepad,
            special_req_id, valve_type_id, rating_class_id,
            material_group_id, end_connection_id, bore_id,
            vds_size_id, size_range, custom_name, subsegment_list,
            created_date, last_modified_date
        )
        SELECT
            SYS_GUID(), "VDS", "Revision", "Status",
            PKG_DATE_UTILS.safe_parse_date("RevDate"),
            PKG_DATE_UTILS.safe_parse_date("LastUpdate"),
            "LastUpdateBy", "Description", "Notepad",
            TO_NUMBER("SpecialReqID"), TO_NUMBER("ValveTypeID"),
            TO_NUMBER("RatingClassID"), TO_NUMBER("MaterialGroupID"),
            TO_NUMBER("EndConnectionID"), TO_NUMBER("BoreID"),
            TO_NUMBER("VDSSizeID"), "SizeRange", "CustomName",
            "SubsegmentList", SYSDATE, SYSDATE
        FROM STG_VDS_LIST
        WHERE "VDS" IS NOT NULL;

    EXCEPTION
        WHEN OTHERS THEN
            v_error_msg := 'Error in parse_and_load_vds_catalog: ' || SQLERRM;
            PKG_ETL_LOGGING.log_error(
                p_endpoint_key => 'VDS_CATALOG',
                p_plant_id => NULL,
                p_issue_revision => NULL,
                p_error_type => 'PROCESSING_ERROR',
                p_error_code => 'VDS_CATALOG_PARSE_ERROR',
                p_error_message => v_error_msg,
                p_raw_data => v_json
            );
            RAISE;
    END parse_and_load_vds_catalog;

END PKG_ETL_PROCESSOR;
/


  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "TR2000_STAGING"."PKG_ETL_TEST_UTILS" AS

    PROCEDURE clear_all_logs IS
    BEGIN
        DELETE FROM ETL_ERROR_LOG;
        DELETE FROM ETL_RUN_LOG;
        DELETE FROM ETL_STATISTICS;
        COMMIT;
    END;

    PROCEDURE clear_all_data IS
    BEGIN
        -- Clear core tables
        DELETE FROM PCS_REFERENCES;
        DELETE FROM VDS_REFERENCES;
        DELETE FROM MDS_REFERENCES;
        DELETE FROM EDS_REFERENCES;
        DELETE FROM VSK_REFERENCES;
        DELETE FROM ESK_REFERENCES;
        DELETE FROM PIPE_ELEMENT_REFERENCES;
        DELETE FROM SC_REFERENCES;
        DELETE FROM VSM_REFERENCES;
        DELETE FROM PCS_LIST;
        DELETE FROM PCS_HEADER_PROPERTIES;
        DELETE FROM PCS_TEMP_PRESSURES;
        DELETE FROM PCS_PIPE_SIZES;
        DELETE FROM PCS_PIPE_ELEMENTS;
        DELETE FROM PCS_VALVE_ELEMENTS;
        DELETE FROM PCS_EMBEDDED_NOTES;
        DELETE FROM VDS_LIST;

        -- Clear staging tables
        DELETE FROM STG_PCS_REFERENCES;
        DELETE FROM STG_VDS_REFERENCES;
        DELETE FROM STG_MDS_REFERENCES;
        DELETE FROM STG_EDS_REFERENCES;
        DELETE FROM STG_VSK_REFERENCES;
        DELETE FROM STG_ESK_REFERENCES;
        DELETE FROM STG_PIPE_ELEMENT_REFERENCES;
        DELETE FROM STG_SC_REFERENCES;
        DELETE FROM STG_VSM_REFERENCES;
        DELETE FROM STG_PCS_LIST;
        DELETE FROM STG_VDS_LIST;
        DELETE FROM STG_PCS_HEADER_PROPERTIES;
        DELETE FROM STG_PCS_TEMP_PRESSURES;
        DELETE FROM STG_PCS_PIPE_SIZES;
        DELETE FROM STG_PCS_PIPE_ELEMENTS;
        DELETE FROM STG_PCS_VALVE_ELEMENTS;
        DELETE FROM STG_PCS_EMBEDDED_NOTES;

        COMMIT;
    END;

    PROCEDURE clear_raw_json IS
    BEGIN
        DELETE FROM RAW_JSON;
        COMMIT;
    END;

    PROCEDURE reset_for_testing IS
    BEGIN
        clear_all_data;
        clear_all_logs;
        clear_raw_json;
    END;

    PROCEDURE generate_test_filter IS
    BEGIN
        DELETE FROM ETL_FILTER;
        INSERT INTO ETL_FILTER (plant_id, plant_name, issue_revision, added_by_user_id)
        VALUES ('34', 'GRANE', '4.2', 'TEST_USER');
        COMMIT;
    END;

    PROCEDURE show_etl_status IS
        v_count NUMBER;
    BEGIN
        DBMS_OUTPUT.PUT_LINE('=== ETL STATUS REPORT ===');

        SELECT COUNT(*) INTO v_count FROM ETL_FILTER;
        DBMS_OUTPUT.PUT_LINE('ETL_FILTER: ' || v_count);

        SELECT COUNT(*) INTO v_count FROM RAW_JSON;
        DBMS_OUTPUT.PUT_LINE('RAW_JSON: ' || v_count);

        SELECT COUNT(*) INTO v_count FROM PCS_REFERENCES;
        DBMS_OUTPUT.PUT_LINE('PCS_REFERENCES: ' || v_count);

        SELECT COUNT(*) INTO v_count FROM VDS_REFERENCES;
        DBMS_OUTPUT.PUT_LINE('VDS_REFERENCES: ' || v_count);

        -- Check if any staging tables have data
        SELECT COUNT(*) INTO v_count FROM STG_PCS_REFERENCES;
        IF v_count > 0 THEN
            DBMS_OUTPUT.PUT_LINE('WARNING: STG_PCS_REFERENCES has ' || v_count || ' records');
        END IF;

        DBMS_OUTPUT.PUT_LINE('========================');
    END;

    PROCEDURE validate_data_integrity IS
    BEGIN
        DBMS_OUTPUT.PUT_LINE('Data integrity check complete');
    END;

    PROCEDURE quick_test_run(
        p_plant_id VARCHAR2 DEFAULT '34',
        p_issue_revision VARCHAR2 DEFAULT '4.2'
    ) IS
    BEGIN
        reset_for_testing;
        DELETE FROM ETL_FILTER;
        INSERT INTO ETL_FILTER (plant_id, plant_name, issue_revision, added_by_user_id)
        VALUES (p_plant_id, 'TEST_PLANT', p_issue_revision, 'TEST_USER');
        COMMIT;
        show_etl_status;
    END;

END PKG_ETL_TEST_UTILS;
/


  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "TR2000_STAGING"."PKG_INDEPENDENT_ETL_CONTROL" AS

    -- Clear VDS catalog data
    PROCEDURE clear_vds_catalog IS
        v_run_id NUMBER;
        v_count NUMBER;
    BEGIN
        v_run_id := PKG_ETL_LOGGING.get_current_run_id;

        DELETE FROM VDS_LIST;
        v_count := SQL%ROWCOUNT;

        PKG_ETL_LOGGING.log_clear_operation(
            p_run_id => NVL(v_run_id, 0),
            p_table_name => 'VDS_LIST',
            p_records_deleted => v_count
        );

        EXECUTE IMMEDIATE 'TRUNCATE TABLE STG_VDS_LIST';

        COMMIT;
    END clear_vds_catalog;

    -- Get VDS catalog statistics
    FUNCTION get_vds_catalog_stats RETURN VARCHAR2 IS
        v_count NUMBER;
        v_last_update DATE;
    BEGIN
        SELECT COUNT(*), MAX(last_modified_date)
        INTO v_count, v_last_update
        FROM VDS_LIST;

        RETURN 'VDS Catalog: ' || v_count || ' items, Last Update: ' ||
               NVL(TO_CHAR(v_last_update, 'YYYY-MM-DD HH24:MI:SS'), 'Never');
    END get_vds_catalog_stats;

    -- Run VDS catalog ETL
    PROCEDURE run_vds_catalog_etl IS
        v_run_id NUMBER;
        v_stat_id NUMBER;
        v_api_stat_id NUMBER;
        v_raw_json_id NUMBER;
        v_start_time TIMESTAMP;
        v_response_size NUMBER;
        v_records_count NUMBER;
        v_error_msg VARCHAR2(4000);
    BEGIN
        -- Start ETL run
        v_run_id := PKG_ETL_LOGGING.start_etl_run(
            p_run_type => 'VDS_CATALOG_ETL'
        );

        v_stat_id := PKG_ETL_LOGGING.log_operation_start(
            p_run_id => v_run_id,
            p_stat_type => 'PROCESSING',
            p_operation_name => 'VDS_CATALOG_FULL_LOAD'
        );

        BEGIN
            -- Clear existing VDS data
            clear_vds_catalog;

            -- Log API call start
            v_start_time := SYSTIMESTAMP;
            v_api_stat_id := PKG_ETL_LOGGING.log_operation_start(
                p_run_id => v_run_id,
                p_stat_type => 'API_CALL',
                p_endpoint_key => 'VDS_CATALOG',
                p_operation_name => 'fetch_vds_catalog'
            );

            -- Fetch VDS catalog from API
            v_raw_json_id := PKG_API_CLIENT.fetch_vds_catalog(
                p_batch_id => 'VDS_RUN_' || v_run_id
            );

            -- Get response size
            SELECT LENGTH(payload) INTO v_response_size
            FROM RAW_JSON WHERE raw_json_id = v_raw_json_id;

            -- Log API call success
            PKG_ETL_LOGGING.log_operation_end(
                p_stat_id => v_api_stat_id,
                p_status => 'SUCCESS',
                p_api_response_size => v_response_size,
                p_api_status_code => 200
            );

            -- Also log as quick API call for statistics
            PKG_ETL_LOGGING.log_api_call(
                p_run_id => v_run_id,
                p_endpoint_key => 'VDS_CATALOG',
                p_duration_ms => EXTRACT(SECOND FROM (SYSTIMESTAMP - v_start_time)) * 1000,
                p_response_size => v_response_size,
                p_status_code => 200,
                p_status => 'SUCCESS'
            );

            -- Parse and load VDS data
            v_start_time := SYSTIMESTAMP;
            v_api_stat_id := PKG_ETL_LOGGING.log_operation_start(
                p_run_id => v_run_id,
                p_stat_type => 'PROCESSING',
                p_endpoint_key => 'VDS_CATALOG',
                p_operation_name => 'parse_and_load_vds_catalog'
            );

            PKG_ETL_PROCESSOR.parse_and_load_vds_catalog(v_raw_json_id);

            -- Get record count
            SELECT COUNT(*) INTO v_records_count FROM VDS_LIST;

            PKG_ETL_LOGGING.log_operation_end(
                p_stat_id => v_api_stat_id,
                p_status => 'SUCCESS',
                p_records_processed => v_records_count,
                p_records_inserted => v_records_count
            );

            -- Log overall success
            PKG_ETL_LOGGING.log_operation_end(
                p_stat_id => v_stat_id,
                p_status => 'SUCCESS',
                p_records_processed => v_records_count,
                p_error_message => 'Successfully loaded ' || v_records_count || ' VDS items'
            );

            -- End run successfully
            PKG_ETL_LOGGING.end_etl_run(v_run_id, 'SUCCESS');

            -- Output summary
            DBMS_OUTPUT.PUT_LINE('VDS Catalog ETL completed successfully');
            DBMS_OUTPUT.PUT_LINE('Records loaded: ' || v_records_count);
            DBMS_OUTPUT.PUT_LINE('Response size: ' || ROUND(v_response_size/1024/1024, 2) || ' MB');

        EXCEPTION
            WHEN OTHERS THEN
                v_error_msg := SQLERRM;

                -- Log operation failures
                IF v_api_stat_id IS NOT NULL THEN
                    PKG_ETL_LOGGING.log_operation_end(
                        p_stat_id => v_api_stat_id,
                        p_status => 'FAILED',
                        p_error_message => v_error_msg
                    );
                END IF;

                PKG_ETL_LOGGING.log_operation_end(
                    p_stat_id => v_stat_id,
                    p_status => 'FAILED',
                    p_error_message => v_error_msg
                );

                -- Log error
                PKG_ETL_LOGGING.log_error(
                    p_endpoint_key => 'VDS_CATALOG',
                    p_error_type => 'VDS_ETL_ERROR',
                    p_error_message => v_error_msg,
                    p_error_stack => DBMS_UTILITY.FORMAT_ERROR_STACK
                );

                -- End run as failed
                PKG_ETL_LOGGING.end_etl_run(v_run_id, 'FAILED');

                DBMS_OUTPUT.PUT_LINE('VDS Catalog ETL failed: ' || v_error_msg);
                RAISE;
        END;
    END run_vds_catalog_etl;

END PKG_INDEPENDENT_ETL_CONTROL;
/


  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "TR2000_STAGING"."PKG_MAIN_ETL_CONTROL" AS

    PROCEDURE run_main_etl IS
        v_batch_id VARCHAR2(50);
        v_run_id NUMBER;
        v_error_msg VARCHAR2(4000);
    BEGIN
        v_batch_id := 'FULL_ETL_' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS');

        v_run_id := PKG_ETL_LOGGING.start_etl_run(
            p_run_type => 'FULL_ETL',
            p_initiated_by => USER
        );
        PKG_ETL_LOGGING.set_current_run_id(v_run_id);

        DBMS_OUTPUT.PUT_LINE('Starting full ETL run');
        DBMS_OUTPUT.PUT_LINE('Batch ID: ' || v_batch_id);
        DBMS_OUTPUT.PUT_LINE('Run ID: ' || v_run_id);

        -- CRITICAL FIX: Clear all data tables at start
        DBMS_OUTPUT.PUT_LINE('Clearing all data tables...');
        PKG_ETL_TEST_UTILS.clear_all_data();
        DBMS_OUTPUT.PUT_LINE('Data tables cleared');

        FOR rec IN (SELECT DISTINCT plant_id, issue_revision FROM ETL_FILTER) LOOP
            DBMS_OUTPUT.PUT_LINE('Processing references for Plant: ' || rec.plant_id || ', Issue: ' || rec.issue_revision);
            process_references_for_issue(rec.plant_id, rec.issue_revision);
        END LOOP;

        FOR rec IN (SELECT DISTINCT plant_id FROM ETL_FILTER) LOOP
            DBMS_OUTPUT.PUT_LINE('Processing PCS list for Plant: ' || rec.plant_id);
            process_pcs_list(rec.plant_id);
        END LOOP;

        DBMS_OUTPUT.PUT_LINE('Processing PCS details...');
        process_pcs_details;

        PKG_ETL_LOGGING.end_etl_run(
            p_run_id => v_run_id,
            p_status => 'SUCCESS'
        );

        DBMS_OUTPUT.PUT_LINE('Full ETL completed');

    EXCEPTION
        WHEN OTHERS THEN
            v_error_msg := SQLERRM;

            PKG_ETL_LOGGING.end_etl_run(
                p_run_id => v_run_id,
                p_status => 'FAILED'
            );

            PKG_ETL_LOGGING.log_error(
                p_endpoint_key => 'FULL_ETL',
                p_plant_id => NULL,
                p_issue_revision => NULL,
                p_error_type => 'ETL_ERROR',
                p_error_code => 'FULL_ETL_FAILED',
                p_error_message => v_error_msg
            );

            DBMS_OUTPUT.PUT_LINE('Full ETL failed: ' || v_error_msg);
            RAISE;
    END run_main_etl;

    PROCEDURE process_references_for_issue(
        p_plant_id VARCHAR2,
        p_issue_revision VARCHAR2
    ) IS
        v_batch_id VARCHAR2(50);
        v_count NUMBER := 0;
        v_raw_json_id NUMBER;
        v_records_processed NUMBER;
        v_run_id NUMBER;
        v_stat_id NUMBER;
    BEGIN
        v_batch_id := 'REF_' || p_plant_id || '_' || p_issue_revision || '_' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS');
        v_run_id := PKG_ETL_LOGGING.get_current_run_id;

        -- No need to DELETE - tables already cleared in run_main_etl

        FOR ref_type IN (
            SELECT 'PCS' as ref_type FROM dual UNION ALL
            SELECT 'VDS' FROM dual UNION ALL
            SELECT 'MDS' FROM dual UNION ALL
            SELECT 'EDS' FROM dual UNION ALL
            SELECT 'VSK' FROM dual UNION ALL
            SELECT 'ESK' FROM dual UNION ALL
            SELECT 'PIPE_ELEMENT' FROM dual UNION ALL
            SELECT 'SC' FROM dual UNION ALL
            SELECT 'VSM' FROM dual
        ) LOOP
            v_raw_json_id := PKG_API_CLIENT.fetch_reference_data(
                p_plant_id => p_plant_id,
                p_issue_revision => p_issue_revision,
                p_ref_type => ref_type.ref_type,
                p_batch_id => v_batch_id
            );

            v_count := v_count + 1;

            IF ref_type.ref_type = 'PCS' THEN
                PKG_ETL_PROCESSOR.parse_and_load_pcs_references(
                    p_raw_json_id => v_raw_json_id,
                    p_plant_id => p_plant_id,
                    p_issue_revision => p_issue_revision
                );
                SELECT COUNT(*) INTO v_records_processed FROM PCS_REFERENCES
                WHERE plant_id = p_plant_id AND issue_revision = p_issue_revision;

            ELSIF ref_type.ref_type = 'VDS' THEN
                PKG_ETL_PROCESSOR.parse_and_load_vds_references(
                    p_raw_json_id => v_raw_json_id,
                    p_plant_id => p_plant_id,
                    p_issue_revision => p_issue_revision
                );
                SELECT COUNT(*) INTO v_records_processed FROM VDS_REFERENCES
                WHERE plant_id = p_plant_id AND issue_revision = p_issue_revision;

            ELSIF ref_type.ref_type = 'MDS' THEN
                PKG_ETL_PROCESSOR.parse_and_load_mds_references(
                    p_raw_json_id => v_raw_json_id,
                    p_plant_id => p_plant_id,
                    p_issue_revision => p_issue_revision
                );
                SELECT COUNT(*) INTO v_records_processed FROM MDS_REFERENCES
                WHERE plant_id = p_plant_id AND issue_revision = p_issue_revision;

            ELSIF ref_type.ref_type = 'EDS' THEN
                PKG_ETL_PROCESSOR.parse_and_load_eds_references(
                    p_raw_json_id => v_raw_json_id,
                    p_plant_id => p_plant_id,
                    p_issue_revision => p_issue_revision
                );
                SELECT COUNT(*) INTO v_records_processed FROM EDS_REFERENCES
                WHERE plant_id = p_plant_id AND issue_revision = p_issue_revision;

            ELSIF ref_type.ref_type = 'VSK' THEN
                PKG_ETL_PROCESSOR.parse_and_load_vsk_references(
                    p_raw_json_id => v_raw_json_id,
                    p_plant_id => p_plant_id,
                    p_issue_revision => p_issue_revision
                );
                SELECT COUNT(*) INTO v_records_processed FROM VSK_REFERENCES
                WHERE plant_id = p_plant_id AND issue_revision = p_issue_revision;

            ELSIF ref_type.ref_type = 'ESK' THEN
                PKG_ETL_PROCESSOR.parse_and_load_esk_references(
                    p_raw_json_id => v_raw_json_id,
                    p_plant_id => p_plant_id,
                    p_issue_revision => p_issue_revision
                );
                SELECT COUNT(*) INTO v_records_processed FROM ESK_REFERENCES
                WHERE plant_id = p_plant_id AND issue_revision = p_issue_revision;

            ELSIF ref_type.ref_type = 'PIPE_ELEMENT' THEN
                PKG_ETL_PROCESSOR.parse_and_load_pipe_element_references(
                    p_raw_json_id => v_raw_json_id,
                    p_plant_id => p_plant_id,
                    p_issue_revision => p_issue_revision
                );
                SELECT COUNT(*) INTO v_records_processed FROM PIPE_ELEMENT_REFERENCES
                WHERE plant_id = p_plant_id AND issue_revision = p_issue_revision;

            ELSIF ref_type.ref_type = 'SC' THEN
                PKG_ETL_PROCESSOR.parse_and_load_sc_references(
                    p_raw_json_id => v_raw_json_id,
                    p_plant_id => p_plant_id,
                    p_issue_revision => p_issue_revision
                );
                SELECT COUNT(*) INTO v_records_processed FROM SC_REFERENCES
                WHERE plant_id = p_plant_id AND issue_revision = p_issue_revision;

            ELSIF ref_type.ref_type = 'VSM' THEN
                PKG_ETL_PROCESSOR.parse_and_load_vsm_references(
                    p_raw_json_id => v_raw_json_id,
                    p_plant_id => p_plant_id,
                    p_issue_revision => p_issue_revision
                );
                SELECT COUNT(*) INTO v_records_processed FROM VSM_REFERENCES
                WHERE plant_id = p_plant_id AND issue_revision = p_issue_revision;
            END IF;
        END LOOP;

        DBMS_OUTPUT.PUT_LINE('Processed ' || v_count || ' reference types');
        COMMIT;
    END process_references_for_issue;

    PROCEDURE process_pcs_list(
        p_plant_id VARCHAR2
    ) IS
        v_batch_id VARCHAR2(50);
        v_raw_json_id NUMBER;
        v_run_id NUMBER;
        v_stat_id NUMBER;
        v_records_count NUMBER;
    BEGIN
        v_batch_id := 'PCS_LIST_' || p_plant_id || '_' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS');
        v_run_id := PKG_ETL_LOGGING.get_current_run_id;

        v_raw_json_id := PKG_API_CLIENT.fetch_pcs_list(
            p_plant_id => p_plant_id,
            p_batch_id => v_batch_id
        );

        PKG_ETL_PROCESSOR.parse_and_load_pcs_list(
            p_raw_json_id => v_raw_json_id,
            p_plant_id => p_plant_id
        );

        DBMS_OUTPUT.PUT_LINE('PCS list processed');
        COMMIT;
    END process_pcs_list;

    PROCEDURE process_pcs_details IS
        v_batch_id VARCHAR2(50);
        v_count NUMBER := 0;
        v_max_pcs_details NUMBER;
        v_raw_json_id NUMBER;
        v_run_id NUMBER;
        v_stat_id NUMBER;
        v_base_url VARCHAR2(500);
    BEGIN
        SELECT setting_value INTO v_max_pcs_details
        FROM CONTROL_SETTINGS
        WHERE setting_key = 'MAX_PCS_DETAILS_PER_RUN';

        SELECT setting_value INTO v_base_url
        FROM CONTROL_SETTINGS
        WHERE setting_key = 'API_BASE_URL';

        DBMS_OUTPUT.PUT_LINE('Processing PCS details for OFFICIAL revisions only...');
        DBMS_OUTPUT.PUT_LINE('Max PCS details per run: ' || v_max_pcs_details);

        v_batch_id := 'PCS_DETAILS_' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS');
        v_run_id := PKG_ETL_LOGGING.get_current_run_id;

        -- CRITICAL FIX: Only process official revisions from PCS_REFERENCES
        FOR rec IN (
            SELECT DISTINCT
                r.plant_id,
                r.pcs_name,
                r.official_revision as revision  -- Use OFFICIAL_REVISION
            FROM PCS_REFERENCES r
            WHERE r.official_revision IS NOT NULL
            -- Ensure the official revision exists in PCS_LIST
            AND EXISTS (
                SELECT 1 FROM PCS_LIST l
                WHERE l.plant_id = r.plant_id
                  AND l.pcs_name = r.pcs_name
                  AND l.revision = r.official_revision
            )
            AND ROWNUM <= CASE
                WHEN v_max_pcs_details = 0 THEN 999999
                ELSE v_max_pcs_details
            END
        ) LOOP
            DBMS_OUTPUT.PUT_LINE('Processing PCS: ' || rec.pcs_name || ' Official Rev: ' || rec.revision);

            FOR detail_type IN (
                SELECT 'header-properties' as dtype FROM dual UNION ALL
                SELECT 'temp-pressures' FROM dual UNION ALL
                SELECT 'pipe-sizes' FROM dual UNION ALL
                SELECT 'pipe-elements' FROM dual UNION ALL
                SELECT 'valve-elements' FROM dual UNION ALL
                SELECT 'embedded-notes' FROM dual
            ) LOOP
                v_raw_json_id := PKG_API_CLIENT.fetch_pcs_detail(
                    p_plant_id => rec.plant_id,
                    p_pcs_name => rec.pcs_name,
                    p_revision => rec.revision,  -- Official revision
                    p_detail_type => detail_type.dtype,
                    p_batch_id => v_batch_id
                );

                PKG_PCS_DETAIL_PROCESSOR.process_pcs_detail(
                    p_raw_json_id => v_raw_json_id,
                    p_plant_id => rec.plant_id,
                    p_pcs_name => rec.pcs_name,
                    p_revision => rec.revision,  -- Official revision
                    p_detail_type => detail_type.dtype
                );
            END LOOP;

            v_count := v_count + 1;
        END LOOP;

        DBMS_OUTPUT.PUT_LINE('PCS details completed. Processed: ' || v_count || ' official PCS revisions');
        DBMS_OUTPUT.PUT_LINE('Total API calls: ' || (v_count * 6));
        COMMIT;
    END process_pcs_details;

END PKG_MAIN_ETL_CONTROL;
/


  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "TR2000_STAGING"."PKG_PCS_DETAIL_PROCESSOR" AS

    PROCEDURE process_pcs_detail(
        p_raw_json_id   IN NUMBER,
        p_plant_id      IN VARCHAR2,
        p_pcs_name      IN VARCHAR2,
        p_revision      IN VARCHAR2,
        p_detail_type   IN VARCHAR2
    ) IS
        v_json CLOB;
        v_upper_type VARCHAR2(50);
        v_error_msg VARCHAR2(4000);
        v_error_code VARCHAR2(50);
    BEGIN
        -- API → RAW_JSON (get the JSON payload)
        SELECT payload INTO v_json
        FROM RAW_JSON
        WHERE raw_json_id = p_raw_json_id;

        v_upper_type := UPPER(REPLACE(p_detail_type, '-', '_'));

        -- Process based on detail type
        IF v_upper_type IN ('HEADER_PROPERTIES', 'PCS_HEADER_PROPERTIES', 'PCS_HEADER', 'HEADER') THEN
            -- ===== HEADER_PROPERTIES Handler =====
            -- RAW_JSON → STG_PCS_HEADER_PROPERTIES
            -- No DELETE needed - tables cleared at ETL start

            INSERT INTO STG_PCS_HEADER_PROPERTIES (
                plant_id, pcs_name, pcs_revision,
                "PCS", "Revision", "Status", "RevDate",
                "RatingClass", "TestPressure", "MaterialGroup", "DesignCode",
                "LastUpdate", "LastUpdateBy", "Approver", "Notepad",
                "SC", "VSM", "DesignCodeRevMark",
                "CorrAllowance", "CorrAllowanceRevMark",
                "LongWeldEff", "LongWeldEffRevMark",
                "WallThkTol", "WallThkTolRevMark",
                "ServiceRemark", "ServiceRemarkRevMark",
                "DesignPress01", "DesignPress02", "DesignPress03", "DesignPress04",
                "DesignPress05", "DesignPress06", "DesignPress07", "DesignPress08",
                "DesignPress09", "DesignPress10", "DesignPress11", "DesignPress12",
                "DesignPressRevMark",
                "DesignTemp01", "DesignTemp02", "DesignTemp03", "DesignTemp04",
                "DesignTemp05", "DesignTemp06", "DesignTemp07", "DesignTemp08",
                "DesignTemp09", "DesignTemp10", "DesignTemp11", "DesignTemp12",
                "DesignTempRevMark",
                "NoteIDCorrAllowance", "NoteIDServiceCode", "NoteIDWallThkTol",
                "NoteIDLongWeldEff", "NoteIDGeneralPCS", "NoteIDDesignCode",
                "NoteIDPressTempTable", "NoteIDPipeSizeWthTable",
                "PressElementChange", "TempElementChange",
                "MaterialGroupID", "SpecialReqID", "SpecialReq",
                "NewVDSSection", "TubePCS", "EDSMJMatrix", "MJReductionFactor"
            )
            SELECT
                p_plant_id, p_pcs_name, p_revision,
                jt.PCS, jt.Revision, jt.Status, jt.RevDate,
                jt.RatingClass, jt.TestPressure, jt.MaterialGroup, jt.DesignCode,
                jt.LastUpdate, jt.LastUpdateBy, jt.Approver, jt.Notepad,
                jt.SC, jt.VSM, jt.DesignCodeRevMark,
                jt.CorrAllowance, jt.CorrAllowanceRevMark,
                jt.LongWeldEff, jt.LongWeldEffRevMark,
                jt.WallThkTol, jt.WallThkTolRevMark,
                jt.ServiceRemark, jt.ServiceRemarkRevMark,
                jt.DesignPress01, jt.DesignPress02, jt.DesignPress03, jt.DesignPress04,
                jt.DesignPress05, jt.DesignPress06, jt.DesignPress07, jt.DesignPress08,
                jt.DesignPress09, jt.DesignPress10, jt.DesignPress11, jt.DesignPress12,
                jt.DesignPressRevMark,
                jt.DesignTemp01, jt.DesignTemp02, jt.DesignTemp03, jt.DesignTemp04,
                jt.DesignTemp05, jt.DesignTemp06, jt.DesignTemp07, jt.DesignTemp08,
                jt.DesignTemp09, jt.DesignTemp10, jt.DesignTemp11, jt.DesignTemp12,
                jt.DesignTempRevMark,
                jt.NoteIDCorrAllowance, jt.NoteIDServiceCode, jt.NoteIDWallThkTol,
                jt.NoteIDLongWeldEff, jt.NoteIDGeneralPCS, jt.NoteIDDesignCode,
                jt.NoteIDPressTempTable, jt.NoteIDPipeSizeWthTable,
                jt.PressElementChange, jt.TempElementChange,
                jt.MaterialGroupID, jt.SpecialReqID, jt.SpecialReq,
                jt.NewVDSSection, jt.TubePCS, jt.EDSMJMatrix, jt.MJReductionFactor
            FROM JSON_TABLE(v_json, '$.getPCS[*]'
                COLUMNS (
                    PCS VARCHAR2(100) PATH '$.PCS',
                    Revision VARCHAR2(50) PATH '$.Revision',
                    Status VARCHAR2(50) PATH '$.Status',
                    RevDate VARCHAR2(50) PATH '$.RevDate',
                    RatingClass VARCHAR2(100) PATH '$.RatingClass',
                    TestPressure VARCHAR2(50) PATH '$.TestPressure',
                    MaterialGroup VARCHAR2(100) PATH '$.MaterialGroup',
                    DesignCode VARCHAR2(100) PATH '$.DesignCode',
                    LastUpdate VARCHAR2(50) PATH '$.LastUpdate',
                    LastUpdateBy VARCHAR2(100) PATH '$.LastUpdateBy',
                    Approver VARCHAR2(100) PATH '$.Approver',
                    Notepad VARCHAR2(4000) PATH '$.Notepad',
                    SC VARCHAR2(100) PATH '$.SC',
                    VSM VARCHAR2(100) PATH '$.VSM',
                    DesignCodeRevMark VARCHAR2(50) PATH '$.DesignCodeRevMark',
                    CorrAllowance VARCHAR2(50) PATH '$.CorrAllowance',
                    CorrAllowanceRevMark VARCHAR2(50) PATH '$.CorrAllowanceRevMark',
                    LongWeldEff VARCHAR2(50) PATH '$.LongWeldEff',
                    LongWeldEffRevMark VARCHAR2(50) PATH '$.LongWeldEffRevMark',
                    WallThkTol VARCHAR2(50) PATH '$.WallThkTol',
                    WallThkTolRevMark VARCHAR2(50) PATH '$.WallThkTolRevMark',
                    ServiceRemark VARCHAR2(500) PATH '$.ServiceRemark',
                    ServiceRemarkRevMark VARCHAR2(50) PATH '$.ServiceRemarkRevMark',
                    DesignPress01 VARCHAR2(50) PATH '$.DesignPress01',
                    DesignPress02 VARCHAR2(50) PATH '$.DesignPress02',
                    DesignPress03 VARCHAR2(50) PATH '$.DesignPress03',
                    DesignPress04 VARCHAR2(50) PATH '$.DesignPress04',
                    DesignPress05 VARCHAR2(50) PATH '$.DesignPress05',
                    DesignPress06 VARCHAR2(50) PATH '$.DesignPress06',
                    DesignPress07 VARCHAR2(50) PATH '$.DesignPress07',
                    DesignPress08 VARCHAR2(50) PATH '$.DesignPress08',
                    DesignPress09 VARCHAR2(50) PATH '$.DesignPress09',
                    DesignPress10 VARCHAR2(50) PATH '$.DesignPress10',
                    DesignPress11 VARCHAR2(50) PATH '$.DesignPress11',
                    DesignPress12 VARCHAR2(50) PATH '$.DesignPress12',
                    DesignPressRevMark VARCHAR2(50) PATH '$.DesignPressRevMark',
                    DesignTemp01 VARCHAR2(50) PATH '$.DesignTemp01',
                    DesignTemp02 VARCHAR2(50) PATH '$.DesignTemp02',
                    DesignTemp03 VARCHAR2(50) PATH '$.DesignTemp03',
                    DesignTemp04 VARCHAR2(50) PATH '$.DesignTemp04',
                    DesignTemp05 VARCHAR2(50) PATH '$.DesignTemp05',
                    DesignTemp06 VARCHAR2(50) PATH '$.DesignTemp06',
                    DesignTemp07 VARCHAR2(50) PATH '$.DesignTemp07',
                    DesignTemp08 VARCHAR2(50) PATH '$.DesignTemp08',
                    DesignTemp09 VARCHAR2(50) PATH '$.DesignTemp09',
                    DesignTemp10 VARCHAR2(50) PATH '$.DesignTemp10',
                    DesignTemp11 VARCHAR2(50) PATH '$.DesignTemp11',
                    DesignTemp12 VARCHAR2(50) PATH '$.DesignTemp12',
                    DesignTempRevMark VARCHAR2(50) PATH '$.DesignTempRevMark',
                    NoteIDCorrAllowance VARCHAR2(50) PATH '$.NoteIDCorrAllowance',
                    NoteIDServiceCode VARCHAR2(50) PATH '$.NoteIDServiceCode',
                    NoteIDWallThkTol VARCHAR2(50) PATH '$.NoteIDWallThkTol',
                    NoteIDLongWeldEff VARCHAR2(50) PATH '$.NoteIDLongWeldEff',
                    NoteIDGeneralPCS VARCHAR2(50) PATH '$.NoteIDGeneralPCS',
                    NoteIDDesignCode VARCHAR2(50) PATH '$.NoteIDDesignCode',
                    NoteIDPressTempTable VARCHAR2(50) PATH '$.NoteIDPressTempTable',
                    NoteIDPipeSizeWthTable VARCHAR2(50) PATH '$.NoteIDPipeSizeWthTable',
                    PressElementChange VARCHAR2(50) PATH '$.PressElementChange',
                    TempElementChange VARCHAR2(50) PATH '$.TempElementChange',
                    MaterialGroupID VARCHAR2(50) PATH '$.MaterialGroupID',
                    SpecialReqID VARCHAR2(50) PATH '$.SpecialReqID',
                    SpecialReq VARCHAR2(500) PATH '$.SpecialReq',
                    NewVDSSection VARCHAR2(100) PATH '$.NewVDSSection',
                    TubePCS VARCHAR2(100) PATH '$.TubePCS',
                    EDSMJMatrix VARCHAR2(100) PATH '$.EDSMJMatrix',
                    MJReductionFactor VARCHAR2(50) PATH '$.MJReductionFactor'
                )) jt;

            -- STG_* → Core Table PCS_HEADER_PROPERTIES
            -- No DELETE needed - tables cleared at ETL start

            INSERT INTO PCS_HEADER_PROPERTIES (
                pcs_header_properties_guid, plant_id, pcs_name, pcs_revision,
                pcs, revision, status, rev_date,
                rating_class, test_pressure, material_group, design_code,
                last_update, last_update_by, approver, notepad,
                sc, vsm, design_code_rev_mark,
                corr_allowance, corr_allowance_rev_mark,
                long_weld_eff, long_weld_eff_rev_mark,
                wall_thk_tol, wall_thk_tol_rev_mark,
                service_remark, service_remark_rev_mark,
                design_press01, design_press02, design_press03, design_press04,
                design_press05, design_press06, design_press07, design_press08,
                design_press09, design_press10, design_press11, design_press12,
                design_press_rev_mark,
                design_temp01, design_temp02, design_temp03, design_temp04,
                design_temp05, design_temp06, design_temp07, design_temp08,
                design_temp09, design_temp10, design_temp11, design_temp12,
                design_temp_rev_mark,
                note_id_corr_allowance, note_id_service_code, note_id_wall_thk_tol,
                note_id_long_weld_eff, note_id_general_pcs, note_id_design_code,
                note_id_press_temp_table, note_id_pipe_size_wth_table,
                press_element_change, temp_element_change,
                material_group_id, special_req_id, special_req,
                new_vds_section, tube_pcs, eds_mj_matrix, mj_reduction_factor,
                created_date, last_modified_date
            )
            SELECT
                SYS_GUID(), plant_id, pcs_name, pcs_revision,
                "PCS", "Revision", "Status", PKG_DATE_UTILS.safe_parse_date("RevDate"),
                "RatingClass", safe_to_number("TestPressure"), "MaterialGroup", "DesignCode",
                PKG_DATE_UTILS.safe_parse_date("LastUpdate"), "LastUpdateBy", "Approver", "Notepad",
                "SC", "VSM", "DesignCodeRevMark",
                safe_to_number("CorrAllowance"), "CorrAllowanceRevMark",
                safe_to_number("LongWeldEff"), "LongWeldEffRevMark",
                "WallThkTol", "WallThkTolRevMark",
                "ServiceRemark", "ServiceRemarkRevMark",
                safe_to_number("DesignPress01"), safe_to_number("DesignPress02"),
                safe_to_number("DesignPress03"), safe_to_number("DesignPress04"),
                safe_to_number("DesignPress05"), safe_to_number("DesignPress06"),
                safe_to_number("DesignPress07"), safe_to_number("DesignPress08"),
                safe_to_number("DesignPress09"), safe_to_number("DesignPress10"),
                safe_to_number("DesignPress11"), safe_to_number("DesignPress12"),
                "DesignPressRevMark",
                safe_to_number("DesignTemp01"), safe_to_number("DesignTemp02"),
                safe_to_number("DesignTemp03"), safe_to_number("DesignTemp04"),
                safe_to_number("DesignTemp05"), safe_to_number("DesignTemp06"),
                safe_to_number("DesignTemp07"), safe_to_number("DesignTemp08"),
                safe_to_number("DesignTemp09"), safe_to_number("DesignTemp10"),
                safe_to_number("DesignTemp11"), safe_to_number("DesignTemp12"),
                "DesignTempRevMark",
                "NoteIDCorrAllowance", "NoteIDServiceCode", "NoteIDWallThkTol",
                "NoteIDLongWeldEff", "NoteIDGeneralPCS", "NoteIDDesignCode",
                "NoteIDPressTempTable", "NoteIDPipeSizeWthTable",
                "PressElementChange", "TempElementChange",
                safe_to_number("MaterialGroupID"), safe_to_number("SpecialReqID"), "SpecialReq",
                "NewVDSSection", "TubePCS", "EDSMJMatrix", safe_to_number("MJReductionFactor"),
                SYSDATE, SYSDATE
            FROM STG_PCS_HEADER_PROPERTIES
            WHERE plant_id = p_plant_id
              AND pcs_name = p_pcs_name
              AND pcs_revision = p_revision;  -- Include revision in WHERE

        ELSIF v_upper_type IN ('TEMP_PRESSURES', 'PCS_TEMP_PRESSURES', 'TEMP-PRESSURES') THEN
            -- ===== TEMP_PRESSURES Handler =====
            -- No DELETE needed - tables cleared at ETL start

            INSERT INTO STG_PCS_TEMP_PRESSURES (
                plant_id, pcs_name, pcs_revision,
                "Temperature", "Pressure"
            )
            SELECT
                p_plant_id, p_pcs_name, p_revision,
                jt.Temperature, jt.Pressure
            FROM JSON_TABLE(v_json, '$.getTempPressure[*]'
                COLUMNS (
                    Temperature VARCHAR2(50) PATH '$.Temperature',
                    Pressure VARCHAR2(50) PATH '$.Pressure'
                )) jt;

            -- STG_* → Core Table
            INSERT INTO PCS_TEMP_PRESSURES (
                pcs_temp_pressures_guid, plant_id, pcs_name, pcs_revision,
                temperature, pressure,
                created_date, last_modified_date
            )
            SELECT
                SYS_GUID(), plant_id, pcs_name, pcs_revision,
                TO_NUMBER("Temperature"), TO_NUMBER("Pressure"),
                SYSDATE, SYSDATE
            FROM STG_PCS_TEMP_PRESSURES
            WHERE plant_id = p_plant_id
              AND pcs_name = p_pcs_name
              AND pcs_revision = p_revision;

        ELSIF v_upper_type IN ('PIPE_SIZES', 'PCS_PIPE_SIZES', 'PIPE-SIZES') THEN
            -- ===== PIPE_SIZES Handler =====
            -- No DELETE needed - tables cleared at ETL start

            INSERT INTO STG_PCS_PIPE_SIZES (
                plant_id, pcs_name, pcs_revision,
                "PCS", "Revision",
                "NomSize", "OuterDiam", "WallThickness", "Schedule",
                "UnderTolerance", "CorrosionAllowance", "WeldingFactor",
                "DimElementChange", "ScheduleInMatrix"
            )
            SELECT
                p_plant_id, p_pcs_name, p_revision,
                json_pcs, json_revision,
                nom_size, outer_diam, wall_thickness, schedule,
                under_tolerance, corrosion_allowance, welding_factor,
                dim_element_change, schedule_in_matrix
            FROM JSON_TABLE(v_json, '$'
                COLUMNS (
                    json_pcs VARCHAR2(100) PATH '$.PCS',
                    json_revision VARCHAR2(50) PATH '$.Revision',
                    NESTED PATH '$.getPipeSize[*]'
                    COLUMNS (
                        nom_size VARCHAR2(50) PATH '$.NomSize',
                        outer_diam VARCHAR2(50) PATH '$.OuterDiam',
                        wall_thickness VARCHAR2(50) PATH '$.WallThickness',
                        schedule VARCHAR2(50) PATH '$.Schedule',
                        under_tolerance VARCHAR2(50) PATH '$.UnderTolerance',
                        corrosion_allowance VARCHAR2(50) PATH '$.CorrosionAllowance',
                        welding_factor VARCHAR2(50) PATH '$.WeldingFactor',
                        dim_element_change VARCHAR2(50) PATH '$.DimElementChange',
                        schedule_in_matrix VARCHAR2(50) PATH '$.ScheduleInMatrix'
                    )
                )) jt;

            -- STG_* → Core Table
            INSERT INTO PCS_PIPE_SIZES (
                pcs_pipe_sizes_guid, plant_id, pcs_name, pcs_revision,
                pcs, revision, nom_size, outer_diam, wall_thickness, schedule,
                under_tolerance, corrosion_allowance, welding_factor,
                dim_element_change, schedule_in_matrix,
                created_date, last_modified_date
            )
            SELECT
                SYS_GUID(), plant_id, pcs_name, pcs_revision,
                "PCS", "Revision", "NomSize",
                TO_NUMBER("OuterDiam"), TO_NUMBER("WallThickness"), "Schedule",
                TO_NUMBER("UnderTolerance"), TO_NUMBER("CorrosionAllowance"), TO_NUMBER("WeldingFactor"),
                "DimElementChange", "ScheduleInMatrix",
                SYSDATE, SYSDATE
            FROM STG_PCS_PIPE_SIZES
            WHERE plant_id = p_plant_id
              AND pcs_name = p_pcs_name
              AND pcs_revision = p_revision;

        ELSIF v_upper_type IN ('PIPE_ELEMENTS', 'PCS_PIPE_ELEMENTS', 'PIPE-ELEMENTS') THEN
            -- ===== PIPE_ELEMENTS Handler =====
            -- No DELETE needed - tables cleared at ETL start

            INSERT INTO STG_PCS_PIPE_ELEMENTS (
                plant_id, pcs_name, pcs_revision,
                "PCS", "Revision", "MaterialGroupID",
                "ElementGroupNo", "LineNo", "Element",
                "DimStandard", "FromSize", "ToSize",
                "ProductForm", "Material", "MDS",
                "EDS", "EDSRevision", "ESK",
                "Revmark", "Remark", "PageBreak",
                "ElementID", "FreeText", "NoteID",
                "NewDeletedLine", "InitialInfo", "InitialRevmark",
                "MDSVariant", "MDSRevision", "Area"
            )
            SELECT
                p_plant_id, p_pcs_name, p_revision,
                json_pcs, json_revision, material_group_id,
                element_group_no, line_no, element,
                dim_standard, from_size, to_size,
                product_form, material, mds,
                eds, eds_revision, esk,
                revmark, remark, page_break,
                element_id, free_text, note_id,
                new_deleted_line, initial_info, initial_revmark,
                mds_variant, mds_revision, area
            FROM JSON_TABLE(v_json, '$'
                COLUMNS (
                    json_pcs VARCHAR2(100) PATH '$.PCS',
                    json_revision VARCHAR2(50) PATH '$.Revision',
                    material_group_id VARCHAR2(50) PATH '$.MaterialGroupID',
                    NESTED PATH '$.getPipeElement[*]'
                    COLUMNS (
                        element_group_no VARCHAR2(50) PATH '$.ElementGroupNo',
                        line_no VARCHAR2(50) PATH '$.LineNo',
                        element VARCHAR2(200) PATH '$.Element',
                        dim_standard VARCHAR2(100) PATH '$.DimStandard',
                        from_size VARCHAR2(50) PATH '$.FromSize',
                        to_size VARCHAR2(50) PATH '$.ToSize',
                        product_form VARCHAR2(100) PATH '$.ProductForm',
                        material VARCHAR2(200) PATH '$.Material',
                        mds VARCHAR2(100) PATH '$.MDS',
                        eds VARCHAR2(100) PATH '$.EDS',
                        eds_revision VARCHAR2(50) PATH '$.EDSRevision',
                        esk VARCHAR2(100) PATH '$.ESK',
                        revmark VARCHAR2(50) PATH '$.Revmark',
                        remark VARCHAR2(4000) PATH '$.Remark',
                        page_break VARCHAR2(50) PATH '$.PageBreak',
                        element_id VARCHAR2(50) PATH '$.ElementID',
                        free_text VARCHAR2(500) PATH '$.FreeText',
                        note_id VARCHAR2(50) PATH '$.NoteID',
                        new_deleted_line VARCHAR2(50) PATH '$.NewDeletedLine',
                        initial_info VARCHAR2(4000) PATH '$.InitialInfo',
                        initial_revmark VARCHAR2(50) PATH '$.InitialRevmark',
                        mds_variant VARCHAR2(100) PATH '$.MDSVariant',
                        mds_revision VARCHAR2(50) PATH '$.MDSRevision',
                        area VARCHAR2(100) PATH '$.Area'
                    )
                )) jt;

            -- STG_* → Core Table
            INSERT INTO PCS_PIPE_ELEMENTS (
                pcs_pipe_elements_guid, plant_id, pcs_name, pcs_revision,
                pcs, revision, material_group_id,
                element_group_no, line_no, element,
                dim_standard, from_size, to_size,
                product_form, material, mds,
                eds, eds_revision, esk,
                revmark, remark, page_break,
                element_id, free_text, note_id,
                new_deleted_line, initial_info, initial_revmark,
                mds_variant, mds_revision, area,
                created_date, last_modified_date
            )
            SELECT
                SYS_GUID(), plant_id, pcs_name, pcs_revision,
                "PCS", "Revision", TO_NUMBER("MaterialGroupID"),
                TO_NUMBER("ElementGroupNo"), TO_NUMBER("LineNo"), "Element",
                "DimStandard", "FromSize", "ToSize",
                "ProductForm", "Material", "MDS",
                "EDS", "EDSRevision", "ESK",
                "Revmark", SUBSTR("Remark", 1, 500), "PageBreak",
                TO_NUMBER("ElementID"), "FreeText", "NoteID",  -- NOTE_ID stays VARCHAR2
                "NewDeletedLine", SUBSTR("InitialInfo", 1, 200), "InitialRevmark",
                "MDSVariant", "MDSRevision", "Area",
                SYSDATE, SYSDATE
            FROM STG_PCS_PIPE_ELEMENTS
            WHERE plant_id = p_plant_id
              AND pcs_name = p_pcs_name
              AND pcs_revision = p_revision;

        ELSIF v_upper_type IN ('VALVE_ELEMENTS', 'PCS_VALVE_ELEMENTS', 'VALVE-ELEMENTS') THEN
            -- ===== VALVE_ELEMENTS Handler =====
            -- No DELETE needed - tables cleared at ETL start

            INSERT INTO STG_PCS_VALVE_ELEMENTS (
                plant_id, pcs_name, pcs_revision,
                "ValveGroupNo", "LineNo", "ValveType",
                "VDS", "ValveDescription", "FromSize",
                "ToSize", "Revmark", "Remark",
                "PageBreak", "NoteID", "PreviousVDS",
                "NewDeletedLine", "InitialInfo", "InitialRevmark",
                "SizeRange", "Status", "Revision"
            )
            SELECT
                p_plant_id, p_pcs_name, p_revision,
                valve_group_no, line_no, valve_type,
                vds, valve_description, from_size,
                to_size, revmark, remark,
                page_break, note_id, previous_vds,
                new_deleted_line, initial_info, initial_revmark,
                size_range, status, revision
            FROM JSON_TABLE(v_json, '$.getValveElement[*]'
                COLUMNS (
                    valve_group_no VARCHAR2(50) PATH '$.ValveGroupNo',
                    line_no VARCHAR2(50) PATH '$.LineNo',
                    valve_type VARCHAR2(100) PATH '$.ValveType',
                    vds VARCHAR2(100) PATH '$.VDS',
                    valve_description VARCHAR2(4000) PATH '$.ValveDescription',
                    from_size VARCHAR2(50) PATH '$.FromSize',
                    to_size VARCHAR2(50) PATH '$.ToSize',
                    revmark VARCHAR2(50) PATH '$.Revmark',
                    remark VARCHAR2(4000) PATH '$.Remark',
                    page_break VARCHAR2(50) PATH '$.PageBreak',
                    note_id VARCHAR2(50) PATH '$.NoteID',
                    previous_vds VARCHAR2(100) PATH '$.PreviousVDS',
                    new_deleted_line VARCHAR2(50) PATH '$.NewDeletedLine',
                    initial_info VARCHAR2(4000) PATH '$.InitialInfo',
                    initial_revmark VARCHAR2(50) PATH '$.InitialRevmark',
                    size_range VARCHAR2(100) PATH '$.SizeRange',
                    status VARCHAR2(50) PATH '$.Status',
                    revision VARCHAR2(50) PATH '$.Revision'
                )) jt;

            -- STG_* → Core Table
            INSERT INTO PCS_VALVE_ELEMENTS (
                pcs_valve_elements_guid, plant_id, pcs_name, pcs_revision,
                valve_group_no, line_no, valve_type,
                vds, valve_description, from_size,
                to_size, revmark, remark,
                page_break, note_id, previous_vds,
                new_deleted_line, initial_info, initial_revmark,
                size_range, status, revision,
                created_date, last_modified_date
            )
            SELECT
                SYS_GUID(), plant_id, pcs_name, pcs_revision,
                TO_NUMBER("ValveGroupNo"), TO_NUMBER("LineNo"), "ValveType",
                "VDS", SUBSTR("ValveDescription", 1, 500), "FromSize",
                "ToSize", "Revmark", SUBSTR("Remark", 1, 500),
                "PageBreak", "NoteID", "PreviousVDS",  -- NOTE_ID stays VARCHAR2
                "NewDeletedLine", SUBSTR("InitialInfo", 1, 200), "InitialRevmark",
                "SizeRange", "Status", "Revision",
                SYSDATE, SYSDATE
            FROM STG_PCS_VALVE_ELEMENTS
            WHERE plant_id = p_plant_id
              AND pcs_name = p_pcs_name
              AND pcs_revision = p_revision;

        ELSIF v_upper_type IN ('EMBEDDED_NOTES', 'PCS_EMBEDDED_NOTES', 'EMBEDDED-NOTES') THEN
            -- ===== EMBEDDED_NOTES Handler =====
            -- No DELETE needed - tables cleared at ETL start

            INSERT INTO STG_PCS_EMBEDDED_NOTES (
                plant_id, pcs_name, pcs_revision,
                "PCSName", "Revision", "TextSectionID",
                "TextSectionDescription", "PageBreak", "HTMLCLOB"
            )
            SELECT
                p_plant_id, p_pcs_name, p_revision,
                pcs_name_json, revision, text_section_id,
                text_section_description, page_break, html_clob
            FROM JSON_TABLE(v_json, '$.getEmbeddedNotes[*]'
                COLUMNS (
                    pcs_name_json VARCHAR2(100) PATH '$.PCSName',
                    revision VARCHAR2(50) PATH '$.Revision',
                    text_section_id VARCHAR2(50) PATH '$.TextSectionID',
                    text_section_description VARCHAR2(500) PATH '$.TextSectionDescription',
                    page_break VARCHAR2(50) PATH '$.PageBreak',
                    html_clob CLOB PATH '$.HTMLCLOB'
                )) jt;

            -- STG_* → Core Table
            INSERT INTO PCS_EMBEDDED_NOTES (
                pcs_embedded_notes_guid, plant_id, pcs_name, pcs_revision,
                pcsname, revision, text_section_id,
                text_section_description, page_break, html_clob,
                created_date, last_modified_date
            )
            SELECT
                SYS_GUID(), plant_id, pcs_name, pcs_revision,
                "PCSName", "Revision", "TextSectionID",  -- TEXT_SECTION_ID stays VARCHAR2
                "TextSectionDescription", "PageBreak", "HTMLCLOB",
                SYSDATE, SYSDATE
            FROM STG_PCS_EMBEDDED_NOTES
            WHERE plant_id = p_plant_id
              AND pcs_name = p_pcs_name
              AND pcs_revision = p_revision;

        ELSE
            -- Unknown detail type
            RAISE_APPLICATION_ERROR(-20001, 'Unknown PCS detail type: ' || p_detail_type);
        END IF;

        COMMIT;

    EXCEPTION
        WHEN OTHERS THEN
            v_error_code := SQLCODE;
            v_error_msg := SQLERRM;
            ROLLBACK;

            -- Log error
            INSERT INTO ETL_ERROR_LOG (
                error_id, endpoint_key, plant_id,
                error_timestamp, error_type, error_code,
                error_message, raw_data
            ) VALUES (
                ETL_ERROR_SEQ.NEXTVAL,
                'PCS_' || v_upper_type,
                p_plant_id,
                SYSTIMESTAMP,
                'PROCESSING_ERROR',
                v_error_code,
                v_error_msg,
                SUBSTR(v_json, 1, 4000)
            );
            COMMIT;

            -- Re-raise the error
            RAISE;
    END process_pcs_detail;

END PKG_PCS_DETAIL_PROCESSOR;
/

-- =====================================================
-- PROCEDURES
-- =====================================================

  CREATE OR REPLACE EDITIONABLE PROCEDURE "TR2000_STAGING"."FIX_EMBEDDED_NOTES_PARSER" AS
BEGIN
    EXECUTE IMMEDIATE '
    CREATE OR REPLACE PROCEDURE temp_fix_embedded_notes(
        p_json_content IN CLOB,
        p_plant_id     IN VARCHAR2,
        p_pcs_name     IN VARCHAR2,
        p_revision     IN VARCHAR2
    ) AS
    BEGIN
        -- Clear existing data
        DELETE FROM PCS_EMBEDDED_NOTES
        WHERE plant_id = p_plant_id
          AND pcs_name = p_pcs_name
          AND revision = p_revision;

        -- Insert new data
        IF JSON_EXISTS(p_json_content, ''$.getEmbeddedNote'') THEN
            INSERT INTO PCS_EMBEDDED_NOTES (
                pcs_embedded_notes_guid, plant_id, pcs_name, revision,
                text_section_id, text_section_description,
                page_break, html_clob,  -- Correct column name
                created_date, last_modified_date
            )
            SELECT
                SYS_GUID(),
                p_plant_id,
                p_pcs_name,
                p_revision,
                jt.text_section_id,
                jt.text_section_description,
                jt.page_break,
                jt.html_clob,  -- Correct mapping
                SYSDATE,
                SYSDATE
            FROM JSON_TABLE(
                p_json_content, ''$.getEmbeddedNote[*]''
                COLUMNS (
                    text_section_id          VARCHAR2(50)  PATH ''$.TextSectionID'',
                    text_section_description VARCHAR2(500) PATH ''$.TextSectionDescription'',
                    page_break               VARCHAR2(10)  PATH ''$.PageBreak'',
                    html_clob                CLOB          PATH ''$.HTMLCLOB''
                )
            ) jt;
        END IF;

        COMMIT;
    END temp_fix_embedded_notes;
    ';

    DBMS_OUTPUT.PUT_LINE('Embedded notes parser fixed');
END;
/


  CREATE OR REPLACE EDITIONABLE PROCEDURE "TR2000_STAGING"."FIX_PCS_LIST_PARSER" AS
    v_sql CLOB;
BEGIN
    -- Extract just the parse_and_load_pcs_list procedure
    v_sql := '
    CREATE OR REPLACE PROCEDURE temp_parse_and_load_pcs_list(
        p_raw_json_id IN NUMBER,
        p_plant_id    IN VARCHAR2
    ) IS
        v_json_content CLOB;
    BEGIN
        SELECT payload INTO v_json_content
        FROM RAW_JSON
        WHERE raw_json_id = p_raw_json_id;

        DELETE FROM STG_PCS_LIST
        WHERE plant_id = p_plant_id;

        -- Parse JSON - API returns PCS not Name
        IF JSON_EXISTS(v_json_content, ''$.getPlantPcsList'') THEN
            INSERT INTO STG_PCS_LIST (
                plant_id, pcs, revision, status, rev_date,
                rating_class, test_pressure, material_group, design_code,
                last_update, last_update_by, approver, notepad,
                special_req_id, tube_pcs, new_vds_section
            )
            SELECT
                p_plant_id,
                jt.pcs,
                jt.revision,
                jt.status,
                jt.rev_date,
                jt.rating_class,
                jt.test_pressure,
                jt.material_group,
                jt.design_code,
                jt.last_update,
                jt.last_update_by,
                jt.approver,
                jt.notepad,
                jt.special_req_id,
                jt.tube_pcs,
                jt.new_vds_section
            FROM JSON_TABLE(
                v_json_content, ''$.getPlantPcsList[*]''
                COLUMNS (
                    pcs              VARCHAR2(100) PATH ''$.PCS'',
                    revision         VARCHAR2(50)  PATH ''$.Revision'',
                    status           VARCHAR2(50)  PATH ''$.Status'',
                    rev_date         VARCHAR2(50)  PATH ''$.RevDate'',
                    rating_class     VARCHAR2(100) PATH ''$.RatingClass'',
                    test_pressure    VARCHAR2(50)  PATH ''$.TestPressure'',
                    material_group   VARCHAR2(100) PATH ''$.MaterialGroup'',
                    design_code      VARCHAR2(100) PATH ''$.DesignCode'',
                    last_update      VARCHAR2(50)  PATH ''$.LastUpdate'',
                    last_update_by   VARCHAR2(100) PATH ''$.LastUpdateBy'',
                    approver         VARCHAR2(100) PATH ''$.Approver'',
                    notepad          VARCHAR2(4000) PATH ''$.Notepad'',
                    special_req_id   VARCHAR2(50)  PATH ''$.SpecialReqID'',
                    tube_pcs         VARCHAR2(100) PATH ''$.TubePCS'',
                    new_vds_section  VARCHAR2(100) PATH ''$.NewVDSSection''
                )
            ) jt;
        ELSE
            -- Try direct array
            INSERT INTO STG_PCS_LIST (
                plant_id, pcs, revision, status, rev_date,
                rating_class, test_pressure, material_group, design_code,
                last_update, last_update_by, approver, notepad,
                special_req_id, tube_pcs, new_vds_section
            )
            SELECT
                p_plant_id,
                jt.pcs,
                jt.revision,
                jt.status,
                jt.rev_date,
                jt.rating_class,
                jt.test_pressure,
                jt.material_group,
                jt.design_code,
                jt.last_update,
                jt.last_update_by,
                jt.approver,
                jt.notepad,
                jt.special_req_id,
                jt.tube_pcs,
                jt.new_vds_section
            FROM JSON_TABLE(
                v_json_content, ''$[*]''
                COLUMNS (
                    pcs              VARCHAR2(100) PATH ''$.PCS'',
                    revision         VARCHAR2(50)  PATH ''$.Revision'',
                    status           VARCHAR2(50)  PATH ''$.Status'',
                    rev_date         VARCHAR2(50)  PATH ''$.RevDate'',
                    rating_class     VARCHAR2(100) PATH ''$.RatingClass'',
                    test_pressure    VARCHAR2(50)  PATH ''$.TestPressure'',
                    material_group   VARCHAR2(100) PATH ''$.MaterialGroup'',
                    design_code      VARCHAR2(100) PATH ''$.DesignCode'',
                    last_update      VARCHAR2(50)  PATH ''$.LastUpdate'',
                    last_update_by   VARCHAR2(100) PATH ''$.LastUpdateBy'',
                    approver         VARCHAR2(100) PATH ''$.Approver'',
                    notepad          VARCHAR2(4000) PATH ''$.Notepad'',
                    special_req_id   VARCHAR2(50)  PATH ''$.SpecialReqID'',
                    tube_pcs         VARCHAR2(100) PATH ''$.TubePCS'',
                    new_vds_section  VARCHAR2(100) PATH ''$.NewVDSSection''
                )
            ) jt;
        END IF;

        -- Load into PCS_LIST with proper column mapping
        INSERT INTO PCS_LIST (
            pcs_list_guid,
            plant_id,
            pcs_name,      -- Map from PCS
            revision,      -- Use revision as-is (not current_revision)
            status,
            rev_date,
            rating_class,
            test_pressure,
            material_group,
            design_code,
            last_update,
            last_update_by,
            approver,
            notepad,
            special_req_id,
            tube_pcs,
            new_vds_section,
            created_date,
            last_modified_date
        )
        SELECT
            SYS_GUID(),
            plant_id,
            pcs,           -- Map PCS to pcs_name
            revision,
            status,
            PKG_DATE_UTILS.safe_parse_date(rev_date),
            rating_class,
            TO_NUMBER(test_pressure),
            material_group,
            design_code,
            PKG_DATE_UTILS.safe_parse_date(last_update),
            last_update_by,
            approver,
            notepad,
            TO_NUMBER(special_req_id),
            tube_pcs,
            new_vds_section,
            SYSDATE,
            SYSDATE
        FROM STG_PCS_LIST
        WHERE plant_id = p_plant_id
          AND pcs IS NOT NULL;
    END temp_parse_and_load_pcs_list;
    ';

    EXECUTE IMMEDIATE v_sql;
    DBMS_OUTPUT.PUT_LINE('Temporary procedure created');
END;
/


  CREATE OR REPLACE EDITIONABLE PROCEDURE "TR2000_STAGING"."FIX_VDS_CATALOG_PARSER" AS
BEGIN
    EXECUTE IMMEDIATE '
    CREATE OR REPLACE PROCEDURE temp_fix_vds_catalog(
        p_json_content IN CLOB
    ) AS
    BEGIN
        -- Clear existing VDS catalog
        DELETE FROM VDS_LIST;

        -- Parse and load VDS catalog
        IF JSON_EXISTS(p_json_content, ''$.getVDSList'') THEN
            INSERT INTO VDS_LIST (
                vds_list_guid,  -- Correct column name
                vds_name,
                revision,
                status,
                rev_date,
                description,
                valve_type_id,
                rating_class_id,
                material_group_id,
                end_connection_id,
                bore_id,
                size_range,
                custom_name,
                subsegment_list,
                created_date,
                last_modified_date
            )
            SELECT
                SYS_GUID(),  -- Generate GUID
                jt.vds_name,
                jt.revision,
                jt.status,
                PKG_DATE_UTILS.safe_parse_date(jt.rev_date),
                jt.description,
                TO_NUMBER(jt.valve_type_id),
                TO_NUMBER(jt.rating_class_id),
                TO_NUMBER(jt.material_group_id),
                TO_NUMBER(jt.end_connection_id),
                TO_NUMBER(jt.bore_id),
                jt.size_range,
                jt.custom_name,
                jt.subsegment_list,
                SYSDATE,
                SYSDATE
            FROM JSON_TABLE(
                p_json_content, ''$.getVDSList[*]''
                COLUMNS (
                    vds_name           VARCHAR2(100) PATH ''$.VDS'',
                    revision           VARCHAR2(50)  PATH ''$.Revision'',
                    status             VARCHAR2(50)  PATH ''$.Status'',
                    rev_date           VARCHAR2(50)  PATH ''$.RevDate'',
                    description        VARCHAR2(500) PATH ''$.Description'',
                    valve_type_id      VARCHAR2(50)  PATH ''$.ValveTypeID'',
                    rating_class_id    VARCHAR2(50)  PATH ''$.RatingClassID'',
                    material_group_id  VARCHAR2(50)  PATH ''$.MaterialGroupID'',
                    end_connection_id  VARCHAR2(50)  PATH ''$.EndConnectionID'',
                    bore_id            VARCHAR2(50)  PATH ''$.BoreID'',
                    size_range         VARCHAR2(100) PATH ''$.SizeRange'',
                    custom_name        VARCHAR2(200) PATH ''$.CustomName'',
                    subsegment_list    VARCHAR2(500) PATH ''$.SubsegmentList''
                )
            ) jt;
        END IF;

        COMMIT;
    END temp_fix_vds_catalog;
    ';

    DBMS_OUTPUT.PUT_LINE('VDS catalog parser fixed');
END;
/


  CREATE OR REPLACE EDITIONABLE PROCEDURE "TR2000_STAGING"."TEMP_FIX_VDS_PARSE" (p_raw_json_id IN NUMBER) IS
    v_json CLOB;
BEGIN
    SELECT payload INTO v_json FROM RAW_JSON WHERE raw_json_id = p_raw_json_id;

    -- Clear all VDS catalog data
    DELETE FROM STG_VDS_LIST;
    DELETE FROM VDS_LIST;

    -- Parse JSON with correct path
    INSERT INTO STG_VDS_LIST (
        "VDS", "Revision", "Status", "RevDate", "LastUpdate",
        "LastUpdateBy", "Description", "Notepad", "SpecialReqID",
        "ValveTypeID", "RatingClassID", "MaterialGroupID",
        "EndConnectionID", "BoreID", "VDSSizeID", "SizeRange",
        "CustomName", "SubsegmentList"
    )
    SELECT
        jt."VDS", jt."Revision", jt."Status", jt."RevDate", jt."LastUpdate",
        jt."LastUpdateBy", jt."Description", jt."Notepad", jt."SpecialReqID",
        jt."ValveTypeID", jt."RatingClassID", jt."MaterialGroupID",
        jt."EndConnectionID", jt."BoreID", jt."VDSSizeID", jt."SizeRange",
        jt."CustomName", jt."SubsegmentList"
    FROM JSON_TABLE(v_json, '$.getVDS[*]'
        COLUMNS (
            "VDS" VARCHAR2(100) PATH '$.VDS',
            "Revision" VARCHAR2(50) PATH '$.Revision',
            "Status" VARCHAR2(50) PATH '$.Status',
            "RevDate" VARCHAR2(50) PATH '$.RevDate',
            "LastUpdate" VARCHAR2(50) PATH '$.LastUpdate',
            "LastUpdateBy" VARCHAR2(100) PATH '$.LastUpdateBy',
            "Description" VARCHAR2(500) PATH '$.Description',
            "Notepad" VARCHAR2(4000) PATH '$.Notepad',
            "SpecialReqID" VARCHAR2(50) PATH '$.SpecialReqID',
            "ValveTypeID" VARCHAR2(50) PATH '$.ValveTypeID',
            "RatingClassID" VARCHAR2(50) PATH '$.RatingClassID',
            "MaterialGroupID" VARCHAR2(50) PATH '$.MaterialGroupID',
            "EndConnectionID" VARCHAR2(50) PATH '$.EndConnectionID',
            "BoreID" VARCHAR2(50) PATH '$.BoreID',
            "VDSSizeID" VARCHAR2(50) PATH '$.VDSSizeID',
            "SizeRange" VARCHAR2(100) PATH '$.SizeRange',
            "CustomName" VARCHAR2(200) PATH '$.CustomName',
            "SubsegmentList" VARCHAR2(500) PATH '$.SubsegmentList'
        )) jt;

    -- Move to core tables
    INSERT INTO VDS_LIST (
        vds_list_guid, vds_name, revision, status, rev_date,
        last_update, last_update_by, description, notepad,
        special_req_id, valve_type_id, rating_class_id,
        material_group_id, end_connection_id, bore_id,
        vds_size_id, size_range, custom_name, subsegment_list,
        created_date, last_modified_date
    )
    SELECT
        SYS_GUID(), "VDS", "Revision", "Status",
        PKG_DATE_UTILS.safe_parse_date("RevDate"),
        PKG_DATE_UTILS.safe_parse_date("LastUpdate"),
        "LastUpdateBy", "Description", "Notepad",
        TO_NUMBER("SpecialReqID"), TO_NUMBER("ValveTypeID"),
        TO_NUMBER("RatingClassID"), TO_NUMBER("MaterialGroupID"),
        TO_NUMBER("EndConnectionID"), TO_NUMBER("BoreID"),
        TO_NUMBER("VDSSizeID"), "SizeRange", "CustomName",
        "SubsegmentList", SYSDATE, SYSDATE
    FROM STG_VDS_LIST;

    COMMIT;
END;
/

-- =====================================================
-- FUNCTIONS
-- =====================================================

  CREATE OR REPLACE EDITIONABLE FUNCTION "TR2000_STAGING"."EXTRACT_PARAM_VALUE" (
    p_endpoint_value VARCHAR2,
    p_endpoint_template VARCHAR2,
    p_param_name VARCHAR2
) RETURN VARCHAR2 DETERMINISTIC IS
    v_pattern VARCHAR2(1000);
    v_template_work VARCHAR2(1000);
    v_value_work VARCHAR2(1000);
    v_param_placeholder VARCHAR2(100);
    v_start_pos NUMBER;
    v_end_pos NUMBER;
    v_before_text VARCHAR2(500);
    v_after_text VARCHAR2(500);
    v_extracted VARCHAR2(500);
BEGIN
    -- Handle NULL inputs
    IF p_endpoint_value IS NULL OR p_endpoint_template IS NULL OR p_param_name IS NULL THEN
        RETURN NULL;
    END IF;

    v_template_work := p_endpoint_template;
    v_value_work := p_endpoint_value;
    v_param_placeholder := '{' || p_param_name || '}';

    -- Find position of parameter in template
    v_start_pos := INSTR(v_template_work, v_param_placeholder);
    IF v_start_pos = 0 THEN
        RETURN NULL; -- Parameter not in this template
    END IF;

    -- Get text before parameter
    v_before_text := SUBSTR(v_template_work, 1, v_start_pos - 1);

    -- Get text after parameter
    v_after_text := SUBSTR(v_template_work, v_start_pos + LENGTH(v_param_placeholder));

    -- Find next delimiter or parameter after our parameter
    IF v_after_text IS NOT NULL THEN
        -- Find first / or { in after_text
        v_end_pos := LEAST(
            NVL(NULLIF(INSTR(v_after_text, '/'), 0), 9999),
            NVL(NULLIF(INSTR(v_after_text, '{'), 0), 9999)
        );
        IF v_end_pos < 9999 THEN
            v_after_text := SUBSTR(v_after_text, 1, v_end_pos - 1);
        END IF;
    END IF;

    -- Now extract from actual value
    -- Remove the before_text from start
    IF v_before_text IS NOT NULL THEN
        v_value_work := SUBSTR(v_value_work, LENGTH(v_before_text) + 1);
    END IF;

    -- Find where after_text starts (if any)
    IF v_after_text IS NOT NULL AND LENGTH(v_after_text) > 0 THEN
        v_end_pos := INSTR(v_value_work, v_after_text);
        IF v_end_pos > 0 THEN
            v_extracted := SUBSTR(v_value_work, 1, v_end_pos - 1);
        ELSE
            v_extracted := v_value_work;
        END IF;
    ELSE
        -- No after text, take everything up to next / or end
        v_end_pos := INSTR(v_value_work, '/');
        IF v_end_pos > 0 THEN
            v_extracted := SUBSTR(v_value_work, 1, v_end_pos - 1);
        ELSE
            v_extracted := v_value_work;
        END IF;
    END IF;

    RETURN v_extracted;
EXCEPTION
    WHEN OTHERS THEN
        RETURN NULL;
END extract_param_value;
/


  CREATE OR REPLACE EDITIONABLE FUNCTION "TR2000_STAGING"."GET_RAW_JSON_SIZE" (p_raw_json_id NUMBER)
RETURN NUMBER IS
    v_size NUMBER;
BEGIN
    SELECT NVL(DBMS_LOB.GETLENGTH(payload), 0)
    INTO v_size
    FROM RAW_JSON
    WHERE raw_json_id = p_raw_json_id;

    RETURN v_size;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN 0;
    WHEN OTHERS THEN
        RETURN 0;
END get_raw_json_size;
/


  CREATE OR REPLACE EDITIONABLE FUNCTION "TR2000_STAGING"."SAFE_TO_NUMBER" (p_value VARCHAR2) RETURN NUMBER IS
BEGIN
    IF p_value IS NULL THEN
        RETURN NULL;
    END IF;
    RETURN TO_NUMBER(p_value);
EXCEPTION
    WHEN VALUE_ERROR THEN
        RETURN NULL;
    WHEN OTHERS THEN
        RETURN NULL;
END safe_to_number;
/

