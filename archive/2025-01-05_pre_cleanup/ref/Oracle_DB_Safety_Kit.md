# Oracle “DB Safety Kit” — Schema‑Local DDL Snapshots & Easy Restore

**Author:** Vivek’s AI copilot  
**Audience:** Developers and DBAs working in Oracle (XE/SE/EE) who want a *self‑contained* backup of all code/DDL *inside the schema itself*, with simple capture/restore steps.  
**Goal:** Make “oops” events reversible and keep DB + scripts in sync by taking repeatable, searchable **snapshots** of all objects’ DDL right inside Oracle — like a light, schema‑local “git for DDL.”

---

## Why this exists

- Pasting large packages into SQL*Plus/CLI can truncate or produce **empty stubs** (`CREATE OR REPLACE` with nothing inside).  
- Deploy script drift happens: files don’t match what’s actually in the DB.  
- You want a **push‑button, no‑external‑tool** snapshot/restore of *everything* (packages, views, triggers, etc.) while still allowing later integration with Git/Liquibase/Flyway.

**This kit provides:**
- Two tables to store **snapshots** and per‑object **DDL**.
- A package `DDL_SNAPSHOT` with:
  - `SNAPSHOT_ALL(tag)` — capture DDL for every object in the schema.
  - `SNAPSHOT_OBJECT(...)` — capture one object on demand.
  - `GET_OBJECT_DDL(...)` — retrieve stored DDL.
  - `RESTORE_OBJECT(...)` — recreate a single object from a snapshot.
  - `RESTORE_ALL(...)` — (optional) bulk replay for code objects in a safe order (tables **skipped by default**).
- Lightweight **hash** of DDL (first 32k chars) to compare snapshot deltas.
- Optional **guardrails**: block “empty package bodies” and/or archive the *previous* source before it’s overwritten.
- Optional **nightly job** to take snapshots automatically.
- Optional **Data Pump** snippet for data‑level safety.

> ⚠️ **Scope:** This captures **DDL** (code/definitions). It is **not** a data backup. Keep Data Pump/RMAN for data/PITR. The stored hash is a quick change indicator (first 32k chars) — the *CLOB DDL is authoritative*.

---

## Quick Start (5 minutes)

1) Run the **tables** section below.  
2) Compile the **package spec & body**.  
3) Take your first snapshot:
   ```sql
   BEGIN
     ddl_snapshot.snapshot_all(p_tag => 'baseline');
   END;
   /
   ```
4) Verify:
   ```sql
   SELECT COUNT(*) objects, MIN(created_at), MAX(created_at)
   FROM ddl_snapshot_objects o JOIN ddl_snapshots s ON s.snapshot_id = o.snapshot_id
   WHERE s.tag = 'baseline';
   ```
5) If a package is broken later:
   ```sql
   BEGIN
     ddl_snapshot.restore_object(
       p_snapshot_id => (SELECT snapshot_id FROM ddl_snapshots WHERE tag='baseline'),
       p_owner       => USER,
       p_object_name => 'TR2000_LOADER',
       p_object_type => 'PACKAGE BODY'
     );
   END;
   /
   ```

---

## 1) Schema‑Local Tables (DDL Vault)

```sql
-- Tablespace/logging clauses optional; adjust as needed.

CREATE TABLE ddl_snapshots (
  snapshot_id   NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tag           VARCHAR2(200),
  created_at    TIMESTAMP DEFAULT SYSTIMESTAMP,
  created_by    VARCHAR2(128) DEFAULT SYS_CONTEXT('USERENV','SESSION_USER')
);

CREATE TABLE ddl_snapshot_objects (
  id            NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  snapshot_id   NUMBER NOT NULL REFERENCES ddl_snapshots(snapshot_id) ON DELETE CASCADE,
  owner         VARCHAR2(128) NOT NULL,
  object_name   VARCHAR2(128) NOT NULL,
  object_type   VARCHAR2(30)  NOT NULL,
  ddl_text      CLOB,                         -- Stored DDL (CREATE OR REPLACE …)
  ddl_hash      VARCHAR2(64),                 -- SHA256 of first 32k chars (indicator only)
  captured_at   TIMESTAMP DEFAULT SYSTIMESTAMP,
  CONSTRAINT uq_snap_obj UNIQUE (snapshot_id, owner, object_name, object_type)
);

CREATE INDEX ix_snap_objs_name ON ddl_snapshot_objects (owner, object_name, object_type);
```

---

## 2) Package: Capture & Restore

### 2.1 Package Spec

```sql
CREATE OR REPLACE PACKAGE ddl_snapshot AUTHID CURRENT_USER AS
  -- Take a full schema snapshot
  PROCEDURE snapshot_all(p_tag IN VARCHAR2 DEFAULT NULL);

  -- Capture a single object (creates a one‑object snapshot)
  PROCEDURE snapshot_object(
    p_owner       IN VARCHAR2,
    p_object_name IN VARCHAR2,
    p_object_type IN VARCHAR2,
    p_snapshot_id OUT NUMBER
  );

  -- Get stored DDL for an object from a given snapshot
  FUNCTION get_object_ddl(
    p_snapshot_id IN NUMBER,
    p_owner       IN VARCHAR2,
    p_object_name IN VARCHAR2,
    p_object_type IN VARCHAR2
  ) RETURN CLOB;

  -- Restore one object (runs the stored DDL)
  PROCEDURE restore_object(
    p_snapshot_id IN NUMBER,
    p_owner       IN VARCHAR2,
    p_object_name IN VARCHAR2,
    p_object_type IN VARCHAR2
  );

  -- OPTIONAL: restore many objects from a snapshot (tables skipped by default)
  PROCEDURE restore_all(
    p_snapshot_id  IN NUMBER,
    p_include_types IN SYS.ODCIVARCHAR2LIST DEFAULT NULL, -- e.g., SYS.ODCIVARCHAR2LIST('PACKAGE','VIEW')
    p_exclude_types IN SYS.ODCIVARCHAR2LIST DEFAULT SYS.ODCIVARCHAR2LIST('TABLE','INDEX') -- default skips
  );
END ddl_snapshot;
/
```

### 2.2 Package Body

```sql
CREATE OR REPLACE PACKAGE BODY ddl_snapshot AS

  -- Normalize object types to Oracle dictionary names
  FUNCTION norm_type(p_type IN VARCHAR2) RETURN VARCHAR2 IS
    v VARCHAR2(30) := UPPER(TRIM(p_type));
  BEGIN
    IF v IN ('PKG','PACKAGE SPEC') THEN RETURN 'PACKAGE'; END IF;
    IF v IN ('PKB','PACKAGE BODY') THEN RETURN 'PACKAGE BODY'; END IF;
    RETURN v;
  END;

  -- Configure DBMS_METADATA transforms once per session
  PROCEDURE set_xforms IS
  BEGIN
    DBMS_METADATA.set_transform_param(DBMS_METADATA.session_transform,'STORAGE',false);
    DBMS_METADATA.set_transform_param(DBMS_METADATA.session_transform,'TABLESPACE',true);
    DBMS_METADATA.set_transform_param(DBMS_METADATA.session_transform,'SEGMENT_ATTRIBUTES',false);
    DBMS_METADATA.set_transform_param(DBMS_METADATA.session_transform,'PRETTY',true);
    DBMS_METADATA.set_transform_param(DBMS_METADATA.session_transform,'CONSTRAINTS',true);
    DBMS_METADATA.set_transform_param(DBMS_METADATA.session_transform,'REF_CONSTRAINTS',true);
    DBMS_METADATA.set_transform_param(DBMS_METADATA.session_transform,'SQLTERMINATOR',true);
    DBMS_METADATA.set_transform_param(DBMS_METADATA.session_transform,'CONSTRAINTS_AS_ALTER',true);
  END;

  -- Add OR REPLACE for DDL that benefits from it
  FUNCTION add_or_replace(p_type IN VARCHAR2, p_ddl IN CLOB) RETURN CLOB IS
    v CLOB := p_ddl;
  BEGIN
    IF p_type IN ('VIEW','PACKAGE','PACKAGE BODY','PROCEDURE','FUNCTION','TRIGGER','TYPE','TYPE BODY') THEN
      v := REGEXP_REPLACE(v, '^(\\s*CREATE\\s+)', '\\1OR REPLACE ', 1, 1, 'i');
    END IF;
    RETURN v;
  END;

  -- Lightweight hash of first 32k chars (indicator only)
  FUNCTION ddl_hash32k(p_ddl IN CLOB) RETURN VARCHAR2 IS
  BEGIN
    IF p_ddl IS NULL THEN
      RETURN NULL;
    ELSE
      RETURN STANDARD_HASH(DBMS_LOB.SUBSTR(p_ddl, 32767, 1), 'SHA256');
    END IF;
  END;

  -- Get DDL for one object
  FUNCTION fetch_ddl(p_owner IN VARCHAR2, p_name IN VARCHAR2, p_type IN VARCHAR2) RETURN CLOB IS
    doc  CLOB;
    vtyp VARCHAR2(30) := norm_type(p_type);
  BEGIN
    set_xforms;
    CASE vtyp
      WHEN 'TABLE'             THEN doc := DBMS_METADATA.GET_DDL('TABLE', p_name, p_owner);
      WHEN 'VIEW'              THEN doc := DBMS_METADATA.GET_DDL('VIEW', p_name, p_owner);
      WHEN 'SEQUENCE'          THEN doc := DBMS_METADATA.GET_DDL('SEQUENCE', p_name, p_owner);
      WHEN 'PACKAGE'           THEN doc := DBMS_METADATA.GET_DDL('PACKAGE', p_name, p_owner);
      WHEN 'PACKAGE BODY'      THEN doc := DBMS_METADATA.GET_DDL('PACKAGE_BODY', p_name, p_owner);
      WHEN 'PROCEDURE'         THEN doc := DBMS_METADATA.GET_DDL('PROCEDURE', p_name, p_owner);
      WHEN 'FUNCTION'          THEN doc := DBMS_METADATA.GET_DDL('FUNCTION', p_name, p_owner);
      WHEN 'TRIGGER'           THEN doc := DBMS_METADATA.GET_DDL('TRIGGER', p_name, p_owner);
      WHEN 'TYPE'              THEN doc := DBMS_METADATA.GET_DDL('TYPE', p_name, p_owner);
      WHEN 'TYPE BODY'         THEN doc := DBMS_METADATA.GET_DDL('TYPE_BODY', p_name, p_owner);
      WHEN 'MATERIALIZED VIEW' THEN doc := DBMS_METADATA.GET_DDL('MATERIALIZED_VIEW', p_name, p_owner);
      WHEN 'SYNONYM'           THEN doc := DBMS_METADATA.GET_DDL('SYNONYM', p_name, p_owner);
      WHEN 'INDEX'             THEN doc := DBMS_METADATA.GET_DDL('INDEX', p_name, p_owner);
      ELSE
        BEGIN
          doc := DBMS_METADATA.GET_DDL(vtyp, p_name, p_owner);
        EXCEPTION WHEN OTHERS THEN
          doc := NULL;
        END;
    END CASE;

    IF doc IS NOT NULL THEN
      doc := add_or_replace(vtyp, doc);
    END IF;

    RETURN doc;
  END;

  PROCEDURE snapshot_object(
    p_owner       IN VARCHAR2,
    p_object_name IN VARCHAR2,
    p_object_type IN VARCHAR2,
    p_snapshot_id OUT NUMBER
  ) IS
    v_snap_id NUMBER;
    v_ddl     CLOB;
  BEGIN
    INSERT INTO ddl_snapshots(tag) VALUES ('OBJECT-'||p_object_name) RETURNING snapshot_id INTO v_snap_id;

    v_ddl := fetch_ddl(p_owner, p_object_name, p_object_type);

    INSERT INTO ddl_snapshot_objects(
      snapshot_id, owner, object_name, object_type, ddl_text, ddl_hash
    ) VALUES (
      v_snap_id, p_owner, p_object_name, norm_type(p_object_type), v_ddl, ddl_hash32k(v_ddl)
    );

    p_snapshot_id := v_snap_id;
  END;

  PROCEDURE snapshot_all(p_tag IN VARCHAR2 DEFAULT NULL) IS
    v_snap_id NUMBER;
  BEGIN
    INSERT INTO ddl_snapshots(tag) VALUES (p_tag) RETURNING snapshot_id INTO v_snap_id;

    FOR r IN (
      SELECT object_name, object_type
      FROM   user_objects
      WHERE  object_type IN (
        'TABLE','VIEW','SEQUENCE','PACKAGE','PACKAGE BODY',
        'PROCEDURE','FUNCTION','TRIGGER','TYPE','TYPE BODY',
        'MATERIALIZED VIEW','SYNONYM','INDEX'
      )
      AND    object_name NOT LIKE 'BIN$%' -- Skip recycle bin
      ORDER  BY CASE object_type
                 WHEN 'SEQUENCE' THEN 1
                 WHEN 'TYPE' THEN 2
                 WHEN 'TYPE BODY' THEN 3
                 WHEN 'TABLE' THEN 4
                 WHEN 'VIEW' THEN 5
                 WHEN 'SYNONYM' THEN 6
                 WHEN 'PACKAGE' THEN 7
                 WHEN 'PACKAGE BODY' THEN 8
                 WHEN 'PROCEDURE' THEN 9
                 WHEN 'FUNCTION' THEN 10
                 WHEN 'TRIGGER' THEN 11
                 WHEN 'INDEX' THEN 12
                 ELSE 99
               END, object_name
    ) LOOP
      DECLARE
        v_ddl CLOB;
      BEGIN
        v_ddl := fetch_ddl(USER, r.object_name, r.object_type);
        INSERT INTO ddl_snapshot_objects(
          snapshot_id, owner, object_name, object_type, ddl_text, ddl_hash
        ) VALUES (
          v_snap_id, USER, r.object_name, norm_type(r.object_type), v_ddl, ddl_hash32k(v_ddl)
        );
      END;
    END LOOP;
  END;

  FUNCTION get_object_ddl(
    p_snapshot_id IN NUMBER,
    p_owner       IN VARCHAR2,
    p_object_name IN VARCHAR2,
    p_object_type IN VARCHAR2
  ) RETURN CLOB IS
    v CLOB;
  BEGIN
    SELECT ddl_text
      INTO v
      FROM ddl_snapshot_objects
     WHERE snapshot_id = p_snapshot_id
       AND owner       = p_owner
       AND object_name = p_object_name
       AND object_type = norm_type(p_object_type);
    RETURN v;
  EXCEPTION WHEN NO_DATA_FOUND THEN
    RETURN NULL;
  END;

  PROCEDURE restore_object(
    p_snapshot_id IN NUMBER,
    p_owner       IN VARCHAR2,
    p_object_name IN VARCHAR2,
    p_object_type IN VARCHAR2
  ) IS
    v CLOB;
  BEGIN
    v := get_object_ddl(p_snapshot_id, p_owner, p_object_name, p_object_type);
    IF v IS NULL THEN
      RAISE_APPLICATION_ERROR(-20001, 'DDL not found in snapshot.');
    END IF;
    EXECUTE IMMEDIATE v;
  END;

  PROCEDURE restore_all(
    p_snapshot_id   IN NUMBER,
    p_include_types IN SYS.ODCIVARCHAR2LIST DEFAULT NULL,
    p_exclude_types IN SYS.ODCIVARCHAR2LIST DEFAULT SYS.ODCIVARCHAR2LIST('TABLE','INDEX')
  ) IS
  BEGIN
    -- Replay in a dependency‑friendly order (code objects only by default).
    FOR r IN (
      SELECT owner, object_name, object_type, ddl_text
      FROM   ddl_snapshot_objects
      WHERE  snapshot_id = p_snapshot_id
      AND   (p_include_types IS NULL OR object_type MEMBER OF p_include_types)
      AND   (p_exclude_types IS NULL OR NOT (object_type MEMBER OF p_exclude_types))
      ORDER  BY CASE object_type
                 WHEN 'TYPE' THEN 1
                 WHEN 'TYPE BODY' THEN 2
                 WHEN 'VIEW' THEN 3
                 WHEN 'SYNONYM' THEN 4
                 WHEN 'PACKAGE' THEN 5
                 WHEN 'PACKAGE BODY' THEN 6
                 WHEN 'PROCEDURE' THEN 7
                 WHEN 'FUNCTION' THEN 8
                 WHEN 'TRIGGER' THEN 9
                 ELSE 99
               END, object_name
    ) LOOP
      IF r.ddl_text IS NOT NULL THEN
        EXECUTE IMMEDIATE r.ddl_text;
      END IF;
    END LOOP;
  END;

END ddl_snapshot;
/
```

---

## 3) Daily Usage Patterns

### Take a full snapshot (before risky work, nightly, etc.)
```sql
BEGIN
  ddl_snapshot.snapshot_all(p_tag => 'pre_api_changes_2025-09-05');
END;
/
```

### Capture a single object after editing (ad‑hoc)
```sql
DECLARE
  v_snap NUMBER;
BEGIN
  ddl_snapshot.snapshot_object(USER, 'TR2000_LOADER', 'PACKAGE BODY', v_snap);
END;
/
```

### See snapshots and diff changes
```sql
-- List snapshots
SELECT snapshot_id, tag, created_at, created_by
FROM ddl_snapshots
ORDER BY snapshot_id DESC;

-- Compare two snapshots quickly (hash is an indicator)
-- :old_id and :new_id are bind variables
SELECT a.owner, a.object_type, a.object_name,
       CASE WHEN a.ddl_hash = b.ddl_hash THEN 'UNCHANGED' ELSE 'CHANGED' END AS status
FROM   ddl_snapshot_objects a
JOIN   ddl_snapshot_objects b
  ON   b.snapshot_id = :old_id
 AND   a.object_name = b.object_name
 AND   a.object_type = b.object_type
WHERE  a.snapshot_id = :new_id
ORDER  BY status DESC, a.object_type, a.object_name;
```

### Restore a single broken object
```sql
BEGIN
  ddl_snapshot.restore_object(
    p_snapshot_id => :good_snapshot_id,
    p_owner       => USER,
    p_object_name => 'TR2000_LOADER',
    p_object_type => 'PACKAGE BODY'
  );
END;
/
```

### (Optional) Bulk restore code objects (tables skipped unless included)
```sql
BEGIN
  ddl_snapshot.restore_all(
    p_snapshot_id   => :good_snapshot_id,
    p_include_types => NULL, -- NULL = use default set/order
    p_exclude_types => SYS.ODCIVARCHAR2LIST('TABLE','INDEX') -- default skip
  );
END;
/
```

---

## 4) Optional Guardrails

### A) Block “Empty Package Body” accidents
```sql
CREATE OR REPLACE TRIGGER trg_block_empty_pkg
AFTER CREATE ON SCHEMA
DECLARE
  v_lines NUMBER;
BEGIN
  IF ORA_DICT_OBJ_TYPE = 'PACKAGE BODY' THEN
    SELECT COUNT(*)
      INTO v_lines
      FROM ALL_SOURCE
     WHERE owner = ORA_DICT_OBJ_OWNER
       AND name  = ORA_DICT_OBJ_NAME
       AND type  = 'PACKAGE BODY'
       AND REGEXP_LIKE(text, '\S'); -- any non‑whitespace
    IF v_lines < 5 THEN
      RAISE_APPLICATION_ERROR(-20001, 'Blocked: Package body appears empty/minimal.');
    END IF;
  END IF;
END;
/
```

### B) Archive previous code before replace (safety black box)

```sql
CREATE TABLE source_history (
  id            NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  owner         VARCHAR2(128),
  name          VARCHAR2(128),
  type          VARCHAR2(30),
  ddl_event     VARCHAR2(30),
  ddl_ts        TIMESTAMP DEFAULT SYSTIMESTAMP,
  triggered_by  VARCHAR2(128),
  machine       VARCHAR2(128),
  module        VARCHAR2(128),
  old_source    CLOB
);

CREATE OR REPLACE TRIGGER trg_archive_source_before_replace
BEFORE CREATE OR ALTER ON DATABASE
DECLARE
  v_src   CLOB;
BEGIN
  IF ORA_DICT_OBJ_TYPE IN ('PACKAGE','PACKAGE BODY','PROCEDURE','FUNCTION','TRIGGER','TYPE','TYPE BODY') THEN
    BEGIN
      SELECT LISTAGG(text, '') WITHIN GROUP (ORDER BY line)
      INTO   v_src
      FROM   ALL_SOURCE
      WHERE  owner = ORA_DICT_OBJ_OWNER
      AND    name  = ORA_DICT_OBJ_NAME
      AND    type  = ORA_DICT_OBJ_TYPE;
    EXCEPTION WHEN NO_DATA_FOUND THEN
      v_src := NULL;
    END;

    IF v_src IS NOT NULL THEN
      INSERT INTO source_history(owner, name, type, ddl_event, triggered_by, machine, module, old_source)
      VALUES (ORA_DICT_OBJ_OWNER, ORA_DICT_OBJ_NAME, ORA_DICT_OBJ_TYPE, ORA_SYSEVENT,
              SYS_CONTEXT('USERENV','SESSION_USER'), SYS_CONTEXT('USERENV','HOST'),
              SYS_CONTEXT('USERENV','MODULE'), v_src);
    END IF;
  END IF;
EXCEPTION WHEN OTHERS THEN
  NULL; -- don't block DDL
END;
/
```

> Note: This guard archives **code objects** (from `ALL_SOURCE`). Views/tables are handled by the snapshot package via `DBMS_METADATA`.

---

## 5) Optional Nightly Snapshot Job

```sql
BEGIN
  DBMS_SCHEDULER.CREATE_JOB(
    job_name        => 'JOB_DDL_SNAPSHOT_NIGHTLY',
    job_type        => 'PLSQL_BLOCK',
    job_action      => q'[BEGIN ddl_snapshot.snapshot_all(p_tag => 'nightly'); END;]',
    start_date      => SYSTIMESTAMP,
    repeat_interval => 'FREQ=DAILY;BYHOUR=2;BYMINUTE=0;BYSECOND=0',
    enabled         => TRUE,
    comments        => 'Takes nightly schema‑local DDL snapshot'
  );
END;
/
```

> Adjust the hour. You can also add retention (e.g., delete snapshots older than N days) with a small cleanup job.

---

## 6) Optional: Data Pump Schema Backup (Data Safety)

```bash
# Linux/WSL/PowerShell (adapt paths/users as needed)
expdp system/**** schemas=TR2000_STAGING \
  directory=BACKUP_DIR \
  dumpfile=TR2000_STAGING_$(date +%F).dmp \
  logfile=TR2000_STAGING_$(date +%F).log \
  compression=all
```
Keep 7–14 days; rotate. This complements the DDL vault (which is code‑only).

---

## 7) Team Practices (to prevent drift)

- Author PL/SQL in **files**; deploy via **scripts** (SQLcl/Liquibase). The DB vault is your **safety net**, not your only source control.
- Add **utPLSQL tests** for critical packages (CI fails if a stub sneaks in).
- Limit direct `CREATE OR REPLACE` in PROD; favor **pipelines**.
- If multiple devs: agree on **object‑per‑file** naming and review changes via PRs.

---

## 8) Troubleshooting & Notes

- If `DBMS_METADATA.GET_DDL` returns NULL for some objects, verify privileges and that the object exists in your schema. For cross‑schema capture, grant `SELECT_CATALOG_ROLE` or explicit privileges and switch to `DBA_OBJECTS`/`DBA_*` views.
- `ddl_hash` is for quick comparisons. Always use the **stored CLOB** as the source of truth when restoring.
- `RESTORE_ALL` skips tables by default to avoid destructive operations. If you **really** want to replay tables (for another environment), include `'TABLE'` in `p_include_types` and make sure the DDL suits your target.
- Guard triggers run on DDL — keep them **simple** and **non‑blocking** (on errors they should not break deployments).

---

## 9) Minimal Runner Example (apply kit cleanly)

```sql
-- run_kit.sql — execute in your schema
WHENEVER SQLERROR EXIT SQL.SQLCODE

@tables_ddl_vault.sql       -- section 1
@pkg_ddl_snapshot_spec.sql  -- section 2.1
@pkg_ddl_snapshot_body.sql  -- section 2.2
-- @guard_block_empty_pkg.sql -- optional
-- @guard_archive_source.sql  -- optional
-- @job_nightly_snapshot.sql  -- optional

EXIT
```

---

## 10) What success looks like

- A **baseline snapshot** exists and new snapshots are taken before/after significant work or nightly.  
- When a bad deploy happens, you **restore just that object** in seconds.  
- Over time, you still keep **Git/Liquibase** as the authoritative source — this vault simply guarantees that **what’s in the DB is never “unrecoverable.”**

---

**Done.** You can copy this doc into your repo (e.g., `db/docs/ddl-safety-kit.md`) and/or hand it to Claude to automate the setup and create helper scripts.
