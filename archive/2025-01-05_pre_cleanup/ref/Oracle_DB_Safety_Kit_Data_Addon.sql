
-- Oracle DB Safety Kit — Data Snapshot Add-on
-- Purpose: Snapshot and restore *rows* from selected small "control tables" inside your schema.
-- Scope: Stores each table's rows as JSON in a central table per snapshot. Best for small tables
--        (config, control, lookup). For large/critical data, use Data Pump / RMAN.
-- Requires: Oracle 19c+ (JSON features), ideally 21c/XE for JSON_OBJECT(*) convenience (we avoid it here).
-- Author: Vivek’s AI copilot

SET DEFINE OFF

------------------------------------------------------------
-- 1) Tables
------------------------------------------------------------

CREATE TABLE data_snapshots (
  snapshot_id   NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tag           VARCHAR2(200),
  created_at    TIMESTAMP DEFAULT SYSTIMESTAMP,
  created_by    VARCHAR2(128) DEFAULT SYS_CONTEXT('USERENV','SESSION_USER')
);

-- One row per table captured in a snapshot
CREATE TABLE data_snapshot_tables (
  id            NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  snapshot_id   NUMBER NOT NULL REFERENCES data_snapshots(snapshot_id) ON DELETE CASCADE,
  table_name    VARCHAR2(128) NOT NULL,
  row_count     NUMBER,
  data_json     CLOB, -- JSON array of rows
  captured_at   TIMESTAMP DEFAULT SYSTIMESTAMP,
  CONSTRAINT uq_data_snap UNIQUE (snapshot_id, table_name)
);

CREATE INDEX ix_data_snap_tbl ON data_snapshot_tables (table_name);

------------------------------------------------------------
-- 2) Package Spec
------------------------------------------------------------

CREATE OR REPLACE PACKAGE data_snapshot AUTHID CURRENT_USER AS
  -- Capture a single table's data into a new snapshot (RECOMMENDED for small tables)
  PROCEDURE snapshot_table(
    p_table_name IN VARCHAR2,
    p_where      IN VARCHAR2 DEFAULT NULL,
    p_tag        IN VARCHAR2 DEFAULT NULL,
    p_snapshot_id OUT NUMBER
  );

  -- Capture multiple tables into one snapshot
  PROCEDURE snapshot_tables(
    p_table_list IN SYS.ODCIVARCHAR2LIST,
    p_tag        IN VARCHAR2 DEFAULT NULL,
    p_snapshot_id OUT NUMBER
  );

  -- Return stored JSON for a specific table from a snapshot
  FUNCTION get_table_json(
    p_snapshot_id IN NUMBER,
    p_table_name  IN VARCHAR2
  ) RETURN CLOB;

  -- Restore a table's data from a snapshot.
  -- p_mode = 'REPLACE' (default): DELETE all rows first, then insert from snapshot
  --        = 'MERGE'  : Upsert by primary key if one exists; rows not in snapshot remain
  PROCEDURE restore_table(
    p_snapshot_id IN NUMBER,
    p_table_name  IN VARCHAR2,
    p_mode        IN VARCHAR2 DEFAULT 'REPLACE'
  );
END data_snapshot;
/
SHOW ERRORS

------------------------------------------------------------
-- 3) Package Body
------------------------------------------------------------

CREATE OR REPLACE PACKAGE BODY data_snapshot AS

  FUNCTION safe_table_name(p_table_name IN VARCHAR2) RETURN VARCHAR2 IS
  BEGIN
    -- Ensure caller passes a simple name; quote it to be safe
    RETURN DBMS_ASSERT.ENQUOTE_NAME(UPPER(TRIM(p_table_name)), TRUE);
  END;

  FUNCTION build_json_select(p_table_name IN VARCHAR2, p_where IN VARCHAR2) RETURN CLOB IS
    v_tbl   VARCHAR2(4000) := safe_table_name(p_table_name);
    v_cols  CLOB;
    v_sql   CLOB;
  BEGIN
    -- Build JSON_OBJECT column list dynamically: KEY 'COL' VALUE "COL"
    SELECT LISTAGG('KEY '''||column_name||''' VALUE "'||column_name||'"', ',') WITHIN GROUP (ORDER BY column_id)
      INTO v_cols
      FROM user_tab_columns
     WHERE table_name = UPPER(p_table_name)
       AND hidden_column = 'NO'
       AND virtual_column = 'NO';

    IF v_cols IS NULL THEN
      RAISE_APPLICATION_ERROR(-20010, 'No visible columns found for '||p_table_name);
    END IF;

    v_sql := 'SELECT JSON_ARRAYAGG(JSON_OBJECT('||v_cols||' RETURNING CLOB)) '||
             'FROM '||v_tbl||
             CASE WHEN p_where IS NOT NULL THEN ' WHERE '||p_where ELSE '' END;

    RETURN v_sql;
  END;

  FUNCTION build_insert_from_json_sql(p_table_name IN VARCHAR2) RETURN CLOB IS
    v_tbl   VARCHAR2(4000) := safe_table_name(p_table_name);
    v_cols_list  CLOB;
    v_jt_cols    CLOB;
    v_sql        CLOB;
  BEGIN
    -- Build column lists for INSERT and JSON_TABLE
    SELECT LISTAGG('"'||column_name||'"', ',') WITHIN GROUP (ORDER BY column_id),
           LISTAGG('"'||column_name||'" VARCHAR2(4000) PATH ''$.'||column_name||'''', ',') WITHIN GROUP (ORDER BY column_id)
      INTO v_cols_list, v_jt_cols
      FROM user_tab_columns
     WHERE table_name = UPPER(p_table_name)
       AND hidden_column = 'NO'
       AND virtual_column = 'NO';

    v_sql := 'INSERT INTO '||v_tbl||'('||v_cols_list||') '||CHR(10)||
             'SELECT '||v_cols_list||CHR(10)||
             'FROM JSON_TABLE(:json, ''$[*]'' COLUMNS ('||v_jt_cols||'))';

    RETURN v_sql;
  END;

  FUNCTION build_merge_from_json_sql(p_table_name IN VARCHAR2) RETURN CLOB IS
    v_tbl        VARCHAR2(4000) := safe_table_name(p_table_name);
    v_pk_cols    CLOB;
    v_cols_list  CLOB;
    v_jt_cols    CLOB;
    v_on_clause  CLOB;
    v_update_set CLOB;
    v_sql        CLOB;
  BEGIN
    -- Get primary key columns
    SELECT LISTAGG('"'||cc.column_name||'"', ' AND t."'||cc.column_name||'" = s."'||cc.column_name||'"') WITHIN GROUP (ORDER BY cc.position),
           LISTAGG('t."'||cc.column_name||'" = s."'||cc.column_name||'"', ',') WITHIN GROUP (ORDER BY cc.position)
      INTO v_on_clause, v_pk_cols
      FROM user_constraints c
      JOIN user_cons_columns cc ON cc.constraint_name = c.constraint_name
     WHERE c.table_name = UPPER(p_table_name)
       AND c.constraint_type = 'P';

    IF v_on_clause IS NULL THEN
      RAISE_APPLICATION_ERROR(-20011, 'MERGE requires a primary key on '||p_table_name||'. Use p_mode => ''REPLACE''.');
    END IF;

    -- Column lists
    SELECT LISTAGG('"'||column_name||'"', ',') WITHIN GROUP (ORDER BY column_id),
           LISTAGG('"'||column_name||'" VARCHAR2(4000) PATH ''$.'||column_name||'''', ',') WITHIN GROUP (ORDER BY column_id)
      INTO v_cols_list, v_jt_cols
      FROM user_tab_columns
     WHERE table_name = UPPER(p_table_name)
       AND hidden_column = 'NO'
       AND virtual_column = 'NO';

    -- Build update set (exclude PK columns)
    SELECT LISTAGG('t."'||c.column_name||'" = s."'||c.column_name||'"', ',')
      INTO v_update_set
      FROM user_tab_columns c
     WHERE c.table_name = UPPER(p_table_name)
       AND c.hidden_column = 'NO'
       AND c.virtual_column = 'NO'
       AND c.column_name NOT IN (
         SELECT column_name FROM user_cons_columns cc
          JOIN user_constraints k ON k.constraint_name = cc.constraint_name
         WHERE k.table_name = UPPER(p_table_name) AND k.constraint_type = 'P'
       );

    v_sql := 'MERGE INTO '||v_tbl||' t'||CHR(10)||
             'USING ('||CHR(10)||
             '  SELECT '||v_cols_list||CHR(10)||
             '  FROM JSON_TABLE(:json, ''$[*]'' COLUMNS ('||v_jt_cols||'))'||CHR(10)||
             ') s'||CHR(10)||
             'ON ('||REPLACE(v_on_clause, ' AND ', ') AND (')||')'||CHR(10)||
             'WHEN MATCHED THEN UPDATE SET '||v_update_set||CHR(10)||
             'WHEN NOT MATCHED THEN INSERT ('||v_cols_list||') VALUES ('||v_cols_list||')';

    RETURN v_sql;
  END;

  PROCEDURE snapshot_table(
    p_table_name IN VARCHAR2,
    p_where      IN VARCHAR2 DEFAULT NULL,
    p_tag        IN VARCHAR2 DEFAULT NULL,
    p_snapshot_id OUT NUMBER
  ) IS
    v_sid  NUMBER;
    v_sql  CLOB;
    v_json CLOB;
    v_cnt  NUMBER;
  BEGIN
    INSERT INTO data_snapshots(tag) VALUES (p_tag) RETURNING snapshot_id INTO v_sid;

    -- Count rows first
    EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM '||safe_table_name(p_table_name)||
                      CASE WHEN p_where IS NOT NULL THEN ' WHERE '||p_where ELSE '' END
      INTO v_cnt;

    -- Build JSON
    v_sql := build_json_select(p_table_name, p_where);
    EXECUTE IMMEDIATE v_sql INTO v_json;

    INSERT INTO data_snapshot_tables(snapshot_id, table_name, row_count, data_json)
    VALUES (v_sid, UPPER(TRIM(p_table_name)), v_cnt, v_json);

    p_snapshot_id := v_sid;
  END;

  PROCEDURE snapshot_tables(
    p_table_list IN SYS.ODCIVARCHAR2LIST,
    p_tag        IN VARCHAR2 DEFAULT NULL,
    p_snapshot_id OUT NUMBER
  ) IS
    v_sid NUMBER;
  BEGIN
    INSERT INTO data_snapshots(tag) VALUES (p_tag) RETURNING snapshot_id INTO v_sid;

    FOR i IN 1 .. p_table_list.COUNT LOOP
      DECLARE
        v_sql  CLOB;
        v_json CLOB;
        v_cnt  NUMBER;
        v_tbl  VARCHAR2(4000) := safe_table_name(p_table_list(i));
      BEGIN
        EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM '||v_tbl INTO v_cnt;
        v_sql := build_json_select(p_table_list(i), NULL);
        EXECUTE IMMEDIATE v_sql INTO v_json;

        INSERT INTO data_snapshot_tables(snapshot_id, table_name, row_count, data_json)
        VALUES (v_sid, UPPER(TRIM(p_table_list(i))), v_cnt, v_json);
      END;
    END LOOP;

    p_snapshot_id := v_sid;
  END;

  FUNCTION get_table_json(
    p_snapshot_id IN NUMBER,
    p_table_name  IN VARCHAR2
  ) RETURN CLOB IS
    v CLOB;
  BEGIN
    SELECT data_json INTO v
      FROM data_snapshot_tables
     WHERE snapshot_id = p_snapshot_id
       AND table_name  = UPPER(TRIM(p_table_name));
    RETURN v;
  EXCEPTION WHEN NO_DATA_FOUND THEN
    RETURN NULL;
  END;

  PROCEDURE restore_table(
    p_snapshot_id IN NUMBER,
    p_table_name  IN VARCHAR2,
    p_mode        IN VARCHAR2 DEFAULT 'REPLACE'
  ) IS
    v_json CLOB;
    v_sql  CLOB;
  BEGIN
    v_json := get_table_json(p_snapshot_id, p_table_name);
    IF v_json IS NULL THEN
      RAISE_APPLICATION_ERROR(-20012, 'No data snapshot found for '||p_table_name||' in snapshot '||p_snapshot_id);
    END IF;

    IF UPPER(p_mode) = 'REPLACE' THEN
      EXECUTE IMMEDIATE 'DELETE FROM '||safe_table_name(p_table_name);
      v_sql := build_insert_from_json_sql(p_table_name);
      EXECUTE IMMEDIATE v_sql USING v_json;
    ELSIF UPPER(p_mode) = 'MERGE' THEN
      v_sql := build_merge_from_json_sql(p_table_name);
      EXECUTE IMMEDIATE v_sql USING v_json;
    ELSE
      RAISE_APPLICATION_ERROR(-20013, 'Unknown p_mode: '||p_mode||' (use REPLACE or MERGE)');
    END IF;
  END;

END data_snapshot;
/
SHOW ERRORS

-- Usage examples:
--
-- BEGIN
--   -- One table with WHERE filter
--   data_snapshot.snapshot_table('CONTROL_PARAMS', p_where => 'PLANT = ''A''', p_tag => 'pre_change', p_snapshot_id => :sid);
-- END;
-- /
--
-- BEGIN
--   -- Several small control tables at once
--   data_snapshot.snapshot_tables(SYS.ODCIVARCHAR2LIST('CONTROL_PARAMS','FEATURE_FLAGS','ETL_CONFIG'), p_tag => 'nightly', p_snapshot_id => :sid);
-- END;
-- /
--
-- -- Restore (replace all rows)
-- BEGIN
--   data_snapshot.restore_table(:sid, 'FEATURE_FLAGS', p_mode => 'REPLACE'); -- or 'MERGE' if PK exists
-- END;
-- /

